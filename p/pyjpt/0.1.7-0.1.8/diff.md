# Comparing `tmp/pyjpt-0.1.7-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/pyjpt-0.1.8-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,35 @@
-Zip file size: 6210727 bytes, number of entries: 33
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 pyjpt.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 jpt/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 pyjpt-0.1.7.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 jpt/distributions/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 jpt/base/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 jpt/learning/
--rw-r--r--  2.0 unx    12754 b- defN 23-Apr-13 09:28 jpt/sequential_trees.py
--rw-r--r--  2.0 unx      351 b- defN 23-Apr-13 09:28 jpt/__init__.py
--rw-r--r--  2.0 unx      535 b- defN 23-Apr-13 09:28 jpt/version.py
--rw-r--r--  2.0 unx    88037 b- defN 23-Apr-13 09:28 jpt/trees.py
--rw-r--r--  2.0 unx    28520 b- defN 23-Apr-13 09:28 jpt/variables.py
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-13 09:28 jpt/distributions/quantile/
--rw-r--r--  2.0 unx     6213 b- defN 23-Apr-13 09:28 jpt/distributions/multivariate.py
--rw-r--r--  2.0 unx    67148 b- defN 23-Apr-13 09:28 jpt/distributions/univariate.py
--rw-r--r--  2.0 unx     5162 b- defN 23-Apr-13 09:28 jpt/distributions/utils.py
--rw-r--r--  2.0 unx      184 b- defN 23-Apr-13 09:28 jpt/distributions/__init__.py
--rwxr-xr-x  2.0 unx  3703208 b- defN 23-Apr-13 09:28 jpt/distributions/quantile/quantiles.cpython-38-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx        0 b- defN 23-Apr-13 09:28 jpt/distributions/quantile/__init__.py
--rwxr-xr-x  2.0 unx  1748672 b- defN 23-Apr-13 09:28 jpt/distributions/quantile/cdfreg.cpython-38-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx     3003 b- defN 23-Apr-13 09:28 jpt/base/sampling.py
--rw-r--r--  2.0 unx     2671 b- defN 23-Apr-13 09:28 jpt/base/constants.py
--rwxr-xr-x  2.0 unx  8431984 b- defN 23-Apr-13 09:28 jpt/base/functions.cpython-38-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx    11258 b- defN 23-Apr-13 09:28 jpt/base/utils.py
--rw-r--r--  2.0 unx        0 b- defN 23-Apr-13 09:28 jpt/base/__init__.py
--rw-r--r--  2.0 unx      241 b- defN 23-Apr-13 09:28 jpt/base/errors.py
--rwxr-xr-x  2.0 unx  1538592 b- defN 23-Apr-13 09:28 jpt/base/cutils.cpython-38-x86_64-linux-gnu.so
--rwxr-xr-x  2.0 unx  4272728 b- defN 23-Apr-13 09:28 jpt/base/intervals.cpython-38-x86_64-linux-gnu.so
--rwxr-xr-x  2.0 unx  2628400 b- defN 23-Apr-13 09:28 jpt/learning/impurity.cpython-38-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx       96 b- defN 23-Apr-13 09:28 jpt/learning/__init__.py
--rw-r--r--  2.0 unx      148 b- defN 23-Apr-13 09:28 pyjpt-0.1.7.dist-info/WHEEL
--rw-r--r--  2.0 unx        4 b- defN 23-Apr-13 09:28 pyjpt-0.1.7.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2265 b- defN 23-Apr-13 09:28 pyjpt-0.1.7.dist-info/RECORD
--rw-r--r--  2.0 unx     1355 b- defN 23-Apr-13 09:28 pyjpt-0.1.7.dist-info/METADATA
-33 files, 22553529 bytes uncompressed, 6206381 bytes compressed:  72.5%
+Zip file size: 6210660 bytes, number of entries: 33
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 pyjpt.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 jpt/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 pyjpt-0.1.8.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 jpt/distributions/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 jpt/base/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 jpt/learning/
+-rw-r--r--  2.0 unx    12754 b- defN 23-Apr-24 12:26 jpt/sequential_trees.py
+-rw-r--r--  2.0 unx      351 b- defN 23-Apr-24 12:26 jpt/__init__.py
+-rw-r--r--  2.0 unx      535 b- defN 23-Apr-24 12:26 jpt/version.py
+-rw-r--r--  2.0 unx    88164 b- defN 23-Apr-24 12:26 jpt/trees.py
+-rw-r--r--  2.0 unx    28451 b- defN 23-Apr-24 12:26 jpt/variables.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 12:26 jpt/distributions/quantile/
+-rw-r--r--  2.0 unx     6213 b- defN 23-Apr-24 12:26 jpt/distributions/multivariate.py
+-rw-r--r--  2.0 unx    66828 b- defN 23-Apr-24 12:26 jpt/distributions/univariate.py
+-rw-r--r--  2.0 unx     5162 b- defN 23-Apr-24 12:26 jpt/distributions/utils.py
+-rw-r--r--  2.0 unx      184 b- defN 23-Apr-24 12:26 jpt/distributions/__init__.py
+-rwxr-xr-x  2.0 unx  3703208 b- defN 23-Apr-24 12:26 jpt/distributions/quantile/quantiles.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-24 12:26 jpt/distributions/quantile/__init__.py
+-rwxr-xr-x  2.0 unx  1748672 b- defN 23-Apr-24 12:26 jpt/distributions/quantile/cdfreg.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     3003 b- defN 23-Apr-24 12:26 jpt/base/sampling.py
+-rw-r--r--  2.0 unx     2671 b- defN 23-Apr-24 12:26 jpt/base/constants.py
+-rwxr-xr-x  2.0 unx  8431984 b- defN 23-Apr-24 12:26 jpt/base/functions.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx    11258 b- defN 23-Apr-24 12:26 jpt/base/utils.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-24 12:26 jpt/base/__init__.py
+-rw-r--r--  2.0 unx      241 b- defN 23-Apr-24 12:26 jpt/base/errors.py
+-rwxr-xr-x  2.0 unx  1538592 b- defN 23-Apr-24 12:26 jpt/base/cutils.cpython-38-x86_64-linux-gnu.so
+-rwxr-xr-x  2.0 unx  4272728 b- defN 23-Apr-24 12:26 jpt/base/intervals.cpython-38-x86_64-linux-gnu.so
+-rwxr-xr-x  2.0 unx  2628400 b- defN 23-Apr-24 12:26 jpt/learning/impurity.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx       96 b- defN 23-Apr-24 12:26 jpt/learning/__init__.py
+-rw-r--r--  2.0 unx      148 b- defN 23-Apr-24 12:26 pyjpt-0.1.8.dist-info/WHEEL
+-rw-r--r--  2.0 unx        4 b- defN 23-Apr-24 12:26 pyjpt-0.1.8.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2265 b- defN 23-Apr-24 12:26 pyjpt-0.1.8.dist-info/RECORD
+-rw-r--r--  2.0 unx     1355 b- defN 23-Apr-24 12:26 pyjpt-0.1.8.dist-info/METADATA
+33 files, 22553267 bytes uncompressed, 6206314 bytes compressed:  72.5%
```

## zipnote {}

```diff
@@ -1,14 +1,14 @@
 Filename: pyjpt.libs/
 Comment: 
 
 Filename: jpt/
 Comment: 
 
-Filename: pyjpt-0.1.7.dist-info/
+Filename: pyjpt-0.1.8.dist-info/
 Comment: 
 
 Filename: jpt/distributions/
 Comment: 
 
 Filename: jpt/base/
 Comment: 
@@ -81,20 +81,20 @@
 
 Filename: jpt/learning/impurity.cpython-38-x86_64-linux-gnu.so
 Comment: 
 
 Filename: jpt/learning/__init__.py
 Comment: 
 
-Filename: pyjpt-0.1.7.dist-info/WHEEL
+Filename: pyjpt-0.1.8.dist-info/WHEEL
 Comment: 
 
-Filename: pyjpt-0.1.7.dist-info/top_level.txt
+Filename: pyjpt-0.1.8.dist-info/top_level.txt
 Comment: 
 
-Filename: pyjpt-0.1.7.dist-info/RECORD
+Filename: pyjpt-0.1.8.dist-info/RECORD
 Comment: 
 
-Filename: pyjpt-0.1.7.dist-info/METADATA
+Filename: pyjpt-0.1.8.dist-info/METADATA
 Comment: 
 
 Zip file comment:
```

## jpt/version.py

```diff
@@ -10,15 +10,15 @@
     'VERSION_PATCH',
     'VERSION_STRING_FULL',
     'VERSION_STRING_SHORT',
     '__version__',
 ]
 
 
-VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH = (0, 1, 7)
+VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH = (0, 1, 8)
 VERSION_STRING_SHORT = '%s.%s' % (VERSION_MAJOR, VERSION_MINOR)
 VERSION_STRING_FULL = '%s.%s' % (VERSION_STRING_SHORT, VERSION_PATCH)
 
 
 __version__ = VERSION_STRING_FULL
```

## jpt/trees.py

```diff
@@ -370,32 +370,42 @@
     def __hash__(self):
         return hash((type(self), ((k.name, v) for k, v in self.distributions.items()), self.prior))
 
     def to_json(self) -> Dict[str, Any]:
         """
         :return: The DecisionNode as a json serializable dict.
         """
-        return {'idx': self.idx,
-                'distributions': self.distributions.to_json(),
-                'prior': self.prior,
-                'samples': self.samples,
-                's_indices': [int(i) for i in self.s_indices],
-                'parent': ifnone(self.parent, None, attrgetter('idx')),
-                'child_idx': self.parent.children.index(self) if self.parent is not None else -1}
+        return {
+            'idx': self.idx,
+            'distributions': self.distributions.to_json(),
+            'prior': self.prior,
+            'samples': self.samples,
+            's_indices': [int(i) for i in self.s_indices],
+            'parent': ifnone(self.parent, None, attrgetter('idx')),
+            'child_idx': self.parent.children.index(self) if self.parent is not None else -1
+        }
 
     @staticmethod
     def from_json(tree: 'JPT', data: Dict[str, Any]) -> 'Leaf':
         """
         Construct a Decision node from a json dict.
         :param tree: The tree to mount the node in
         :param data: The data describing the members of the node
         :return: the constructed and mounted DecisionNode
         """
-        leaf = Leaf(idx=data['idx'], prior=data['prior'], parent=tree.innernodes.get(data['parent']))
-        leaf.distributions = VariableMap.from_json(tree.variables, data['distributions'], Distribution)
+        leaf = Leaf(
+            idx=data['idx'],
+            prior=data['prior'],
+            parent=tree.innernodes.get(data['parent'])
+        )
+        leaf.distributions = VariableMap(
+            {
+                tree.varnames[v]: tree.varnames[v].domain.from_json(d) for v, d in data['distributions'].items()
+            }
+        )
         leaf._path = []
         if leaf.parent is not None:
             leaf.parent.set_child(data['child_idx'], leaf)
         leaf.prior = data['prior']
         leaf.samples = data['samples']
         if 's_indices' in data:
             leaf.s_indices = np.array(data['s_indices'])
@@ -510,15 +520,14 @@
                 result *= likelihood
 
             return result
 
         else:
             raise ValueError("Unknown Datatype for Conditional JPT, type is %s" % type(value))
 
-
     def parallel_likelihood(self, queries: np.ndarray, dirac_scaling: float = 2.,  min_distances: VariableMap = None) \
             -> np.ndarray:
         """
         Calculate the probability of a (partial) query. Exploits the independence assumption
         :param queries: A VariableMap that maps to singular values (numeric or symbolic)
             or ranges (continuous set, set)
         :type queries: VariableMap
@@ -811,15 +820,15 @@
             DecisionNode.from_json(jpt, d)
         for d in data['leaves']:
             Leaf.from_json(jpt, d)
 
         jpt.priors = VariableMap({
             jpt.varnames[varname]: jpt.varnames[varname].domain.from_json(dist)
             for varname, dist in data['priors'].items()
-        }.items())
+        })
         jpt.root = jpt.allnodes[data.get('root')] if data.get('root') is not None else None
         return jpt
 
     def __getstate__(self):
         return self.to_json()
 
     def __setstate__(self, state):
@@ -1431,15 +1440,15 @@
     def learn(self, data=None, rows=None, columns=None, keep_samples=False) -> 'JPT':
         """
         Fit the jpt to ``data``
         :param data:    The training examples (assumed in row-shape)
         :type data:     [[str or float or bool]]; (according to `self.variables`)
         :param rows:    The training examples (assumed in row-shape)
         :type rows:     [[str or float or bool]]; (according to `self.variables`)
-        :param columns: The training examples (assumed in row-shape)
+        :param columns: The training examples (assumed in column-shape)
         :type columns:  [[str or float or bool]]; (according to `self.variables`)
         :param keep_samples: If true, stores the indices of the original data samples in the leaf nodes. For debugging
                         purposes only. Default is false.
         :return: the fitted model
         """
         # --------------------------------------------------------------------------------------------------------------
         # Check and prepare the data
```

## jpt/variables.py

```diff
@@ -138,15 +138,15 @@
         return {
             'name': self.name,
             'domain': None if self.domain is None else self.domain.to_json(),
             'settings': self.settings
         }
 
     @staticmethod
-    def from_json(data: Dict[str, Any]) -> Union['NumericVariable', 'SymbolicVariable']:
+    def from_json(data: Dict[str, Any]) -> Union['NumericVariable', 'SymbolicVariable', 'IntegerVariable']:
         if data['type'] == 'numeric':
             return NumericVariable.from_json(data)
         elif data['type'] == 'symbolic':
             return SymbolicVariable.from_json(data)
         elif data['type'] == 'integer':
             return IntegerVariable.from_json(data)
         else:
@@ -230,21 +230,23 @@
     def to_json(self) -> Dict[str, Any]:
         return edict(super().to_json()) + {
             'type': 'numeric'
         }
 
     @staticmethod
     def from_json(data: Dict[str, Any]) -> 'NumericVariable':
-        domain = Distribution.type_from_json(data['domain'])
-        return NumericVariable(name=data['name'],
-                               domain=domain,
-                               min_impurity_improvement=data.get(Variable.MIN_IMPURITY_IMPROVEMENT),
-                               max_std=data.get(NumericVariable.MAX_STDEV),
-                               precision=data.get(NumericVariable.PRECISION),
-                               blur=data.get(NumericVariable.BLUR))
+        domain = Distribution.from_json(data['domain'])
+        return NumericVariable(
+            name=data['name'],
+            domain=domain,
+            min_impurity_improvement=data.get(Variable.MIN_IMPURITY_IMPROVEMENT),
+            max_std=data.get(NumericVariable.MAX_STDEV),
+            precision=data.get(NumericVariable.PRECISION),
+            blur=data.get(NumericVariable.BLUR)
+        )
 
     @property
     def _max_std(self):
         if issubclass(self.domain, ScaledNumeric):
             return self.max_std_lbl / math.sqrt(self.domain.values.datascaler.scale)
         else:
             return self.max_std_lbl
@@ -348,15 +350,15 @@
             IntegerVariable,
             hashlib.md5(self.name.encode()).hexdigest(),
             self.domain
         ))
 
     @staticmethod
     def from_json(data: Dict[str, Any]) -> 'IntegerVariable':
-        domain = Distribution.type_from_json(data['domain'])
+        domain = Distribution.from_json(data['domain'])
         return IntegerVariable(
             name=data['name'],
             domain=domain,
             min_impurity_improvement=data.get(Variable.MIN_IMPURITY_IMPROVEMENT)
         )
 
     def to_json(self) -> Dict[str, Any]:
@@ -381,23 +383,27 @@
     }
 
     def __init__(self,
                  name: str,
                  domain: type,
                  min_impurity_improvement: float = None,
                  invert_impurity: bool = None):
-        super().__init__(name,
-                         domain,
-                         min_impurity_improvement=min_impurity_improvement,
-                         invert_impurity=invert_impurity)
+        super().__init__(
+            name,
+            domain,
+            min_impurity_improvement=min_impurity_improvement,
+            invert_impurity=invert_impurity
+        )
 
     @staticmethod
-    def from_json(data) -> Dict[str, Any]:
-        domain = Distribution.type_from_json(data['domain'])
-        return SymbolicVariable(name=data['name'], domain=domain)
+    def from_json(data: Dict[str, Any]) -> 'SymbolicVariable':
+        return SymbolicVariable(
+            name=data['name'],
+            domain=Distribution.from_json(data['domain'])
+        )
 
     def to_json(self) -> Dict[str, Any]:
         return edict(super().to_json()) + {
             'type': 'symbolic'
         }
 
     def str(self, assignment: Union[set, numbers.Number], **kwargs) -> str:
@@ -647,17 +653,19 @@
                   variables: Iterable[Variable],
                   d: Dict[str, Any],
                   typ=None,
                   args=()) -> 'VariableMap':
         vmap = cls()
         varbyname = {var.name: var for var in variables}
         for vname, value in d.items():
-            vmap[varbyname[vname]] = (typ.from_json(value, *args)
-                                      if typ is not None and hasattr(typ, 'from_json')
-                                      else value)
+            vmap[varbyname[vname]] = (
+                typ.from_json(value, *args)
+                if typ is not None and hasattr(typ, 'from_json')
+                else value
+            )
         return vmap
 
     def __repr__(self):
         return '<%s {%s}>' % (type(self).__name__,
                               ', '.join(['%s: %s' % (var.name, repr(val)) for var, val in self.items()]))
 
 
@@ -726,14 +734,15 @@
                 if isinstance(value, collections.abc.Iterable):
                     value = list(value)
 
             result[variable.name] = to_json(value)
 
         return result
 
+
 # ----------------------------------------------------------------------------------------------------------------------
 
 # noinspection DuplicatedCode
 class ValueAssignment(VariableAssignment):
     '''
     Maps a set of variables to values represented by their interior representation, i.e.
     the internal value representation used by JPTs.
```

## jpt/distributions/univariate.py

```diff
@@ -1,10 +1,10 @@
 '''© Copyright 2021, Mareike Picklum, Daniel Nyga.
 '''
-from collections import deque
+from collections import deque, Counter
 from itertools import tee
 from types import FunctionType
 from typing import Any, Iterable, List, Union, Set, Type, Tuple
 
 from jpt.base.utils import classproperty, save_plot, normalized, mapstr, setstr, none2nan
 from jpt.base.errors import Unsatisfiability
 
@@ -468,39 +468,28 @@
         :return:            None
         '''
         raise NotImplementedError()
 
     def to_json(self):
         raise NotImplementedError()
 
-    @staticmethod
-    def from_json(data):
-        clazz = DISTRIBUTIONS.get(data['class'])
-        if clazz is None:
-            raise TypeError('Unknown distribution class: %s' % data['class'])
-        return clazz.from_json(data)
-
     def __getstate__(self):
         return self.to_json()
 
     def __setstate__(self, state):
         self.__dict__ = Distribution.from_json(state).__dict__
 
     @staticmethod
-    def type_from_json(data):
-        typ = _DISTRIBUTION_TYPES.get(data['type'])
-        if typ is None:
+    def from_json(data) -> Type:
+        cls = _DISTRIBUTION_TYPES.get(data['type'])
+        if cls is None:
             raise TypeError('Unknown distribution type: %s' % data['type'])
-        clazz = typ.type_from_json(data)
-        if clazz.__name__ in DISTRIBUTIONS:
-            if not clazz.equiv(DISTRIBUTIONS[clazz.__name__]):
-                raise TypeError('Distribution class named "%s" is ambiguous.' % clazz.__name__)
-        else:
-            DISTRIBUTIONS[clazz.__name__] = clazz
-        return clazz
+        return cls.type_from_json(data)
+
+    type_from_json = from_json
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 
 class Numeric(Distribution):
     '''
     Wrapper class for numeric domains and distributions.
@@ -753,21 +742,25 @@
             return self.create_dirac_impulse(restriction)
 
         else:
             raise ValueError("Unknown Datatype for cropping a numeric distribution, type is %s" % type(restriction))
 
     @classmethod
     def type_to_json(cls):
-        return {'type': 'numeric',
-                'class': cls.__name__}
+        return {
+            'type': 'numeric',
+            'class': cls.__name__
+        }
 
     def inst_to_json(self):
-        return {'class': type(self).__name__,
-                'settings': self.settings,
-                'quantile': self._quantile.to_json() if self._quantile is not None else None}
+        return {
+            'class': type(self).__name__,
+            'settings': self.settings,
+            'quantile': self._quantile.to_json() if self._quantile is not None else None
+        }
 
     to_json = type_to_json
 
     @staticmethod
     def from_json(data):
         return Numeric(**data['settings']).set(QuantileDistribution.from_json(data['quantile']))
 
@@ -918,17 +911,19 @@
     scaler = None
 
     def __init__(self, **settings):
         super().__init__(**settings)
 
     @classmethod
     def type_to_json(cls):
-        return {'type': 'scaled-numeric',
-                'class': cls.__name__,
-                'scaler': cls.scaler.to_json()}
+        return {
+            'type': 'scaled-numeric',
+            'class': cls.__name__,
+            'scaler': cls.scaler.to_json()
+        }
 
     to_json = type_to_json
 
     @staticmethod
     def type_from_json(data):
         clazz = NumericType(data['class'], None)
         clazz.scaler = DataScaler.from_json(data['scaler'])
@@ -1172,22 +1167,26 @@
             params += d.probabilities * w
         if abs(sum(params)) < 1e-10:
             raise Unsatisfiability('Sum of weights must not be zero.')
         return type(distributions[0])().set(params)
 
     @classmethod
     def type_to_json(cls):
-        return {'type': 'symbolic',
-                'class': cls.__qualname__,
-                'labels': list(cls.labels.values())}
+        return {
+            'type': 'symbolic',
+            'class': cls.__qualname__,
+            'labels': list(cls.labels.values())
+        }
 
     def inst_to_json(self):
-        return {'class': type(self).__qualname__,
-                'params': list(self._params),
-                'settings': self.settings}
+        return {
+            'class': type(self).__qualname__,
+            'params': list(self._params),
+            'settings': self.settings
+        }
 
     to_json = type_to_json
 
     @staticmethod
     def type_from_json(data):
         return SymbolicType(data['class'], data['labels'])
 
@@ -1672,14 +1671,17 @@
 
 # ----------------------------------------------------------------------------------------------------------------------
 
 # noinspection PyPep8Naming
 def SymbolicType(name: str, labels: List[Any]) -> Type:
     if len(labels) < 1:
         raise ValueError('At least one value is needed for a symbolic type.')
+    if len(set(labels)) != len(labels):
+        duplicates = [item for item, count in Counter(labels).items() if count > 1]
+        raise ValueError('List of labels  contains duplicates: %s' % duplicates)
     t = type(name, (Multinomial,), {})
     t.values = OrderedDictProxy([(lbl, int(val)) for val, lbl in zip(range(len(labels)), labels)])
     t.labels = OrderedDictProxy([(int(val), lbl) for val, lbl in zip(range(len(labels)), labels)])
     return t
 
 
 # noinspection PyPep8Naming
@@ -1720,15 +1722,7 @@
 
 _DISTRIBUTIONS = {
     'Numeric': Numeric,
     'ScaledNumeric': ScaledNumeric,
     'Multinomial': Multinomial,
     'Integer': Integer
 }
-
-
-DISTRIBUTIONS = dict(_DISTRIBUTIONS)
-
-
-def reset():
-    global DISTRIBUTIONS
-    DISTRIBUTIONS = dict(_DISTRIBUTIONS)
```

## Comparing `pyjpt-0.1.7.dist-info/RECORD` & `pyjpt-0.1.8.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 jpt/sequential_trees.py,sha256=C8tYr60yVCuIhrgT4fBaaG3wo8Jdjqzo53yH9vB-7Ns,12754
 jpt/__init__.py,sha256=W0d32TFKPu7qhXvQynvvoBDY1Idc5dGyO2TppkDz9EQ,351
-jpt/version.py,sha256=lb7pBYtYpCFeHZYuh8V-y35XZ0VYb4oOj4UrlkQDsf0,535
-jpt/trees.py,sha256=JzLKk9hzBgbIerE8Ex65oyTszPmhsp8VgUUO7CrGrsQ,88037
-jpt/variables.py,sha256=FHffJnvC10qf7C2CtOJGzGz8aW50mNXoHZSFY8cDaEs,28520
+jpt/version.py,sha256=hjs22fEtVzChPO4p523l3fuim8YdSmiptpGX7EKmuNw,535
+jpt/trees.py,sha256=qmktWrqtijRYSm6fvy8dHPuanfp2ULUofyd5b87Ycps,88164
+jpt/variables.py,sha256=O2j1rBUqxEXGzIUnUNHZneyqmnjJZVpcYlyCxirONWE,28451
 jpt/distributions/multivariate.py,sha256=TSydOQaBoxg1jPXYa5o7trlJI9gt5vBQQasymsWodf8,6213
-jpt/distributions/univariate.py,sha256=pgn88_2Q0n5UdTN8zUOhOWCuaWaPbSnJjtUMiTEvCXs,67148
+jpt/distributions/univariate.py,sha256=SJ6TNZVufjS_GjqNlqpX9O1JDJhDy-Su_v1a1wBadrg,66828
 jpt/distributions/utils.py,sha256=NfirBpZp0cGV-0uCmbohj9yUNFxESMG0kdm2zHx-WpE,5162
 jpt/distributions/__init__.py,sha256=Mu54eyCF1cgCvipHd2C3bA9I2z79eBplkaXNdUaS1d8,184
 jpt/distributions/quantile/quantiles.cpython-38-x86_64-linux-gnu.so,sha256=T7oWIfx244EGyvxlqYPCUFs0WUEsygcYuwyKdASZX0g,3703208
 jpt/distributions/quantile/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 jpt/distributions/quantile/cdfreg.cpython-38-x86_64-linux-gnu.so,sha256=VwF8bfImqYbTlXNrN-TNUYw2oDV3gBXVUh4St8FC1qU,1748672
 jpt/base/sampling.py,sha256=_nhKx7g3--lTqJrKnegEncq1A7o2wdD1s7o66TzBxZE,3003
 jpt/base/constants.py,sha256=Odh0hvrSivNXAtA5cAyGZbYBJaLZoJO8xeeguCZy9b0,2671
@@ -16,11 +16,11 @@
 jpt/base/utils.py,sha256=F1EvAh8mMdhxn5StTmcPEfQjCnfT2IURfm4fUW_H57Y,11258
 jpt/base/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 jpt/base/errors.py,sha256=5AcRU_6c7MZwTGpH6ASXDOJS4TPOnghcvHy6RCw6opQ,241
 jpt/base/cutils.cpython-38-x86_64-linux-gnu.so,sha256=AHI0f6r9s44IKwXV0CreciXSl2xLaFPnUrUiLJFYAgw,1538592
 jpt/base/intervals.cpython-38-x86_64-linux-gnu.so,sha256=ffTBtOVYWhowsNdCCRz4zFkB5pkS0p6PEZ1eNTTTPGQ,4272728
 jpt/learning/impurity.cpython-38-x86_64-linux-gnu.so,sha256=JN6Wst0smpn1QAcJAFzM0d20UEwVkntKSnXCPbhqIuo,2628400
 jpt/learning/__init__.py,sha256=TCzrRmbTxHgnoU1qeNH3bzto5WHZffx5E2YRftRia8U,96
-pyjpt-0.1.7.dist-info/WHEEL,sha256=5DQRW5VdkIxH8e7ylwa-YBCXLhSZeqHiz1ZmuOscrlo,148
-pyjpt-0.1.7.dist-info/top_level.txt,sha256=MF_1vUuqqq7SOTzpM0V35goyjAKbP-qs_5kTo31pe7E,4
-pyjpt-0.1.7.dist-info/RECORD,,
-pyjpt-0.1.7.dist-info/METADATA,sha256=xKv1fxmvIBLrgJaia2t87Fg_yowzEmkUR9pj2dMhGT8,1355
+pyjpt-0.1.8.dist-info/WHEEL,sha256=5DQRW5VdkIxH8e7ylwa-YBCXLhSZeqHiz1ZmuOscrlo,148
+pyjpt-0.1.8.dist-info/top_level.txt,sha256=MF_1vUuqqq7SOTzpM0V35goyjAKbP-qs_5kTo31pe7E,4
+pyjpt-0.1.8.dist-info/RECORD,,
+pyjpt-0.1.8.dist-info/METADATA,sha256=fGvvft4vyEd29yJiSgwa4NYUirdZWBSlLUYF4-dqhsI,1355
```

## Comparing `pyjpt-0.1.7.dist-info/METADATA` & `pyjpt-0.1.8.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyjpt
-Version: 0.1.7
+Version: 0.1.8
 Requires-Dist: dnutils
 Requires-Dist: graphviz
 Requires-Dist: scipy
 Requires-Dist: numpy
 Requires-Dist: matplotlib
 Requires-Dist: pandas
 Requires-Dist: dateparser
```

