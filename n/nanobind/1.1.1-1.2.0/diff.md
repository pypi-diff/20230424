# Comparing `tmp/nanobind-1.1.1-py3-none-any.whl.zip` & `tmp/nanobind-1.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,76 +1,74 @@
-Zip file size: 168470 bytes, number of entries: 74
--rw-r--r--  2.0 unx      536 b- defN 23-Apr-06 11:42 nanobind/__init__.py
--rw-r--r--  2.0 unx      839 b- defN 23-Apr-05 07:55 nanobind/__main__.py
--rw-r--r--  2.0 unx    21432 b- defN 23-Mar-08 17:01 nanobind/cmake/darwin-ld-cpython.sym
--rw-r--r--  2.0 unx    24563 b- defN 23-Mar-08 17:01 nanobind/cmake/darwin-ld-pypy.sym
--rw-r--r--  2.0 unx    10363 b- defN 23-Mar-08 17:02 nanobind/cmake/nanobind-config.cmake
--rw-r--r--  2.0 unx    11776 b- defN 23-Feb-20 15:57 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
--rw-r--r--  2.0 unx    54550 b- defN 23-Feb-20 15:57 nanobind/ext/robin_map/include/tsl/robin_hash.h
--rw-r--r--  2.0 unx    28414 b- defN 23-Feb-20 15:57 nanobind/ext/robin_map/include/tsl/robin_map.h
--rw-r--r--  2.0 unx    23593 b- defN 22-Oct-19 09:26 nanobind/ext/robin_map/include/tsl/robin_set.h
--rw-r--r--  2.0 unx     5601 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/make_iterator.h
--rw-r--r--  2.0 unx     1628 b- defN 23-Apr-06 11:41 nanobind/include/nanobind/nanobind.h
--rw-r--r--  2.0 unx     5626 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/nb_accessor.h
--rw-r--r--  2.0 unx     7173 b- defN 23-Apr-05 07:55 nanobind/include/nanobind/nb_attr.h
--rw-r--r--  2.0 unx     5325 b- defN 22-Nov-11 13:15 nanobind/include/nanobind/nb_call.h
--rw-r--r--  2.0 unx    14184 b- defN 23-Apr-05 20:48 nanobind/include/nanobind/nb_cast.h
--rw-r--r--  2.0 unx    19171 b- defN 23-Apr-05 07:55 nanobind/include/nanobind/nb_class.h
--rw-r--r--  2.0 unx     5507 b- defN 23-Apr-05 07:55 nanobind/include/nanobind/nb_defs.h
--rw-r--r--  2.0 unx     4129 b- defN 22-Oct-21 08:25 nanobind/include/nanobind/nb_descr.h
--rw-r--r--  2.0 unx      666 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/nb_enums.h
--rw-r--r--  2.0 unx     3526 b- defN 23-Mar-07 23:06 nanobind/include/nanobind/nb_error.h
--rw-r--r--  2.0 unx     9751 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/nb_func.h
--rw-r--r--  2.0 unx    18304 b- defN 23-Mar-07 23:06 nanobind/include/nanobind/nb_lib.h
--rw-r--r--  2.0 unx     1167 b- defN 23-Mar-27 14:22 nanobind/include/nanobind/nb_misc.h
--rw-r--r--  2.0 unx     1377 b- defN 22-Oct-21 08:25 nanobind/include/nanobind/nb_python.h
--rw-r--r--  2.0 unx     6280 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/nb_traits.h
--rw-r--r--  2.0 unx     2468 b- defN 22-Nov-06 21:45 nanobind/include/nanobind/nb_tuple.h
--rw-r--r--  2.0 unx    25089 b- defN 23-Apr-06 11:26 nanobind/include/nanobind/nb_types.h
--rw-r--r--  2.0 unx    12285 b- defN 23-Apr-05 07:55 nanobind/include/nanobind/ndarray.h
--rw-r--r--  2.0 unx     7449 b- defN 23-Mar-07 23:06 nanobind/include/nanobind/operators.h
--rw-r--r--  2.0 unx      276 b- defN 23-Mar-07 23:06 nanobind/include/nanobind/tensor.h
--rw-r--r--  2.0 unx     3010 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/trampoline.h
--rw-r--r--  2.0 unx     8411 b- defN 23-Apr-05 07:55 nanobind/include/nanobind/eigen/dense.h
--rw-r--r--  2.0 unx     6486 b- defN 23-Mar-07 23:06 nanobind/include/nanobind/eigen/sparse.h
--rw-r--r--  2.0 unx      535 b- defN 22-Oct-21 08:25 nanobind/include/nanobind/stl/array.h
--rw-r--r--  2.0 unx     5775 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/bind_map.h
--rw-r--r--  2.0 unx     7250 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/bind_vector.h
--rw-r--r--  2.0 unx     2720 b- defN 23-Mar-16 11:05 nanobind/include/nanobind/stl/filesystem.h
--rw-r--r--  2.0 unx     2478 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/function.h
--rw-r--r--  2.0 unx      527 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/stl/list.h
--rw-r--r--  2.0 unx      596 b- defN 22-Oct-21 08:28 nanobind/include/nanobind/stl/map.h
--rw-r--r--  2.0 unx     2281 b- defN 23-Mar-30 15:19 nanobind/include/nanobind/stl/optional.h
--rw-r--r--  2.0 unx     3403 b- defN 23-Mar-30 15:19 nanobind/include/nanobind/stl/pair.h
--rw-r--r--  2.0 unx      575 b- defN 22-Oct-21 08:25 nanobind/include/nanobind/stl/set.h
--rw-r--r--  2.0 unx     4573 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/shared_ptr.h
--rw-r--r--  2.0 unx     1019 b- defN 22-Nov-04 19:27 nanobind/include/nanobind/stl/string.h
--rw-r--r--  2.0 unx     1063 b- defN 22-Nov-04 19:27 nanobind/include/nanobind/stl/string_view.h
--rw-r--r--  2.0 unx     3463 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/tuple.h
--rw-r--r--  2.0 unx     4310 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/unique_ptr.h
--rw-r--r--  2.0 unx      646 b- defN 22-Oct-21 08:28 nanobind/include/nanobind/stl/unordered_map.h
--rw-r--r--  2.0 unx      652 b- defN 22-Oct-21 08:29 nanobind/include/nanobind/stl/unordered_set.h
--rw-r--r--  2.0 unx     3386 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/variant.h
--rw-r--r--  2.0 unx      537 b- defN 22-Oct-21 08:29 nanobind/include/nanobind/stl/vector.h
--rw-r--r--  2.0 unx     1680 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/detail/nb_array.h
--rw-r--r--  2.0 unx     2655 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/detail/nb_dict.h
--rw-r--r--  2.0 unx     2132 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/detail/nb_list.h
--rw-r--r--  2.0 unx     1942 b- defN 23-Feb-27 12:44 nanobind/include/nanobind/stl/detail/nb_set.h
--rw-r--r--  2.0 unx     3218 b- defN 23-Feb-20 15:29 nanobind/include/nanobind/stl/detail/traits.h
--rw-r--r--  2.0 unx     4165 b- defN 22-Oct-19 09:26 nanobind/src/buffer.h
--rw-r--r--  2.0 unx    27942 b- defN 23-Mar-07 23:06 nanobind/src/common.cpp
--rw-r--r--  2.0 unx     6327 b- defN 23-Feb-20 15:29 nanobind/src/error.cpp
--rw-r--r--  2.0 unx     2548 b- defN 22-Oct-21 08:25 nanobind/src/implicit.cpp
--rw-r--r--  2.0 unx    11560 b- defN 23-Feb-20 15:29 nanobind/src/nb_enum.cpp
--rw-r--r--  2.0 unx    39298 b- defN 23-Apr-05 07:55 nanobind/src/nb_func.cpp
--rw-r--r--  2.0 unx    19095 b- defN 23-Mar-28 11:28 nanobind/src/nb_internals.cpp
--rw-r--r--  2.0 unx     8552 b- defN 23-Mar-07 23:06 nanobind/src/nb_internals.h
--rw-r--r--  2.0 unx    19495 b- defN 23-Apr-05 08:25 nanobind/src/nb_ndarray.cpp
--rw-r--r--  2.0 unx    45214 b- defN 23-Mar-28 11:28 nanobind/src/nb_type.cpp
--rw-r--r--  2.0 unx    18990 b- defN 23-Feb-27 08:33 nanobind/src/ndarray.cpp
--rw-r--r--  2.0 unx     3701 b- defN 22-Nov-03 20:52 nanobind/src/trampoline.cpp
--rw-r--r--  2.0 unx     1521 b- defN 23-Apr-06 11:44 nanobind-1.1.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     1248 b- defN 23-Apr-06 11:44 nanobind-1.1.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-06 11:44 nanobind-1.1.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 23-Apr-06 11:44 nanobind-1.1.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6823 b- defN 23-Apr-06 11:44 nanobind-1.1.1.dist-info/RECORD
-74 files, 624951 bytes uncompressed, 157512 bytes compressed:  74.8%
+Zip file size: 163947 bytes, number of entries: 72
+-rw-rw-r--  2.0 unx      536 b- defN 23-Apr-24 15:36 nanobind/__init__.py
+-rw-rw-r--  2.0 unx      839 b- defN 23-Apr-24 15:36 nanobind/__main__.py
+-rw-rw-r--  2.0 unx    21432 b- defN 23-Apr-24 15:36 nanobind/cmake/darwin-ld-cpython.sym
+-rw-rw-r--  2.0 unx    24563 b- defN 23-Apr-24 15:36 nanobind/cmake/darwin-ld-pypy.sym
+-rw-rw-r--  2.0 unx    10363 b- defN 23-Apr-24 15:36 nanobind/cmake/nanobind-config.cmake
+-rw-rw-r--  2.0 unx    11776 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
+-rw-rw-r--  2.0 unx    54550 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_hash.h
+-rw-rw-r--  2.0 unx    28414 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_map.h
+-rw-rw-r--  2.0 unx    23593 b- defN 23-Apr-24 15:36 nanobind/ext/robin_map/include/tsl/robin_set.h
+-rw-rw-r--  2.0 unx     5601 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/make_iterator.h
+-rw-rw-r--  2.0 unx     1628 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nanobind.h
+-rw-rw-r--  2.0 unx     5626 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_accessor.h
+-rw-rw-r--  2.0 unx     7173 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_attr.h
+-rw-rw-r--  2.0 unx     5325 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_call.h
+-rw-rw-r--  2.0 unx    13975 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_cast.h
+-rw-rw-r--  2.0 unx    19205 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_class.h
+-rw-rw-r--  2.0 unx     5507 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_defs.h
+-rw-rw-r--  2.0 unx     4129 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_descr.h
+-rw-rw-r--  2.0 unx      666 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_enums.h
+-rw-rw-r--  2.0 unx     3526 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_error.h
+-rw-rw-r--  2.0 unx     9751 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_func.h
+-rw-rw-r--  2.0 unx    18304 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_lib.h
+-rw-rw-r--  2.0 unx     1167 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_misc.h
+-rw-rw-r--  2.0 unx     1377 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_python.h
+-rw-rw-r--  2.0 unx     6280 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_traits.h
+-rw-rw-r--  2.0 unx     2468 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_tuple.h
+-rw-rw-r--  2.0 unx    25089 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/nb_types.h
+-rw-rw-r--  2.0 unx    12285 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/ndarray.h
+-rw-rw-r--  2.0 unx     7449 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/operators.h
+-rw-rw-r--  2.0 unx     3013 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/trampoline.h
+-rw-rw-r--  2.0 unx     8411 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/eigen/dense.h
+-rw-rw-r--  2.0 unx     6486 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/eigen/sparse.h
+-rw-rw-r--  2.0 unx      535 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/array.h
+-rw-rw-r--  2.0 unx     5775 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/bind_map.h
+-rw-rw-r--  2.0 unx     7250 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/bind_vector.h
+-rw-rw-r--  2.0 unx     2720 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/filesystem.h
+-rw-rw-r--  2.0 unx     2478 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/function.h
+-rw-rw-r--  2.0 unx      527 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/list.h
+-rw-rw-r--  2.0 unx      596 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/map.h
+-rw-rw-r--  2.0 unx     2281 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/optional.h
+-rw-rw-r--  2.0 unx     3403 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/pair.h
+-rw-rw-r--  2.0 unx      575 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/set.h
+-rw-rw-r--  2.0 unx     4573 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/shared_ptr.h
+-rw-rw-r--  2.0 unx     1019 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/string.h
+-rw-rw-r--  2.0 unx     1063 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/string_view.h
+-rw-rw-r--  2.0 unx     3463 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/tuple.h
+-rw-rw-r--  2.0 unx     4310 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/unique_ptr.h
+-rw-rw-r--  2.0 unx      646 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/unordered_map.h
+-rw-rw-r--  2.0 unx      652 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/unordered_set.h
+-rw-rw-r--  2.0 unx     3386 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/variant.h
+-rw-rw-r--  2.0 unx      537 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/vector.h
+-rw-rw-r--  2.0 unx     1680 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_array.h
+-rw-rw-r--  2.0 unx     2655 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_dict.h
+-rw-rw-r--  2.0 unx     2132 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_list.h
+-rw-rw-r--  2.0 unx     1942 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/nb_set.h
+-rw-rw-r--  2.0 unx     3218 b- defN 23-Apr-24 15:36 nanobind/include/nanobind/stl/detail/traits.h
+-rw-rw-r--  2.0 unx     4165 b- defN 23-Apr-24 15:36 nanobind/src/buffer.h
+-rw-rw-r--  2.0 unx    27942 b- defN 23-Apr-24 15:36 nanobind/src/common.cpp
+-rw-rw-r--  2.0 unx     6327 b- defN 23-Apr-24 15:36 nanobind/src/error.cpp
+-rw-rw-r--  2.0 unx     2548 b- defN 23-Apr-24 15:36 nanobind/src/implicit.cpp
+-rw-rw-r--  2.0 unx    11560 b- defN 23-Apr-24 15:36 nanobind/src/nb_enum.cpp
+-rw-rw-r--  2.0 unx    39337 b- defN 23-Apr-24 15:36 nanobind/src/nb_func.cpp
+-rw-rw-r--  2.0 unx    18420 b- defN 23-Apr-24 15:36 nanobind/src/nb_internals.cpp
+-rw-rw-r--  2.0 unx     8457 b- defN 23-Apr-24 15:36 nanobind/src/nb_internals.h
+-rw-rw-r--  2.0 unx    19495 b- defN 23-Apr-24 15:36 nanobind/src/nb_ndarray.cpp
+-rw-rw-r--  2.0 unx    47554 b- defN 23-Apr-24 15:36 nanobind/src/nb_type.cpp
+-rw-rw-r--  2.0 unx     3628 b- defN 23-Apr-24 15:36 nanobind/src/trampoline.cpp
+-rw-rw-r--  2.0 unx     1521 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     1426 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        9 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     6651 b- defN 23-Apr-24 15:36 nanobind-1.2.0.dist-info/RECORD
+72 files, 607055 bytes uncompressed, 153257 bytes compressed:  74.8%
```

## zipnote {}

```diff
@@ -81,17 +81,14 @@
 
 Filename: nanobind/include/nanobind/ndarray.h
 Comment: 
 
 Filename: nanobind/include/nanobind/operators.h
 Comment: 
 
-Filename: nanobind/include/nanobind/tensor.h
-Comment: 
-
 Filename: nanobind/include/nanobind/trampoline.h
 Comment: 
 
 Filename: nanobind/include/nanobind/eigen/dense.h
 Comment: 
 
 Filename: nanobind/include/nanobind/eigen/sparse.h
@@ -195,29 +192,26 @@
 
 Filename: nanobind/src/nb_ndarray.cpp
 Comment: 
 
 Filename: nanobind/src/nb_type.cpp
 Comment: 
 
-Filename: nanobind/src/ndarray.cpp
-Comment: 
-
 Filename: nanobind/src/trampoline.cpp
 Comment: 
 
-Filename: nanobind-1.1.1.dist-info/LICENSE
+Filename: nanobind-1.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: nanobind-1.1.1.dist-info/METADATA
+Filename: nanobind-1.2.0.dist-info/METADATA
 Comment: 
 
-Filename: nanobind-1.1.1.dist-info/WHEEL
+Filename: nanobind-1.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: nanobind-1.1.1.dist-info/top_level.txt
+Filename: nanobind-1.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: nanobind-1.1.1.dist-info/RECORD
+Filename: nanobind-1.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nanobind/__init__.py

```diff
@@ -8,14 +8,14 @@
     "Return the path to the nanobind include directory"
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "include")
 
 def cmake_dir() -> str:
     "Return the path to the nanobind CMake module directory."
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "cmake")
 
-__version__ = "1.1.1"
+__version__ = "1.2.0"
 
 __all__ = (
     "__version__",
     "include_dir",
     "cmake_dir",
 )
```

## nanobind/include/nanobind/nanobind.h

```diff
@@ -18,16 +18,16 @@
 #  pragma warning(disable: 4702) // unreachable code (e.g. when binding a noreturn function)
    // The next two lines disable warnings that are "just noise" according to Stephan T. Lavavej (a MSFT STL maintainer)
 #  pragma warning(disable: 4275) // non dll-interface class 'std::exception' used as base for dll-interface class [..]
 #  pragma warning(disable: 4251) // [..] needs to have a dll-interface to be used by clients of class [..]
 #endif
 
 #define NB_VERSION_MAJOR 1
-#define NB_VERSION_MINOR 1
-#define NB_VERSION_PATCH 1
+#define NB_VERSION_MINOR 2
+#define NB_VERSION_PATCH 0
 
 // Core C++ headers that nanobind depends on
 #include <cstdint>
 #include <exception>
 #include <stdexcept>
 #include <type_traits>
 #include <typeinfo>
```

## nanobind/include/nanobind/nb_cast.h

```diff
@@ -334,35 +334,29 @@
 NAMESPACE_END(detail)
 
 template <typename T, typename Derived>
 T cast(const detail::api<Derived> &value, bool convert = true) {
     if constexpr (std::is_same_v<T, void>) {
         return;
     } else {
-        using Ti     = detail::intrinsic_t<T>;
-        using Caster = detail::make_caster<Ti>;
+        using Caster = detail::make_caster<T>;
+        using Output = typename Caster::template Cast<T>;
+
+        static_assert(
+            !(std::is_reference_v<T> || std::is_pointer_v<T>) || Caster::IsClass ||
+            std::is_same_v<const char *, T>,
+            "nanobind::cast(): cannot return a reference to a temporary.");
 
         Caster caster;
         if (!caster.from_python(value.derived().ptr(),
                                 convert ? (uint8_t) detail::cast_flags::convert
                                         : (uint8_t) 0, nullptr))
             detail::raise_cast_error();
 
-        if constexpr (std::is_same_v<T, const char *>) {
-            return caster.operator const char *();
-        } else {
-            static_assert(
-                !(std::is_reference_v<T> || std::is_pointer_v<T>) || Caster::IsClass,
-                "nanobind::cast(): cannot return a reference to a temporary.");
-
-            if constexpr (detail::is_pointer_v<T>)
-                return caster.operator Ti*();
-            else
-                return caster.operator Ti&();
-        }
+        return caster.operator Output();
     }
 }
 
 template <typename T>
 object cast(T &&value, rv_policy policy = rv_policy::automatic_reference) {
     handle h = detail::make_caster<T>::from_cpp(
         (detail::forward_t<T>) value, detail::infer_policy<T>(policy), nullptr);
```

## nanobind/include/nanobind/nb_class.h

```diff
@@ -139,15 +139,15 @@
     t.flags |= (uint32_t) type_flags::has_dynamic_attr;
 }
 
 template <typename T>
 NB_INLINE void type_extra_apply(type_data &t, supplement<T>) {
     static_assert(std::is_trivially_default_constructible_v<T>,
                   "The supplement type must be a POD (plain old data) type");
-    t.flags |= (uint32_t) type_flags::has_supplement;
+    t.flags |= (uint32_t) type_flags::has_supplement | (uint32_t) type_flags::is_final;
     t.supplement = (void *) malloc(sizeof(T));
 }
 
 template <typename T> void wrap_copy(void *dst, const void *src) {
     new ((T *) dst) T(*(const T *) src);
 }
```

## nanobind/include/nanobind/trampoline.h

```diff
@@ -11,56 +11,57 @@
 #pragma once
 
 #include <nanobind/nanobind.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
-NB_CORE void trampoline_new(void **data, size_t size, void *ptr,
-                            const std::type_info *cpp_type) noexcept;
+NB_CORE void trampoline_new(void **data, size_t size, void *ptr) noexcept;
 NB_CORE void trampoline_release(void **data, size_t size) noexcept;
 
 NB_CORE PyObject *trampoline_lookup(void **data, size_t size, const char *name,
                                     bool pure);
 
 template <size_t Size> struct trampoline {
     mutable void *data[2 * Size + 1];
 
-    NB_INLINE trampoline(void *ptr, const std::type_info *cpp_type) {
-        trampoline_new(data, Size, ptr, cpp_type);
+    NB_INLINE trampoline(void *ptr) {
+        trampoline_new(data, Size, ptr);
     }
 
     NB_INLINE ~trampoline() { trampoline_release(data, Size); }
 
     NB_INLINE handle lookup(const char *name, bool pure) const {
         return trampoline_lookup(data, Size, name, pure);
     }
 
     NB_INLINE handle base() const { return (PyObject *) data[0]; }
 };
 
 #define NB_TRAMPOLINE(base, size)                                              \
     using NBBase = base;                                                       \
     using NBBase::NBBase;                                                      \
-    nanobind::detail::trampoline<size> nb_trampoline{ this, &typeid(NBBase) }
+    nanobind::detail::trampoline<size> nb_trampoline{ this }
 
 #define NB_OVERRIDE_NAME(name, func, ...)                                      \
     nanobind::handle nb_key = nb_trampoline.lookup(name, false);               \
     using nb_ret_type = decltype(NBBase::func(__VA_ARGS__));                   \
     if (nb_key.is_valid()) {                                                   \
         nanobind::gil_scoped_acquire nb_guard;                                 \
         return nanobind::cast<nb_ret_type>(                                    \
             nb_trampoline.base().attr(nb_key)(__VA_ARGS__));                   \
     } else                                                                     \
-        return NBBase::func(__VA_ARGS__)                                       \
+        return NBBase::func(__VA_ARGS__)
 
 #define NB_OVERRIDE_PURE_NAME(name, func, ...)                                 \
     nanobind::handle nb_key = nb_trampoline.lookup(name, true);                \
-    nanobind::gil_scoped_acquire nb_guard;                                     \
     using nb_ret_type = decltype(NBBase::func(__VA_ARGS__));                   \
+    if (!nb_key.is_valid())                                                    \
+        throw std::runtime_error("Method " name " not implemented!");          \
+    nanobind::gil_scoped_acquire nb_guard;                                     \
     return nanobind::cast<nb_ret_type>(                                        \
         nb_trampoline.base().attr(nb_key)(__VA_ARGS__))
 
 #define NB_OVERRIDE(func, ...)                                                 \
     NB_OVERRIDE_NAME(#func, func, __VA_ARGS__)
 
 #define NB_OVERRIDE_PURE(func, ...)                                            \
```

## nanobind/src/nb_func.cpp

```diff
@@ -625,15 +625,15 @@
                 args_flags[0] = (uint8_t) cast_flags::construct;
 
             try {
                 // Found a suitable overload, let's try calling it
                 result = f->impl((void *) f->capture, args, args_flags,
                                  (rv_policy) (f->flags & 0b111), &cleanup);
 
-                if (!result) {
+                if (NB_UNLIKELY(!result)) {
                     error_handler = nb_func_error_noconvert;
                     goto done;
                 }
             } catch (next_overload &) {
                 result = NB_NEXT_OVERLOAD;
             } catch (python_error &e) {
                 e.restore();
@@ -647,15 +647,15 @@
 
             if (result != NB_NEXT_OVERLOAD) {
                 if (is_constructor) {
                     nb_inst *self_arg_nb = (nb_inst *) self_arg;
                     self_arg_nb->destruct = true;
                     self_arg_nb->ready = true;
 
-                    if (self_flags & (uint32_t) type_flags::intrusive_ptr)
+                    if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::intrusive_ptr))
                         nb_type_data(Py_TYPE(self_arg))
                             ->set_self_py(inst_ptr(self_arg_nb), self_arg);
                 }
 
                 goto done;
             }
         }
@@ -771,15 +771,15 @@
 
             if (result != NB_NEXT_OVERLOAD) {
                 if (is_constructor) {
                     nb_inst *self_arg_nb = (nb_inst *) self_arg;
                     self_arg_nb->destruct = true;
                     self_arg_nb->ready = true;
 
-                    if (self_flags & (uint32_t) type_flags::intrusive_ptr)
+                    if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::intrusive_ptr))
                         nb_type_data(Py_TYPE(self_arg))
                             ->set_self_py(inst_ptr(self_arg_nb), self_arg);
                 }
 
                 goto done;
             }
         }
```

## nanobind/src/nb_internals.cpp

```diff
@@ -73,15 +73,14 @@
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 extern PyObject *nb_func_getattro(PyObject *, PyObject *);
 extern PyObject *nb_func_get_doc(PyObject *, void *);
 extern PyObject *nb_bound_method_getattro(PyObject *, PyObject *);
-extern PyObject *nb_func_get_getset(PyObject *, PyObject *);
 extern int nb_func_traverse(PyObject *, visitproc, void *);
 extern int nb_func_clear(PyObject *);
 extern void nb_func_dealloc(PyObject *);
 extern int nb_bound_method_traverse(PyObject *, visitproc, void *);
 extern int nb_bound_method_clear(PyObject *);
 extern void nb_bound_method_dealloc(PyObject *);
 extern PyObject *nb_method_descr_get(PyObject *, PyObject *, PyObject *);
@@ -192,28 +191,14 @@
     /* .name = */ "nanobind.nb_type",
     /* .basicsize = */ 0,
     /* .itemsize = */ 0,
     /* .flags = */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
     /* .slots = */ nb_type_slots
 };
 
-static PyType_Slot nb_enum_slots[] = {
-    { Py_tp_base, nullptr },
-    { 0, nullptr }
-};
-
-static PyType_Spec nb_enum_spec = {
-    /*.name = */"nanobind.nb_enum",
-    /*.basicsize = */0,
-    /*.itemsize = */0,
-    /*.flags = */Py_TPFLAGS_DEFAULT,
-    /*.slots = */nb_enum_slots
-};
-
-
 #if PY_VERSION_HEX >= 0x030C0000
 static PyMemberDef nb_static_property_members[] = {
     { "__doc__", T_OBJECT, 0, 0, nullptr },
     { nullptr, 0, 0, 0, nullptr }
 };
 #endif
 
@@ -390,54 +375,50 @@
 #endif
     if (!dict)
         fail("nanobind::detail::internals_dict(): failed!");
 
     return dict;
 }
 
-static void internals_make() {
+static NB_NOINLINE nb_internals *internals_make() {
     str nb_name("nanobind");
 
-    internals_p = new nb_internals();
+    nb_internals *p = new nb_internals();
 
     PyObject *dict = internals_dict();
 
     const char *internals_id = NB_INTERNALS_ID;
-    PyObject *capsule = PyCapsule_New(internals_p, internals_id, nullptr);
+    PyObject *capsule = PyCapsule_New(p, internals_id, nullptr);
     PyObject *nb_module = PyModule_NewObject(nb_name.ptr());
     int rv = PyDict_SetItemString(dict, internals_id, capsule);
     if (rv || !capsule || !nb_module)
         fail("nanobind::detail::internals_make(): allocation failed!");
     Py_DECREF(capsule);
 
-    internals_p->nb_module = nb_module;
+    p->nb_module = nb_module;
 
     // Function objects
-    internals_p->nb_func = (PyTypeObject *) PyType_FromSpec(&nb_func_spec);
-    internals_p->nb_method = (PyTypeObject *) PyType_FromSpec(&nb_method_spec);
-    internals_p->nb_bound_method =
+    p->nb_func = (PyTypeObject *) PyType_FromSpec(&nb_func_spec);
+    p->nb_method = (PyTypeObject *) PyType_FromSpec(&nb_method_spec);
+    p->nb_bound_method =
         (PyTypeObject *) PyType_FromSpec(&nb_bound_method_spec);
 
-    // Metaclass #1 (nb_type)
+    // Metaclass (nb_type)
 #if defined(Py_LIMITED_API)
     int tp_itemsize = cast<int>(handle(&PyType_Type).attr("__itemsize__"));
     int tp_basicsize = cast<int>(handle(&PyType_Type).attr("__basicsize__"));
 #else
     int tp_itemsize = (int) PyType_Type.tp_itemsize;
     int tp_basicsize = (int) PyType_Type.tp_basicsize;
 #endif
-    nb_type_spec.basicsize = nb_enum_spec.basicsize = tp_basicsize
+    nb_type_spec.basicsize = tp_basicsize
         + (int) sizeof(type_data);
-    nb_type_spec.itemsize = nb_enum_spec.itemsize = tp_itemsize;
+    nb_type_spec.itemsize = tp_itemsize;
     nb_type_slots[0].pfunc = &PyType_Type;
-    internals_p->nb_type = (PyTypeObject *) PyType_FromSpec(&nb_type_spec);
-
-    // Metaclass #2 (nb_enum)
-    nb_enum_slots[0].pfunc = internals_p->nb_type;
-    internals_p->nb_enum = (PyTypeObject *) PyType_FromSpec(&nb_enum_spec);
+    p->nb_type = (PyTypeObject *) PyType_FromSpec(&nb_type_spec);
 
     /// Static properties
  #if defined(Py_LIMITED_API)
     tp_basicsize = cast<int>(handle(&PyProperty_Type).attr("__basicsize__"));
     tp_itemsize = cast<int>(handle(&PyProperty_Type).attr("__itemsize__"));
  #else
     tp_basicsize = (int) PyProperty_Type.tp_basicsize;
@@ -452,36 +433,35 @@
 #else
     nb_static_property_slots[1].pfunc = PyProperty_Type.tp_members;
 #endif
     nb_static_property_slots[0].pfunc = &PyProperty_Type;
     nb_static_property_spec.basicsize = tp_basicsize;
     nb_static_property_spec.itemsize = tp_itemsize;
 
-    internals_p->nb_static_property =
+    p->nb_static_property =
         (PyTypeObject *) PyType_FromSpec(&nb_static_property_spec);
-    internals_p->nb_static_property_enabled = true;
+    p->nb_static_property_enabled = true;
 
     // Tensor type
-    internals_p->nb_ndarray = (PyTypeObject *) PyType_FromSpec(&nb_ndarray_spec);
+    p->nb_ndarray = (PyTypeObject *) PyType_FromSpec(&nb_ndarray_spec);
 
-    if (!internals_p->nb_func || !internals_p->nb_method ||
-        !internals_p->nb_bound_method || !internals_p->nb_type ||
-        !internals_p->nb_enum || !internals_p->nb_static_property ||
-        !internals_p->nb_ndarray)
+    if (!p->nb_func || !p->nb_method ||
+        !p->nb_bound_method || !p->nb_type ||
+        !p->nb_static_property || !p->nb_ndarray)
         fail("nanobind::detail::internals_make(): type initialization failed!");
 
 #if PY_VERSION_HEX < 0x03090000
-    internals_p->nb_ndarray->tp_as_buffer->bf_getbuffer = nb_ndarray_getbuffer;
-    internals_p->nb_ndarray->tp_as_buffer->bf_releasebuffer = nb_ndarray_releasebuffer;
-    internals_p->nb_func->tp_flags |= NB_HAVE_VECTORCALL;
-    internals_p->nb_func->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
-    internals_p->nb_method->tp_flags |= NB_HAVE_VECTORCALL;
-    internals_p->nb_method->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
-    internals_p->nb_bound_method->tp_flags |= NB_HAVE_VECTORCALL;
-    internals_p->nb_bound_method->tp_vectorcall_offset = offsetof(nb_bound_method, vectorcall);
+    p->nb_ndarray->tp_as_buffer->bf_getbuffer = nb_ndarray_getbuffer;
+    p->nb_ndarray->tp_as_buffer->bf_releasebuffer = nb_ndarray_releasebuffer;
+    p->nb_func->tp_flags |= NB_HAVE_VECTORCALL;
+    p->nb_func->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
+    p->nb_method->tp_flags |= NB_HAVE_VECTORCALL;
+    p->nb_method->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
+    p->nb_bound_method->tp_flags |= NB_HAVE_VECTORCALL;
+    p->nb_bound_method->tp_vectorcall_offset = offsetof(nb_bound_method, vectorcall);
 #endif
 
     register_exception_translator(default_exception_translator, nullptr);
 
 #if PY_VERSION_HEX < 0x030C0000 && !defined(PYPY_VERSION)
     /* The implementation of typing.py on CPython <3.12 tends to introduce
        spurious reference leaks that upset nanobind's leak checker. The
@@ -523,33 +503,39 @@
         fprintf(stderr,
                 "Warning: could not install the nanobind cleanup handler! This "
                 "is needed to check for reference leaks and release remaining "
                 "resources at interpreter shutdown (e.g., to avoid leaks being "
                 "reported by tools like 'valgrind'). If you are a user of a "
                 "python extension library, you can ignore this warning.");
 #endif
+    return p;
 }
 
-static void internals_fetch() {
+static nb_internals *internals_fetch() {
     PyObject *dict = internals_dict();
 
     const char *internals_id = NB_INTERNALS_ID;
     PyObject *capsule = PyDict_GetItemString(dict, internals_id);
 
+    nb_internals *ptr;
     if (capsule) {
-        internals_p = (nb_internals *) PyCapsule_GetPointer(capsule, internals_id);
-        if (!internals_p)
+        ptr = (nb_internals *) PyCapsule_GetPointer(capsule, internals_id);
+        if (!ptr)
             fail("nanobind::detail::internals_fetch(): capsule pointer is NULL!");
-        return;
+    } else {
+        ptr = internals_make();
     }
 
-    internals_make();
+    internals_p = ptr;
+
+    return ptr;
 }
 
 nb_internals &internals_get() noexcept {
-    if (!internals_p)
-        internals_fetch();
-    return *internals_p;
+    nb_internals *ptr = internals_p;
+    if (NB_UNLIKELY(!ptr))
+        ptr = internals_fetch();
+    return *ptr;
 }
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_internals.h

```diff
@@ -97,21 +97,14 @@
         v ^= v >> 33;
         v *= (uintptr_t) 0xc4ceb9fe1a85ec53ull;
         v ^= v >> 33;
         return (size_t) v;
     }
 };
 
-struct ptr_type_hash {
-    NB_INLINE size_t
-    operator()(const std::pair<const void *, std::type_index> &value) const {
-        return ptr_hash()(value.first) ^ value.second.hash_code();
-    }
-};
-
 struct keep_alive_entry {
     void *data; // unique data pointer
     void (*deleter)(void *) noexcept; // custom deleter, excluded from hashing/equality
 
     keep_alive_entry(void *data, void (*deleter)(void *) noexcept = nullptr)
         : data(data), deleter(deleter) { }
 };
@@ -166,36 +159,42 @@
           typename eq = std::equal_to<key>>
 using py_map =
     tsl::robin_map<key, value, hash, eq, py_allocator<std::pair<key, value>>>;
 
 using keep_alive_set =
     py_set<keep_alive_entry, keep_alive_hash, keep_alive_eq>;
 
-using nb_instance_map = py_map<std::pair<void *, std::type_index>, nb_inst *, ptr_type_hash>;
+// Linked list of instances with the same pointer address. Usually just 1..
+struct nb_inst_seq {
+    nb_inst *inst;
+    nb_inst_seq *next = nullptr;
+};
+
+using nb_inst_map = py_map<void *, nb_inst_seq, ptr_hash>;
 using nb_type_map = py_map<std::type_index, type_data *>;
 
 struct nb_internals {
     /// Internal nanobind module
     PyObject *nb_module;
 
     /// Registered metaclasses for nanobind classes and enumerations
-    PyTypeObject *nb_type, *nb_enum;
+    PyTypeObject *nb_type;
 
     /// Types of nanobind functions and methods
     PyTypeObject *nb_func, *nb_method, *nb_bound_method;
 
     /// Property variant for static attributes
     PyTypeObject *nb_static_property;
     bool nb_static_property_enabled;
 
     /// N-dimensional array wrapper
     PyTypeObject *nb_ndarray;
 
     /// Instance pointer -> Python object mapping
-    nb_instance_map inst_c2p;
+    nb_inst_map inst_c2p;
 
     /// C++ type -> Python type mapping
     nb_type_map type_c2p;
 
     /// Dictionary of sets storing keep_alive references
     py_map<void *, keep_alive_set, ptr_hash> keep_alive;
```

## nanobind/src/nb_type.cpp

```diff
@@ -111,20 +111,35 @@
             self->direct = false;
         }
 
         self->internal = false;
     }
 
     // Update hash table that maps from C++ to Python instance
-    auto [it, success] = internals_get().inst_c2p.try_emplace(
-        std::pair<void *, std::type_index>(value, *t->type),
-        self);
+    nb_inst_seq seq_v { self };
+    auto [it, success] =
+        internals_get().inst_c2p.try_emplace(value, seq_v);
 
-    if (!success)
-        fail("nanobind::detail::inst_new(): duplicate object!");
+    if (!success) {
+        nb_inst_seq *seq = &it.value();
+        while (true) {
+            if (NB_UNLIKELY(seq->inst == self))
+                fail("nanobind::detail::inst_new(): duplicate instance!");
+            if (!seq->next)
+                break;
+            seq = seq->next;
+        }
+
+        nb_inst_seq *next = (nb_inst_seq *) PyMem_Malloc(sizeof(nb_inst_seq));
+        if (NB_UNLIKELY(!next))
+            fail("nanobind::detail::inst_new(): list element allocation failed!");
+
+        *next = seq_v;
+        seq->next = next;
+    }
 
     return (PyObject *) self;
 }
 
 // Allocate a new instance with co-located storage
 PyObject *inst_new(PyTypeObject *type, PyObject *, PyObject *) {
     return inst_new_impl(type, nullptr);
@@ -178,20 +193,44 @@
                 Py_DECREF((PyObject *) e.data);
             else
                 e.deleter(e.data);
         }
     }
 
     // Update hash table that maps from C++ to Python instance
-    auto it = internals.inst_c2p.find(
-        std::pair<void *, std::type_index>(p, *t->type));
-    if (it == internals.inst_c2p.end())
+    nb_inst_seq *seq = nullptr, *pred = nullptr;
+    nb_inst_map &inst_c2p = internals.inst_c2p;
+    nb_inst_map::iterator it = inst_c2p.find(p);
+
+    if (it != inst_c2p.end()) {
+        seq = &it.value();
+
+        do {
+            if (seq->inst == inst)
+                break;
+            pred = seq;
+            seq = seq->next;
+        } while (seq);
+    }
+
+    if (!seq || seq->inst != inst)
         fail("nanobind::detail::inst_dealloc(\"%s\"): attempted to delete "
              "an unknown instance (%p)!", t->name, p);
-    internals.inst_c2p.erase(it);
+
+    if (pred) {
+        pred->next = seq->next;
+        PyMem_Free(seq);
+    } else {
+        if (seq->next) {
+            it.value() = *(seq->next);
+            PyMem_Free(seq->next);
+        } else {
+            inst_c2p.erase(it);
+        }
+    }
 
     if (gc) {
         #if defined(Py_LIMITED_API)
             static freefunc tp_free =
                 (freefunc) PyType_GetSlot(tp, Py_tp_free);
         #else
             freefunc tp_free = tp->tp_free;
@@ -441,16 +480,15 @@
 
     if (has_traverse && (!base || (PyType_GetFlags((PyTypeObject *) base) &
                                    Py_TPFLAGS_HAVE_GC) == 0))
         spec.flags |= Py_TPFLAGS_HAVE_GC;
 
     *s++ = { 0, nullptr };
 
-    PyTypeObject *metaclass = is_enum ? internals.nb_enum
-                                      : internals.nb_type;
+    PyTypeObject *metaclass =  internals.nb_type;
 
 #if PY_VERSION_HEX >= 0x030C0000
     // Life is good, PyType_FromMetaclass() is available
     PyObject *result = PyType_FromMetaclass(metaclass, mod, &spec, base);
     if (!result) {
         python_error err;
         fail("nanobind::detail::nb_type_new(\"%s\"): type construction failed: %s!", t->name, err.what());
@@ -659,15 +697,15 @@
     } else {
         to->supplement = nullptr;
     }
 
     if (has_dynamic_attr) {
         to->flags |= (uint32_t) type_flags::has_dynamic_attr;
         #if defined(Py_LIMITED_API)
-            to->dictoffset = (Py_ssize_t) (basicsize - ptr_size);
+            to->dictoffset = (size_t) (basicsize - ptr_size);
         #endif
     }
 
     if (has_scope)
         setattr(t->scope, t->name, result);
 
     setattr(result, "__qualname__", qualname.ptr());
@@ -781,16 +819,15 @@
         return true;
     }
 
     nb_internals &internals = internals_get();
     PyTypeObject *src_type = Py_TYPE(src);
     const std::type_info *cpp_type_src = nullptr;
     const PyTypeObject *metaclass = Py_TYPE((PyObject *) src_type);
-    const bool src_is_nb_type = metaclass == internals.nb_type ||
-                                metaclass == internals.nb_enum;
+    const bool src_is_nb_type = metaclass == internals.nb_type;
 
     type_data *dst_type = nullptr;
 
     // If 'src' is a nanobind-bound type
     if (src_is_nb_type) {
         type_data *t = nb_type_data(src_type);
         cpp_type_src = t->type;
@@ -863,15 +900,15 @@
 void keep_alive(PyObject *nurse, PyObject *patient) {
     if (!patient || !nurse || nurse == Py_None || patient == Py_None)
         return;
 
     nb_internals &internals = internals_get();
     PyTypeObject *metaclass = Py_TYPE((PyObject *) Py_TYPE(nurse));
 
-    if (metaclass == internals.nb_type || metaclass == internals.nb_enum) {
+    if (metaclass == internals.nb_type) {
         // Populate nanobind-internal data structures
         keep_alive_set &keep_alive = internals.keep_alive[nurse];
 
         auto [it, success] = keep_alive.emplace(patient);
         if (success) {
             Py_INCREF(patient);
             ((nb_inst *) nurse)->clear_keep_alive = true;
@@ -905,15 +942,15 @@
     if (!nurse)
         fail("nanobind::detail::keep_alive(): nurse==nullptr!");
 
     PyTypeObject *metaclass = Py_TYPE((PyObject *) Py_TYPE(nurse));
 
     nb_internals &internals = internals_get();
 
-    if (metaclass == internals.nb_type || metaclass == internals.nb_enum) {
+    if (metaclass == internals.nb_type) {
         keep_alive_set &keep_alive = internals.keep_alive[nurse];
         auto [it, success] = keep_alive.emplace(payload, callback);
         if (!success)
             raise("keep_alive(): the given 'payload' pointer was already registered!");
         ((nb_inst *) nurse)->clear_keep_alive = true;
     } else {
         PyObject *patient = capsule_new(payload, nullptr, callback);
@@ -999,90 +1036,157 @@
     return (PyObject *) inst;
 }
 
 PyObject *nb_type_put(const std::type_info *cpp_type,
                       void *value, rv_policy rvp,
                       cleanup_list *cleanup,
                       bool *is_new) noexcept {
-    using Key = std::pair<void *, std::type_index>;
-
     // Convert nullptr -> None
     if (!value) {
         Py_INCREF(Py_None);
         return Py_None;
     }
 
-    // Check if the instance is already registered with nanobind
     nb_internals &internals = internals_get();
-    nb_instance_map &map = internals.inst_c2p;
+    nb_inst_map &map = internals.inst_c2p;
     nb_type_map &type_map = internals.type_c2p;
-    nb_instance_map::iterator it = map.find(Key(value, *cpp_type));
+    type_data *td = nullptr;
 
-    if (it != map.end() && rvp != rv_policy::copy) {
-        PyObject *result = (PyObject *) it->second;
-        Py_INCREF(result);
-        return result;
-    } else if (rvp == rv_policy::none) {
-        return nullptr;
+    auto lookup_type = [cpp_type, &td, &type_map]() -> bool {
+        if (!td) {
+            nb_type_map::iterator it =
+                type_map.find(std::type_index(*cpp_type));
+
+            if (it == type_map.end())
+                return false;
+
+            td = it->second;
+        }
+
+        return true;
+    };
+
+    if (rvp != rv_policy::copy) {
+        // Check if the instance is already registered with nanobind
+        nb_inst_map::iterator it = map.find(value);
+
+        if (it != map.end()) {
+            const nb_inst_seq *seq = &it->second;
+
+            while (seq) {
+                PyObject *inst = (PyObject *) seq->inst;
+                PyTypeObject *tp = Py_TYPE(inst);
+
+                if (nb_type_data(tp)->type == cpp_type) {
+                    Py_INCREF(inst);
+                    return inst;
+                }
+
+                if (!lookup_type())
+                    return nullptr;
+
+                if (PyType_IsSubtype(tp, td->type_py)) {
+                    Py_INCREF(inst);
+                    return inst;
+                }
+
+                seq = seq->next;
+            }
+        } else if (rvp == rv_policy::none) {
+            return nullptr;
+        }
     }
 
-    // Look up the corresponding type
-    nb_type_map::iterator it2 = type_map.find(std::type_index(*cpp_type));
-    if (NB_UNLIKELY(it2 == type_map.end()))
+    // Look up the corresponding Python type if not already done
+    if (!lookup_type())
         return nullptr;
 
-    return nb_type_put_common(value, it2->second, rvp, cleanup, is_new);
+    return nb_type_put_common(value, td, rvp, cleanup, is_new);
 }
 
 PyObject *nb_type_put_p(const std::type_info *cpp_type,
                         const std::type_info *cpp_type_p,
                         void *value, rv_policy rvp,
                         cleanup_list *cleanup,
                         bool *is_new) noexcept {
-    using Key = std::pair<void *, std::type_index>;
+    using Key = std::pair<void *, PyTypeObject *>;
 
     // Convert nullptr -> None
     if (!value) {
         Py_INCREF(Py_None);
         return Py_None;
     }
 
     // Check if the instance is already registered with nanobind
     nb_internals &internals = internals_get();
-    nb_instance_map &map = internals.inst_c2p;
+    nb_inst_map &map = internals.inst_c2p;
     nb_type_map &type_map = internals.type_c2p;
-    nb_instance_map::iterator it = map.end();
 
-    if (NB_UNLIKELY(cpp_type_p && cpp_type_p != cpp_type))
-        it = map.find(Key(value, *cpp_type_p));
+    // Look up the corresponding Python type
+    type_data *td = nullptr,
+              *td_p = nullptr;
+
+    auto lookup_type = [cpp_type, cpp_type_p, &td, &td_p, &type_map]() -> bool {
+        if (!td) {
+            nb_type_map::iterator it =
+                type_map.find(std::type_index(*cpp_type));
 
-    if (NB_LIKELY(it == map.end()))
-        it = map.find(Key(value, *cpp_type));
+            if (it == type_map.end())
+                return false;
 
-    if (it != map.end() && rvp != rv_policy::copy) {
-        PyObject *result = (PyObject *) it->second;
-        Py_INCREF(result);
-        return result;
-    } else if (rvp == rv_policy::none) {
-        return nullptr;
-    }
+            td = it->second;
+
+            if (cpp_type_p && cpp_type_p != cpp_type) {
+                it = type_map.find(std::type_index(*cpp_type_p));
+
+                if (it != type_map.end())
+                    td_p = it->second;
+            }
+        }
+
+        return true;
+    };
+
+    if (rvp != rv_policy::copy) {
+        // Check if the instance is already registered with nanobind
+        nb_inst_map::iterator it = map.find(value);
+
+        if (it != map.end()) {
+            const nb_inst_seq *seq = &it->second;
+            while (seq) {
+                PyObject *inst = (PyObject *) seq->inst;
+                PyTypeObject *tp = Py_TYPE(inst);
+                const std::type_info *p = nb_type_data(tp)->type;
+
+                if (p == cpp_type || p == cpp_type_p) {
+                    Py_INCREF(inst);
+                    return inst;
+                }
 
-    // Look up the corresponding type
-    nb_type_map::iterator it2 = type_map.end();
+                if (!lookup_type())
+                    return nullptr;
 
-    if (NB_UNLIKELY(cpp_type_p && cpp_type_p != cpp_type))
-        it2 = type_map.find(std::type_index(*cpp_type_p));
+                if (PyType_IsSubtype(tp, td->type_py) ||
+                    (td_p && PyType_IsSubtype(tp, td_p->type_py))) {
+                    Py_INCREF(inst);
+                    return inst;
+                }
 
-    if (NB_LIKELY(it2 == type_map.end()))
-        it2 = type_map.find(std::type_index(*cpp_type));
+                seq = seq->next;
+            }
+        } else if (rvp == rv_policy::none) {
+            return nullptr;
+        }
+    }
 
-    if (NB_UNLIKELY(it2 == type_map.end()))
+    // Look up the corresponding Python type if not already done
+    if (!lookup_type())
         return nullptr;
 
-    return nb_type_put_common(value, it2->second, rvp, cleanup, is_new);
+    return nb_type_put_common(value, td_p ? td_p : td, rvp, cleanup, is_new);
 }
 
 static void nb_type_put_unique_finalize(PyObject *o,
                                         const std::type_info *cpp_type,
                                         bool cpp_delete, bool is_new) {
     if (!cpp_delete && is_new)
         fail("nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
@@ -1217,16 +1321,15 @@
     return nullptr;
 }
 
 bool nb_type_check(PyObject *t) noexcept {
     nb_internals &internals = internals_get();
     PyTypeObject *metaclass = Py_TYPE(t);
 
-    return metaclass == internals.nb_type ||
-           metaclass == internals.nb_enum;
+    return metaclass == internals.nb_type;
 }
 
 size_t nb_type_size(PyObject *t) noexcept {
     return nb_type_data((PyTypeObject *) t)->size;
 }
 
 size_t nb_type_align(PyObject *t) noexcept {
```

## nanobind/src/trampoline.cpp

```diff
@@ -9,24 +9,22 @@
 
 #include <nanobind/trampoline.h>
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
-void trampoline_new(void **data, size_t size, void *ptr,
-                    const std::type_info *cpp_type) noexcept {
+void trampoline_new(void **data, size_t size, void *ptr) noexcept {
     // GIL is held when the trampoline constructor runs
-    nb_internals &internals = internals_get();
-    auto it = internals.inst_c2p.find(
-        std::pair<void *, std::type_index>(ptr, *cpp_type));
-    if (it == internals.inst_c2p.end())
-        fail("nanobind::detail::trampoline_new(): instance not found!");
+    nb_inst_map &inst_c2p = internals_get().inst_c2p;
+    nb_inst_map::iterator it = inst_c2p.find(ptr);
+    if (it == inst_c2p.end() || it->second.next)
+        fail("nanobind::detail::trampoline_new(): unique instance not found!");
 
-    data[0] = it->second;
+    data[0] = it->second.inst;
     memset(data + 1, 0, sizeof(void *) * 2 * size);
 }
 
 void trampoline_release(void **data, size_t size) noexcept {
     // GIL is held when the trampoline destructor runs
     for (size_t i = 0; i < size; ++i)
         Py_XDECREF((PyObject *) data[i*2 + 2]);
```

## Comparing `nanobind-1.1.1.dist-info/LICENSE` & `nanobind-1.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `nanobind-1.1.1.dist-info/METADATA` & `nanobind-1.2.0.dist-info/METADATA`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 Metadata-Version: 2.1
 Name: nanobind
-Version: 1.1.1
+Version: 1.2.0
 Summary: nanobind: tiny and efficient C++/Python bindings
 Home-page: https://github.com/wjakob/nanobind
 Author: Wenzel Jakob
 Author-email: wenzel.jakob@epfl.ch
 License: BSD
+Platform: UNKNOWN
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 
 ![nanobind logo](
 https://github.com/wjakob/nanobind/raw/master/docs/images/logo.jpg?raw=True)
 
@@ -18,14 +19,18 @@
 [Boost.Python](https://www.boost.org/doc/libs/1_64_0/libs/python/doc/html)
 and [pybind11](http://github.com/pybind/pybind11) and uses near-identical
 syntax. In contrast to these existing tools, nanobind is more efficient:
 bindings compile in a shorter amount of time, produce smaller binaries, and
 have better runtime performance.
 
 More concretely,
-[benchmarks](https://nanobind.readthedocs.io/en/latest/benchmark.html) show
-**~2-3× faster** compile time, **~3× smaller** binaries, and up to **~8×
-lower** runtime overheads compared to pybind11.
+[benchmarks](https://nanobind.readthedocs.io/en/latest/benchmark.html) show up
+to **~4× faster** compile time, **~5× smaller** binaries, and **~10× lower**
+runtime overheads compared to pybind11. nanobind also outperforms Cython in
+important metrics (**3-12×** binary size reduction, **1.6-4×** compilation time
+reduction, similar runtime performance).
 
 Please see the following links for tutorial and reference documentation in
 [HTML](https://nanobind.readthedocs.io/en/latest/) and
 [PDF](https://nanobind.readthedocs.io/_/downloads/en/latest/pdf/) formats.
+
+
```

## Comparing `nanobind-1.1.1.dist-info/RECORD` & `nanobind-1.2.0.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,38 +1,37 @@
-nanobind/__init__.py,sha256=PbPTDoZOnLwzhQ3mZC4esADkpqydcdxY4qlp109RUr4,536
+nanobind/__init__.py,sha256=BfWmYNuAbvagMWq0QeU_R-u537oxkXAPJsYxD3loVu8,536
 nanobind/__main__.py,sha256=pOZfAi6HXCHLnzBZ0Ax1jJ-PbFDYJ-XP51yG5AgTmjA,839
 nanobind/cmake/darwin-ld-cpython.sym,sha256=qi-ZCmrzmvlN6QdhfUmQLQAyVaAg7dhH-DTSpGWhvoQ,21432
 nanobind/cmake/darwin-ld-pypy.sym,sha256=QF3OnNiEZfCskhbCig1FaaNF3DfkjDzLTMcP94o1_uE,24563
 nanobind/cmake/nanobind-config.cmake,sha256=sqWcyrMVyu6Efelrbe0wQDLrVXR9-o5s6NzE7Omz2rs,10363
 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h,sha256=LJaMwboQYidGGoaldoAplZDcslLeT5sP6L8lZghVaDU,11776
 nanobind/ext/robin_map/include/tsl/robin_hash.h,sha256=9jsUsbV085jb736e5Z6MJIYUSvrwBpLYmagPsOTiglc,54550
 nanobind/ext/robin_map/include/tsl/robin_map.h,sha256=WQiZfe4hA3mzQLlJXDZQax0rWjctSnyJnB9jJJgeC6Y,28414
 nanobind/ext/robin_map/include/tsl/robin_set.h,sha256=m5o-74heDBBcvGNsGME8_Y4wiLMO8Ax8t70urBH6srk,23593
 nanobind/include/nanobind/make_iterator.h,sha256=WKcEOQc_L_Mhhk1GgwwvsysUTbSgiBCmDnm0X7K330o,5601
-nanobind/include/nanobind/nanobind.h,sha256=aLeMVo1ZNjdt9Ad4Txz3k1wfeWZV2apeIaWO95lzDbE,1628
+nanobind/include/nanobind/nanobind.h,sha256=gxmjG9gLJGLiCiiu2L_c_IKzbMIWeepQrGXYSfJAdsI,1628
 nanobind/include/nanobind/nb_accessor.h,sha256=27K0E4cJYSBtD5VVsBtrLCWZTnTXXdr0IwtqLHeQ0aQ,5626
 nanobind/include/nanobind/nb_attr.h,sha256=REBdouY7U8ZHif3rTWv8Ar73RarjMeXSev-w5JHR3QU,7173
 nanobind/include/nanobind/nb_call.h,sha256=nNDUBNN8bbTgMUYRry_I7SR8deNHs2P1T7pPemCFK9k,5325
-nanobind/include/nanobind/nb_cast.h,sha256=FnKKSKayMZmwF_CXWkab5WBsHmjdZZfNIicagotJp9A,14184
-nanobind/include/nanobind/nb_class.h,sha256=6_emXw1sBxTaxg0GQusA2ltsMCP_yIMiMwhV_Y2AAr0,19171
+nanobind/include/nanobind/nb_cast.h,sha256=5LDpGd1mF6eR9eIEaltD1r-JoR83_eByemvkTdB0E2Q,13975
+nanobind/include/nanobind/nb_class.h,sha256=PUGiWi58P4Dz4G2EO3wqORF_GwJ9M9_-rE4jYQLMSj8,19205
 nanobind/include/nanobind/nb_defs.h,sha256=3oQ6zkZwCO6VVDqjeh6l_77U2rkEDdhGMeGctUdNOzQ,5507
 nanobind/include/nanobind/nb_descr.h,sha256=tX2-_5kHTuIe62iGi0sqn-QehGNYGjcL32OmeWoYY2g,4129
 nanobind/include/nanobind/nb_enums.h,sha256=JSxGC4c2YyN83gmcTVV450KLJX_RTRPAHRPUhxuAvds,666
 nanobind/include/nanobind/nb_error.h,sha256=Z8rGRtW9D7FjIOeS0G_tXYN5zN1LAvZNvVQ5O3r2FBs,3526
 nanobind/include/nanobind/nb_func.h,sha256=QMxiOQf6LnI5hDcrHa5r-KEkXLfbEJ-n64xmL1Y98Rk,9751
 nanobind/include/nanobind/nb_lib.h,sha256=g5Biz2O7Gf9MZ0da87OoHmpn8WPLi0PRrHHU2hfTIeY,18304
 nanobind/include/nanobind/nb_misc.h,sha256=D9NdER_kwi7qHGgYtKTsjPKHIkZqcGpqG9wT9XMtT74,1167
 nanobind/include/nanobind/nb_python.h,sha256=tuHjb9Dd4X5MOILJdgOFN_7RBIAAq3Y1bL_-POIRqKU,1377
 nanobind/include/nanobind/nb_traits.h,sha256=eJNLIHHx_1PMYHJwxsbf_QaM_1fGb3vsj1OES-7hCb8,6280
 nanobind/include/nanobind/nb_tuple.h,sha256=aqqTm9DkjH_SvDuPLKjU3Ya1lgs_LWyaQMkhTQRZoIc,2468
 nanobind/include/nanobind/nb_types.h,sha256=xxXX5X9XsMbNNcagEOC_6lFi78qpN26G3YH4R9L5bq4,25089
 nanobind/include/nanobind/ndarray.h,sha256=pUyfae5pWFHzdpw_VJo4DCYED5sehEYx0W-PgVXfSq4,12285
 nanobind/include/nanobind/operators.h,sha256=jSHKzNE_NDc--E65ycUsU6b0x1O_ThpzzCMV4uv5IE4,7449
-nanobind/include/nanobind/tensor.h,sha256=TkAx35liSSU7ptGwsSdPMlbuCVlhZcnBgvPVGCf88fY,276
-nanobind/include/nanobind/trampoline.h,sha256=pbOUaSdforI340HWsVPJ96xuNIVPTRDrnD6ag2kufQY,3010
+nanobind/include/nanobind/trampoline.h,sha256=Dx2NVfwiMkiqZ_zMxodWTkBQwmTrXAj599dueIIkCYY,3013
 nanobind/include/nanobind/eigen/dense.h,sha256=XXvpoh1sszCq6x_hxpVnhP11UwDNOvTiHx0YDBgxqZo,8411
 nanobind/include/nanobind/eigen/sparse.h,sha256=M1y9wF0AqVaIXXywzQVFtGZ91t5z8dytv_st5CxBhjg,6486
 nanobind/include/nanobind/stl/array.h,sha256=-jdVTy9gcqjH4kBVWbm52dGecHr90rwkusJX6ucHrII,535
 nanobind/include/nanobind/stl/bind_map.h,sha256=iEyY2r8iNdCYGY6_MHv6XsSzjWW_TY97ZQOBVflOo8w,5775
 nanobind/include/nanobind/stl/bind_vector.h,sha256=5z2IDbBMULnBdoJqRoQQFAWBwOPVhH40JVUqqZw8t9A,7250
 nanobind/include/nanobind/stl/filesystem.h,sha256=MAGHVOW5fq7GP3HwB-UaXDADA1kkPp1Y6JVe55XNFbk,2720
 nanobind/include/nanobind/stl/function.h,sha256=wlfxVQW3_c2KUJI9AFgq1MG9F9tXHJ8ASqjENy7CC3A,2478
@@ -56,19 +55,18 @@
 nanobind/include/nanobind/stl/detail/nb_set.h,sha256=vEq2LqjblYcgFHoC0VMptmTLq9-fH4SzY2ABNBZRNnM,1942
 nanobind/include/nanobind/stl/detail/traits.h,sha256=Aaa89qY0NJpmbkRzZA8OLLkH3IBZMV1aQ5Y1u9RUoaw,3218
 nanobind/src/buffer.h,sha256=Rmh6YRwuyajBiWq5FRh4nVvXNhD46f_qPz79obX_mqs,4165
 nanobind/src/common.cpp,sha256=lZuP5vlzcan7-LjEOTsSCmIhZWlDOuZz5VleETfsJtI,27942
 nanobind/src/error.cpp,sha256=dTB6RacW7SRHyUIBuYNRnUMaZFHiTPhxkjOOJC1WIqE,6327
 nanobind/src/implicit.cpp,sha256=9IJHaA8GJ1TTZ4AeChFbmWFKI6IvELG1hVwwr_9ZbCg,2548
 nanobind/src/nb_enum.cpp,sha256=Cf8xJ4uB7FyBdhNmvP_zo5LgDU2k6ZBURecPWkTpJX8,11560
-nanobind/src/nb_func.cpp,sha256=rIatUgEtYMaJrm7SMNbN0ZfsFLWN9x2z8SvlWh9cHCw,39298
-nanobind/src/nb_internals.cpp,sha256=XSPHc7M0In4YQFKW7qRRl0RCzcdCY_8ybrmi3JDb0Mk,19095
-nanobind/src/nb_internals.h,sha256=qFOrJGJOfBy1i8KZeigOWTiGq86t0kCKMF7GbzZd-uA,8552
+nanobind/src/nb_func.cpp,sha256=4IPJJEDnos5z_WgeldmvQWMw2dqSgReYdbzg6Iz2N6Q,39337
+nanobind/src/nb_internals.cpp,sha256=ozSpVJMP-uIty5pvHIEOLgSmoh6MxN7o9X0kRq4pEsU,18420
+nanobind/src/nb_internals.h,sha256=bFn22JXq3FeA6yKNu4LxAZoWODt5lg3O_6OkF0fOw10,8457
 nanobind/src/nb_ndarray.cpp,sha256=st0LPnCSy5cWrX25dxUgdaRK_ARDl_IocFQCDm1uISA,19495
-nanobind/src/nb_type.cpp,sha256=LabD6dP4eOE8-mDtsQAbLlJtYOelKgMQ-Dwdc5eC28g,45214
-nanobind/src/ndarray.cpp,sha256=Dwe3-ytb-V2fMh-a_BjoMPmtXTwclXnT9vuE8XiqR2o,18990
-nanobind/src/trampoline.cpp,sha256=wepoIarbrDwA_rBD2yz7KQn4Hoyixai-sxDRrl8RNXY,3701
-nanobind-1.1.1.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
-nanobind-1.1.1.dist-info/METADATA,sha256=jpy6dr2kTdOSFacOxeKCCT2bU9yeWc5zCdKQzGypnVQ,1248
-nanobind-1.1.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-nanobind-1.1.1.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
-nanobind-1.1.1.dist-info/RECORD,,
+nanobind/src/nb_type.cpp,sha256=IG8eaP6ELEGT3Gu5e7Gn1kQSSuc11xiRq9UuStsM74Q,47554
+nanobind/src/trampoline.cpp,sha256=dXZQjj2nKxcUjg4Nca4FPqRegp_HPHSNz77DwaC5TcA,3628
+nanobind-1.2.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
+nanobind-1.2.0.dist-info/METADATA,sha256=K5vpQYJYaEvvlBzrTd8aqS66IilxWCFdfuGDFhvOWxU,1426
+nanobind-1.2.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+nanobind-1.2.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
+nanobind-1.2.0.dist-info/RECORD,,
```

