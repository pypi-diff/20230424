# Comparing `tmp/navigator_auth-0.6.9-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/navigator_auth-0.7.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,88 +1,90 @@
-Zip file size: 616832 bytes, number of entries: 86
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 examples/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth-0.6.9.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/backends/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/handlers/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/storages/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/libs/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/abac/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/authorizations/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/middlewares/
--rw-r--r--  2.0 unx    15408 b- defN 23-Mar-26 19:03 navigator_auth/models.py
--rwxr-xr-x  2.0 unx   830832 b- defN 23-Mar-26 19:03 navigator_auth/exceptions.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx      270 b- defN 23-Mar-26 19:03 navigator_auth/__init__.py
--rw-r--r--  2.0 unx     2291 b- defN 23-Mar-26 19:03 navigator_auth/responses.py
--rw-r--r--  2.0 unx     3361 b- defN 23-Mar-26 19:03 navigator_auth/identities.py
--rw-r--r--  2.0 unx    10464 b- defN 23-Mar-26 19:03 navigator_auth/decorators.py
--rw-r--r--  2.0 unx     9004 b- defN 23-Mar-26 19:03 navigator_auth/conf.py
--rw-r--r--  2.0 unx    23134 b- defN 23-Mar-26 19:03 navigator_auth/auth.py
--rw-r--r--  2.0 unx      600 b- defN 23-Mar-26 19:03 navigator_auth/version.py
--rw-r--r--  2.0 unx    14373 b- defN 23-Mar-26 19:03 navigator_auth/backends/azure.py
--rw-r--r--  2.0 unx     1635 b- defN 23-Mar-26 19:03 navigator_auth/backends/oauth.py
--rw-r--r--  2.0 unx    15394 b- defN 23-Mar-26 19:03 navigator_auth/backends/abstract.py
--rw-r--r--  2.0 unx    15344 b- defN 23-Mar-26 19:03 navigator_auth/backends/external.py
--rw-r--r--  2.0 unx     4135 b- defN 23-Mar-26 19:03 navigator_auth/backends/jwksutils.py
--rw-r--r--  2.0 unx     8284 b- defN 23-Mar-26 19:03 navigator_auth/backends/basic.py
--rw-r--r--  2.0 unx     2256 b- defN 23-Mar-26 19:03 navigator_auth/backends/noauth.py
--rw-r--r--  2.0 unx      562 b- defN 23-Mar-26 19:03 navigator_auth/backends/__init__.py
--rw-r--r--  2.0 unx     5143 b- defN 23-Mar-26 19:03 navigator_auth/backends/google.py
--rw-r--r--  2.0 unx     7225 b- defN 23-Mar-26 19:03 navigator_auth/backends/api.py
--rw-r--r--  2.0 unx     9251 b- defN 23-Mar-26 19:03 navigator_auth/backends/token.py
--rw-r--r--  2.0 unx     5377 b- defN 23-Mar-26 19:03 navigator_auth/backends/okta.py
--rw-r--r--  2.0 unx     3640 b- defN 23-Mar-26 19:03 navigator_auth/backends/github.py
--rw-r--r--  2.0 unx    11471 b- defN 23-Mar-26 19:03 navigator_auth/backends/django.py
--rw-r--r--  2.0 unx     9719 b- defN 23-Mar-26 19:03 navigator_auth/backends/troc.py
--rw-r--r--  2.0 unx     9599 b- defN 23-Mar-26 19:03 navigator_auth/backends/adfs.py
--rw-r--r--  2.0 unx     4624 b- defN 23-Mar-26 19:03 navigator_auth/handlers/__init__.py
--rw-r--r--  2.0 unx      314 b- defN 23-Mar-26 19:03 navigator_auth/handlers/clients.py
--rw-r--r--  2.0 unx    26477 b- defN 23-Mar-26 19:03 navigator_auth/handlers/users.py
--rw-r--r--  2.0 unx    10869 b- defN 23-Mar-26 19:03 navigator_auth/handlers/base.py
--rw-r--r--  2.0 unx      342 b- defN 23-Mar-26 19:03 navigator_auth/handlers/permissions.py
--rw-r--r--  2.0 unx      838 b- defN 23-Mar-26 19:03 navigator_auth/handlers/orgs.py
--rw-r--r--  2.0 unx      978 b- defN 23-Mar-26 19:03 navigator_auth/handlers/program.py
--rw-r--r--  2.0 unx     5791 b- defN 23-Mar-26 19:03 navigator_auth/handlers/userattrs.py
--rw-r--r--  2.0 unx      708 b- defN 23-Mar-26 19:03 navigator_auth/handlers/groups.py
--rw-r--r--  2.0 unx    15819 b- defN 23-Mar-26 19:03 navigator_auth/handlers/model.py
--rw-r--r--  2.0 unx     2314 b- defN 23-Mar-26 19:03 navigator_auth/storages/abstract.py
--rw-r--r--  2.0 unx       59 b- defN 23-Mar-26 19:03 navigator_auth/storages/__init__.py
--rw-r--r--  2.0 unx     1288 b- defN 23-Mar-26 19:03 navigator_auth/storages/postgres.py
--rw-r--r--  2.0 unx      776 b- defN 23-Mar-26 19:03 navigator_auth/storages/redis.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 19:03 navigator_auth/libs/__init__.py
--rwxr-xr-x  2.0 unx   503728 b- defN 23-Mar-26 19:03 navigator_auth/libs/cipher.cpython-39-x86_64-linux-gnu.so
--rwxr-xr-x  2.0 unx   451736 b- defN 23-Mar-26 19:03 navigator_auth/libs/json.cpython-39-x86_64-linux-gnu.so
-drwxr-xr-x  2.0 unx        0 b- stor 23-Mar-26 19:03 navigator_auth/abac/storages/
--rw-r--r--  2.0 unx     5711 b- defN 23-Mar-26 19:03 navigator_auth/abac/pdp.py
--rw-r--r--  2.0 unx     3126 b- defN 23-Mar-26 19:03 navigator_auth/abac/errors.py
--rw-r--r--  2.0 unx     3118 b- defN 23-Mar-26 19:03 navigator_auth/abac/context.py
--rw-r--r--  2.0 unx     2262 b- defN 23-Mar-26 19:03 navigator_auth/abac/audit.py
--rw-r--r--  2.0 unx     5579 b- defN 23-Mar-26 19:03 navigator_auth/abac/policies.py
--rw-r--r--  2.0 unx      113 b- defN 23-Mar-26 19:03 navigator_auth/abac/__init__.py
--rw-r--r--  2.0 unx     2403 b- defN 23-Mar-26 19:03 navigator_auth/abac/decorators.py
--rw-r--r--  2.0 unx     1493 b- defN 23-Mar-26 19:03 navigator_auth/abac/middleware.py
--rw-r--r--  2.0 unx     3206 b- defN 23-Mar-26 19:03 navigator_auth/abac/guardian.py
--rw-r--r--  2.0 unx     2604 b- defN 23-Mar-26 19:03 navigator_auth/abac/storages/db.py
--rw-r--r--  2.0 unx      487 b- defN 23-Mar-26 19:03 navigator_auth/abac/storages/abstract.py
--rw-r--r--  2.0 unx      717 b- defN 23-Mar-26 19:03 navigator_auth/abac/storages/pg.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 19:03 navigator_auth/abac/storages/__init__.py
--rw-r--r--  2.0 unx      842 b- defN 23-Mar-26 19:03 navigator_auth/authorizations/abstract.py
--rw-r--r--  2.0 unx      170 b- defN 23-Mar-26 19:03 navigator_auth/authorizations/__init__.py
--rw-r--r--  2.0 unx      674 b- defN 23-Mar-26 19:03 navigator_auth/authorizations/allow_hosts.py
--rw-r--r--  2.0 unx      733 b- defN 23-Mar-26 19:03 navigator_auth/authorizations/hosts.py
--rw-r--r--  2.0 unx     3442 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/abstract.py
--rw-r--r--  2.0 unx      384 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/__init__.py
--rw-r--r--  2.0 unx     2912 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/token.py
--rw-r--r--  2.0 unx     3192 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/django.py
--rw-r--r--  2.0 unx     2838 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/troc.py
--rw-r--r--  2.0 unx     3707 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/apikey.py
--rw-r--r--  2.0 unx     4520 b- defN 23-Mar-26 19:03 navigator_auth/middlewares/jwt.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 19:03 examples/__init__.py
--rw-r--r--  2.0 unx     2362 b- defN 23-Mar-26 19:03 examples/test_handler.py
--rw-r--r--  2.0 unx     5060 b- defN 23-Mar-26 19:03 examples/test_abac.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Mar-26 19:03 navigator_auth-0.6.9.dist-info/LICENSE
--rw-r--r--  2.0 unx      148 b- defN 23-Mar-26 19:03 navigator_auth-0.6.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       24 b- defN 23-Mar-26 19:03 navigator_auth-0.6.9.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6715 b- defN 23-Mar-26 19:03 navigator_auth-0.6.9.dist-info/RECORD
--rw-r--r--  2.0 unx     3145 b- defN 23-Mar-26 19:03 navigator_auth-0.6.9.dist-info/METADATA
-86 files, 2128477 bytes uncompressed, 604746 bytes compressed:  71.6%
+Zip file size: 623068 bytes, number of entries: 88
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth-0.7.0.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/authorizations/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/storages/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/abac/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/backends/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/middlewares/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/handlers/
+-rw-r--r--  2.0 unx     2291 b- defN 23-Apr-24 02:15 navigator_auth/responses.py
+-rw-r--r--  2.0 unx     3529 b- defN 23-Apr-24 02:15 navigator_auth/identities.py
+-rw-r--r--  2.0 unx      270 b- defN 23-Apr-24 02:15 navigator_auth/__init__.py
+-rwxr-xr-x  2.0 unx   830832 b- defN 23-Apr-24 02:15 navigator_auth/exceptions.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx    10464 b- defN 23-Apr-24 02:15 navigator_auth/decorators.py
+-rw-r--r--  2.0 unx    23134 b- defN 23-Apr-24 02:15 navigator_auth/auth.py
+-rw-r--r--  2.0 unx      600 b- defN 23-Apr-24 02:15 navigator_auth/version.py
+-rw-r--r--  2.0 unx    15539 b- defN 23-Apr-24 02:15 navigator_auth/models.py
+-rw-r--r--  2.0 unx     9333 b- defN 23-Apr-24 02:15 navigator_auth/conf.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-24 02:15 navigator_auth/libs/__init__.py
+-rwxr-xr-x  2.0 unx   503728 b- defN 23-Apr-24 02:15 navigator_auth/libs/cipher.cpython-39-x86_64-linux-gnu.so
+-rwxr-xr-x  2.0 unx   451736 b- defN 23-Apr-24 02:15 navigator_auth/libs/json.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx      842 b- defN 23-Apr-24 02:15 navigator_auth/authorizations/abstract.py
+-rw-r--r--  2.0 unx      733 b- defN 23-Apr-24 02:15 navigator_auth/authorizations/hosts.py
+-rw-r--r--  2.0 unx      170 b- defN 23-Apr-24 02:15 navigator_auth/authorizations/__init__.py
+-rw-r--r--  2.0 unx      674 b- defN 23-Apr-24 02:15 navigator_auth/authorizations/allow_hosts.py
+-rw-r--r--  2.0 unx     2314 b- defN 23-Apr-24 02:15 navigator_auth/storages/abstract.py
+-rw-r--r--  2.0 unx       59 b- defN 23-Apr-24 02:15 navigator_auth/storages/__init__.py
+-rw-r--r--  2.0 unx     1288 b- defN 23-Apr-24 02:15 navigator_auth/storages/postgres.py
+-rw-r--r--  2.0 unx      776 b- defN 23-Apr-24 02:15 navigator_auth/storages/redis.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/abac/policies/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-24 02:15 navigator_auth/abac/storages/
+-rw-r--r--  2.0 unx    11772 b- defN 23-Apr-24 02:15 navigator_auth/abac/pdp.py
+-rw-r--r--  2.0 unx     8379 b- defN 23-Apr-24 02:15 navigator_auth/abac/guardian.py
+-rw-r--r--  2.0 unx     2984 b- defN 23-Apr-24 02:15 navigator_auth/abac/context.py
+-rw-r--r--  2.0 unx      113 b- defN 23-Apr-24 02:15 navigator_auth/abac/__init__.py
+-rw-r--r--  2.0 unx     3126 b- defN 23-Apr-24 02:15 navigator_auth/abac/errors.py
+-rw-r--r--  2.0 unx     1645 b- defN 23-Apr-24 02:15 navigator_auth/abac/middleware.py
+-rw-r--r--  2.0 unx     2403 b- defN 23-Apr-24 02:15 navigator_auth/abac/decorators.py
+-rw-r--r--  2.0 unx     2262 b- defN 23-Apr-24 02:15 navigator_auth/abac/audit.py
+-rw-r--r--  2.0 unx     5999 b- defN 23-Apr-24 02:15 navigator_auth/abac/policies/policy.py
+-rw-r--r--  2.0 unx      595 b- defN 23-Apr-24 02:15 navigator_auth/abac/policies/environment.py
+-rw-r--r--  2.0 unx     6251 b- defN 23-Apr-24 02:15 navigator_auth/abac/policies/abstract.py
+-rw-r--r--  2.0 unx      340 b- defN 23-Apr-24 02:15 navigator_auth/abac/policies/__init__.py
+-rw-r--r--  2.0 unx     9127 b- defN 23-Apr-24 02:15 navigator_auth/abac/policies/obj.py
+-rw-r--r--  2.0 unx     4287 b- defN 23-Apr-24 02:15 navigator_auth/abac/policies/file.py
+-rw-r--r--  2.0 unx     2604 b- defN 23-Apr-24 02:15 navigator_auth/abac/storages/db.py
+-rw-r--r--  2.0 unx      487 b- defN 23-Apr-24 02:15 navigator_auth/abac/storages/abstract.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-24 02:15 navigator_auth/abac/storages/__init__.py
+-rw-r--r--  2.0 unx      770 b- defN 23-Apr-24 02:15 navigator_auth/abac/storages/pg.py
+-rw-r--r--  2.0 unx     9599 b- defN 23-Apr-24 02:15 navigator_auth/backends/adfs.py
+-rw-r--r--  2.0 unx     5377 b- defN 23-Apr-24 02:15 navigator_auth/backends/okta.py
+-rw-r--r--  2.0 unx     7225 b- defN 23-Apr-24 02:15 navigator_auth/backends/api.py
+-rw-r--r--  2.0 unx     3640 b- defN 23-Apr-24 02:15 navigator_auth/backends/github.py
+-rw-r--r--  2.0 unx    11471 b- defN 23-Apr-24 02:15 navigator_auth/backends/django.py
+-rw-r--r--  2.0 unx    15394 b- defN 23-Apr-24 02:15 navigator_auth/backends/abstract.py
+-rw-r--r--  2.0 unx     4135 b- defN 23-Apr-24 02:15 navigator_auth/backends/jwksutils.py
+-rw-r--r--  2.0 unx     9251 b- defN 23-Apr-24 02:15 navigator_auth/backends/token.py
+-rw-r--r--  2.0 unx      562 b- defN 23-Apr-24 02:15 navigator_auth/backends/__init__.py
+-rw-r--r--  2.0 unx    14373 b- defN 23-Apr-24 02:15 navigator_auth/backends/azure.py
+-rw-r--r--  2.0 unx     2256 b- defN 23-Apr-24 02:15 navigator_auth/backends/noauth.py
+-rw-r--r--  2.0 unx     9719 b- defN 23-Apr-24 02:15 navigator_auth/backends/troc.py
+-rw-r--r--  2.0 unx     8284 b- defN 23-Apr-24 02:15 navigator_auth/backends/basic.py
+-rw-r--r--  2.0 unx    15344 b- defN 23-Apr-24 02:15 navigator_auth/backends/external.py
+-rw-r--r--  2.0 unx     1635 b- defN 23-Apr-24 02:15 navigator_auth/backends/oauth.py
+-rw-r--r--  2.0 unx     5143 b- defN 23-Apr-24 02:15 navigator_auth/backends/google.py
+-rw-r--r--  2.0 unx     4520 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/jwt.py
+-rw-r--r--  2.0 unx     3707 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/apikey.py
+-rw-r--r--  2.0 unx     3192 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/django.py
+-rw-r--r--  2.0 unx     3442 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/abstract.py
+-rw-r--r--  2.0 unx     2912 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/token.py
+-rw-r--r--  2.0 unx      384 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/__init__.py
+-rw-r--r--  2.0 unx     2838 b- defN 23-Apr-24 02:15 navigator_auth/middlewares/troc.py
+-rw-r--r--  2.0 unx     8174 b- defN 23-Apr-24 02:15 navigator_auth/handlers/userattrs.py
+-rw-r--r--  2.0 unx      708 b- defN 23-Apr-24 02:15 navigator_auth/handlers/groups.py
+-rw-r--r--  2.0 unx     4914 b- defN 23-Apr-24 02:15 navigator_auth/handlers/__init__.py
+-rw-r--r--  2.0 unx    19074 b- defN 23-Apr-24 02:15 navigator_auth/handlers/model.py
+-rw-r--r--  2.0 unx      838 b- defN 23-Apr-24 02:15 navigator_auth/handlers/orgs.py
+-rw-r--r--  2.0 unx      314 b- defN 23-Apr-24 02:15 navigator_auth/handlers/clients.py
+-rw-r--r--  2.0 unx    10993 b- defN 23-Apr-24 02:15 navigator_auth/handlers/base.py
+-rw-r--r--  2.0 unx      342 b- defN 23-Apr-24 02:15 navigator_auth/handlers/permissions.py
+-rw-r--r--  2.0 unx    26477 b- defN 23-Apr-24 02:15 navigator_auth/handlers/users.py
+-rw-r--r--  2.0 unx     1170 b- defN 23-Apr-24 02:15 navigator_auth/handlers/program.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Apr-24 02:15 navigator_auth-0.7.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx      148 b- defN 23-Apr-24 02:15 navigator_auth-0.7.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 23-Apr-24 02:15 navigator_auth-0.7.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6970 b- defN 23-Apr-24 02:15 navigator_auth-0.7.0.dist-info/RECORD
+-rw-r--r--  2.0 unx     3198 b- defN 23-Apr-24 02:15 navigator_auth-0.7.0.dist-info/METADATA
+88 files, 2160551 bytes uncompressed, 610518 bytes compressed:  71.8%
```

## zipnote {}

```diff
@@ -1,259 +1,265 @@
 Filename: navigator_auth/
 Comment: 
 
-Filename: examples/
-Comment: 
-
-Filename: navigator_auth-0.6.9.dist-info/
+Filename: navigator_auth-0.7.0.dist-info/
 Comment: 
 
 Filename: navigator_auth.libs/
 Comment: 
 
-Filename: navigator_auth/backends/
+Filename: navigator_auth/libs/
 Comment: 
 
-Filename: navigator_auth/handlers/
+Filename: navigator_auth/authorizations/
 Comment: 
 
 Filename: navigator_auth/storages/
 Comment: 
 
-Filename: navigator_auth/libs/
-Comment: 
-
 Filename: navigator_auth/abac/
 Comment: 
 
-Filename: navigator_auth/authorizations/
+Filename: navigator_auth/backends/
 Comment: 
 
 Filename: navigator_auth/middlewares/
 Comment: 
 
-Filename: navigator_auth/models.py
+Filename: navigator_auth/handlers/
 Comment: 
 
-Filename: navigator_auth/exceptions.cpython-39-x86_64-linux-gnu.so
+Filename: navigator_auth/responses.py
 Comment: 
 
-Filename: navigator_auth/__init__.py
+Filename: navigator_auth/identities.py
 Comment: 
 
-Filename: navigator_auth/responses.py
+Filename: navigator_auth/__init__.py
 Comment: 
 
-Filename: navigator_auth/identities.py
+Filename: navigator_auth/exceptions.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
 Filename: navigator_auth/decorators.py
 Comment: 
 
-Filename: navigator_auth/conf.py
-Comment: 
-
 Filename: navigator_auth/auth.py
 Comment: 
 
 Filename: navigator_auth/version.py
 Comment: 
 
-Filename: navigator_auth/backends/azure.py
+Filename: navigator_auth/models.py
 Comment: 
 
-Filename: navigator_auth/backends/oauth.py
+Filename: navigator_auth/conf.py
 Comment: 
 
-Filename: navigator_auth/backends/abstract.py
+Filename: navigator_auth/libs/__init__.py
 Comment: 
 
-Filename: navigator_auth/backends/external.py
+Filename: navigator_auth/libs/cipher.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
-Filename: navigator_auth/backends/jwksutils.py
+Filename: navigator_auth/libs/json.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
-Filename: navigator_auth/backends/basic.py
+Filename: navigator_auth/authorizations/abstract.py
 Comment: 
 
-Filename: navigator_auth/backends/noauth.py
+Filename: navigator_auth/authorizations/hosts.py
 Comment: 
 
-Filename: navigator_auth/backends/__init__.py
+Filename: navigator_auth/authorizations/__init__.py
 Comment: 
 
-Filename: navigator_auth/backends/google.py
+Filename: navigator_auth/authorizations/allow_hosts.py
 Comment: 
 
-Filename: navigator_auth/backends/api.py
+Filename: navigator_auth/storages/abstract.py
 Comment: 
 
-Filename: navigator_auth/backends/token.py
+Filename: navigator_auth/storages/__init__.py
 Comment: 
 
-Filename: navigator_auth/backends/okta.py
+Filename: navigator_auth/storages/postgres.py
 Comment: 
 
-Filename: navigator_auth/backends/github.py
+Filename: navigator_auth/storages/redis.py
 Comment: 
 
-Filename: navigator_auth/backends/django.py
+Filename: navigator_auth/abac/policies/
 Comment: 
 
-Filename: navigator_auth/backends/troc.py
+Filename: navigator_auth/abac/storages/
 Comment: 
 
-Filename: navigator_auth/backends/adfs.py
+Filename: navigator_auth/abac/pdp.py
 Comment: 
 
-Filename: navigator_auth/handlers/__init__.py
+Filename: navigator_auth/abac/guardian.py
 Comment: 
 
-Filename: navigator_auth/handlers/clients.py
+Filename: navigator_auth/abac/context.py
 Comment: 
 
-Filename: navigator_auth/handlers/users.py
+Filename: navigator_auth/abac/__init__.py
 Comment: 
 
-Filename: navigator_auth/handlers/base.py
+Filename: navigator_auth/abac/errors.py
 Comment: 
 
-Filename: navigator_auth/handlers/permissions.py
+Filename: navigator_auth/abac/middleware.py
 Comment: 
 
-Filename: navigator_auth/handlers/orgs.py
+Filename: navigator_auth/abac/decorators.py
 Comment: 
 
-Filename: navigator_auth/handlers/program.py
+Filename: navigator_auth/abac/audit.py
 Comment: 
 
-Filename: navigator_auth/handlers/userattrs.py
+Filename: navigator_auth/abac/policies/policy.py
 Comment: 
 
-Filename: navigator_auth/handlers/groups.py
+Filename: navigator_auth/abac/policies/environment.py
 Comment: 
 
-Filename: navigator_auth/handlers/model.py
+Filename: navigator_auth/abac/policies/abstract.py
 Comment: 
 
-Filename: navigator_auth/storages/abstract.py
+Filename: navigator_auth/abac/policies/__init__.py
 Comment: 
 
-Filename: navigator_auth/storages/__init__.py
+Filename: navigator_auth/abac/policies/obj.py
 Comment: 
 
-Filename: navigator_auth/storages/postgres.py
+Filename: navigator_auth/abac/policies/file.py
 Comment: 
 
-Filename: navigator_auth/storages/redis.py
+Filename: navigator_auth/abac/storages/db.py
 Comment: 
 
-Filename: navigator_auth/libs/__init__.py
+Filename: navigator_auth/abac/storages/abstract.py
 Comment: 
 
-Filename: navigator_auth/libs/cipher.cpython-39-x86_64-linux-gnu.so
+Filename: navigator_auth/abac/storages/__init__.py
 Comment: 
 
-Filename: navigator_auth/libs/json.cpython-39-x86_64-linux-gnu.so
+Filename: navigator_auth/abac/storages/pg.py
 Comment: 
 
-Filename: navigator_auth/abac/storages/
+Filename: navigator_auth/backends/adfs.py
 Comment: 
 
-Filename: navigator_auth/abac/pdp.py
+Filename: navigator_auth/backends/okta.py
 Comment: 
 
-Filename: navigator_auth/abac/errors.py
+Filename: navigator_auth/backends/api.py
 Comment: 
 
-Filename: navigator_auth/abac/context.py
+Filename: navigator_auth/backends/github.py
 Comment: 
 
-Filename: navigator_auth/abac/audit.py
+Filename: navigator_auth/backends/django.py
 Comment: 
 
-Filename: navigator_auth/abac/policies.py
+Filename: navigator_auth/backends/abstract.py
 Comment: 
 
-Filename: navigator_auth/abac/__init__.py
+Filename: navigator_auth/backends/jwksutils.py
 Comment: 
 
-Filename: navigator_auth/abac/decorators.py
+Filename: navigator_auth/backends/token.py
 Comment: 
 
-Filename: navigator_auth/abac/middleware.py
+Filename: navigator_auth/backends/__init__.py
 Comment: 
 
-Filename: navigator_auth/abac/guardian.py
+Filename: navigator_auth/backends/azure.py
 Comment: 
 
-Filename: navigator_auth/abac/storages/db.py
+Filename: navigator_auth/backends/noauth.py
 Comment: 
 
-Filename: navigator_auth/abac/storages/abstract.py
+Filename: navigator_auth/backends/troc.py
 Comment: 
 
-Filename: navigator_auth/abac/storages/pg.py
+Filename: navigator_auth/backends/basic.py
 Comment: 
 
-Filename: navigator_auth/abac/storages/__init__.py
+Filename: navigator_auth/backends/external.py
 Comment: 
 
-Filename: navigator_auth/authorizations/abstract.py
+Filename: navigator_auth/backends/oauth.py
 Comment: 
 
-Filename: navigator_auth/authorizations/__init__.py
+Filename: navigator_auth/backends/google.py
 Comment: 
 
-Filename: navigator_auth/authorizations/allow_hosts.py
+Filename: navigator_auth/middlewares/jwt.py
 Comment: 
 
-Filename: navigator_auth/authorizations/hosts.py
+Filename: navigator_auth/middlewares/apikey.py
 Comment: 
 
-Filename: navigator_auth/middlewares/abstract.py
+Filename: navigator_auth/middlewares/django.py
 Comment: 
 
-Filename: navigator_auth/middlewares/__init__.py
+Filename: navigator_auth/middlewares/abstract.py
 Comment: 
 
 Filename: navigator_auth/middlewares/token.py
 Comment: 
 
-Filename: navigator_auth/middlewares/django.py
+Filename: navigator_auth/middlewares/__init__.py
 Comment: 
 
 Filename: navigator_auth/middlewares/troc.py
 Comment: 
 
-Filename: navigator_auth/middlewares/apikey.py
+Filename: navigator_auth/handlers/userattrs.py
 Comment: 
 
-Filename: navigator_auth/middlewares/jwt.py
+Filename: navigator_auth/handlers/groups.py
 Comment: 
 
-Filename: examples/__init__.py
+Filename: navigator_auth/handlers/__init__.py
+Comment: 
+
+Filename: navigator_auth/handlers/model.py
+Comment: 
+
+Filename: navigator_auth/handlers/orgs.py
+Comment: 
+
+Filename: navigator_auth/handlers/clients.py
 Comment: 
 
-Filename: examples/test_handler.py
+Filename: navigator_auth/handlers/base.py
+Comment: 
+
+Filename: navigator_auth/handlers/permissions.py
 Comment: 
 
-Filename: examples/test_abac.py
+Filename: navigator_auth/handlers/users.py
+Comment: 
+
+Filename: navigator_auth/handlers/program.py
 Comment: 
 
-Filename: navigator_auth-0.6.9.dist-info/LICENSE
+Filename: navigator_auth-0.7.0.dist-info/LICENSE
 Comment: 
 
-Filename: navigator_auth-0.6.9.dist-info/WHEEL
+Filename: navigator_auth-0.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: navigator_auth-0.6.9.dist-info/top_level.txt
+Filename: navigator_auth-0.7.0.dist-info/top_level.txt
 Comment: 
 
-Filename: navigator_auth-0.6.9.dist-info/RECORD
+Filename: navigator_auth-0.7.0.dist-info/RECORD
 Comment: 
 
-Filename: navigator_auth-0.6.9.dist-info/METADATA
+Filename: navigator_auth-0.7.0.dist-info/METADATA
 Comment: 
 
 Zip file comment:
```

## navigator_auth/models.py

```diff
@@ -214,15 +214,15 @@
     identity_id: UUID = Column(required=False, primary_key=True, db_default="auto", repr=False)
     display_name: str = Column(required=False)
     title: str = Column(required=False)
     nickname: str = Column(required=False)
     email: str = Column(required=False)
     phone: str = Column(required=False)
     short_bio: Text = Column(required=False)
-    avatar: str = Column(required=False)
+    avatar: Text = Column(required=False)
     user_id: User = Column(required=True, fk="user_id|username", api="users", label="User")
     auth_provider: str = Column(required=False)
     auth_data: Optional[dict] = Column(required=False, repr=False)
     attributes: Optional[dict] = Column(required=False, repr=False)
     created_at: datetime = Column(required=False, default=datetime.now(), repr=False)
 
     class Meta:
@@ -235,15 +235,15 @@
     identity_id: UUID = Column(required=False, primary_key=True, db_default="auto", repr=False)
     display_name: str = Column(required=False)
     title: str = Column(required=False)
     nickname: str = Column(required=False)
     email: str = Column(required=False)
     phone: str = Column(required=False)
     short_bio: Text = Column(required=False)
-    avatar: str = Column(required=False)
+    avatar: Text = Column(required=False)
     user_id: User = Column(required=True, fk="user_id|username", api="users", label="User")
     accounts: Optional[dict] = Column(required=False, default_factory=dict)
 
     class Meta:
         name = "vw_user_identities"
         schema = AUTH_DB_SCHEMA
         strict = True
@@ -343,16 +343,16 @@
         name = "user_groups"
         schema = AUTH_DB_SCHEMA
         strict = True
         connection = None
 
 
 class ProgramGroup(Model):
-    program_id: Program = Column(required=True, primary_key=True)
-    group_id: Group = Column(required=True, primary_key=True)
+    program_id: Program = Column(required=True, primary_key=True, fk="user_id|username", api="users", label="User")
+    group_id: Group = Column(required=True, primary_key=True, fk="group_id|group_name", api="groups", label="Group")
     created_at: datetime = Column(required=False, default=datetime.now())
     created_by: str = Column(required=False)
 
     class Meta:
         name = "program_groups"
         schema = AUTH_DB_SCHEMA
         strict = True
@@ -432,16 +432,16 @@
     """Social Accounts from User"""
     account_id: UUID = Column(
         required=False, primary_key=True, db_default="auto", repr=False
     )
     user_id: User = Column(required=True)
     provider: str = Column(required=True)
     uid: str = Column(required=False)
-    address: str = Column(required=False)
+    address: str = Column(required=False, repr=False)
     account: Optional[dict] = Column(required=False, default_factory=dict)
-    created_at: datetime = Column(required=False, default=datetime.now())
+    created_at: datetime = Column(required=False, default=datetime.now(), repr=False)
 
     class Meta:
         name = "user_accounts"
         schema = AUTH_DB_SCHEMA
         strict = True
         connection = None
```

## navigator_auth/identities.py

```diff
@@ -8,14 +8,18 @@
     name: str
     uri: str
     description: str
     icon: str
     external: bool = Column(required=True, default=False)
     headers: dict = Column(required=False, default_factory=dict)
 
+    class Meta:
+        strict = True
+        frozen = False
+
 
 class Group(BaseModel):
     """Group.
 
     Association (group) were users belongs to.
     """
 
@@ -27,32 +31,32 @@
 
 
 # create a Guest Group.
 Guest = Group(group="guest")
 
 
 class Organization(BaseModel):
-    org_id: str
-    organization: str
-    slug: str
+    org_id: str = Column(required=True)
+    organization: str = Column(required=True)
+    slug: str = Column(required=False)
 
     def __post_init__(self) -> None:
         super(Organization, self).__post_init__()
         if not self.slug:
             self.slug = slugify(self.organization)
 
     class Meta:
         strict = True
         frozen = False
 
 
 class Program(BaseModel):
-    program_id: int
-    program_name: str
-    program_slug: str
+    program_id: int = Column(required=True)
+    program_name: str = Column(required=True)
+    program_slug: str = Column(required=False)
 
     def __post_init__(self) -> None:
         super(Program, self).__post_init__()
         if not self.program_slug:
             self.program_slug = slugify(self.program_name)
 
     class Meta:
@@ -66,17 +70,17 @@
     Describe an Authenticated Entity on Navigator.
     """
 
     id: Any = Column(required=True)
     auth_method: str = None
     access_token: Optional[str] = None
     enabled: bool = Column(required=True, default=True)
-    data: InitVar = Column(required=False, default_factory=dict)
+    data: InitVar = {}
     is_authenticated: bool = Column(equired=False, default=False)
-    userdata: dict = Column(required=False, default_factory={})
+    userdata: dict = Column(required=False, default_factory=dict)
 
     def __post_init__(self, data):  # pylint: disable=W0221
         self.userdata = data
         for key, value in data.items():
             self.create_field(key, value)
 
     def set(self, name: str, value: Any) -> None:
```

## navigator_auth/conf.py

```diff
@@ -53,14 +53,20 @@
 exclude_list = excluded_default + new_excluded
 
 # if false, force credentials are not required for using this system.
 AUTH_CREDENTIALS_REQUIRED = config.getboolean(
     "AUTH_CREDENTIALS_REQUIRED", fallback=True
 )
 
+# what happen when a user doesn't exists?
+# possible values are: create (user is created), raise (a UserDoesntExists exception raises)
+# and ignore, session is created but user is missing.
+AUTH_MISSING_ACCOUNT = config.get("AUTH_MISSING_ACCOUNT", fallback="create")
+# List of function callbacks called (in order) when a user is
+
 # AsyncDB Model representing a User Record.
 AUTH_USER_MODEL = config.get("AUTH_USER_MODEL", fallback="navigator_auth.models.User")
 # User View can represent a more complex user View used for getting User Data.
 AUTH_USER_VIEW = config.get("AUTH_USER_VIEW", fallback="navigator_auth.models.User")
 
 # Group Record.
 AUTH_GROUP_MODEL = config.get(
```

## navigator_auth/version.py

```diff
@@ -3,15 +3,15 @@
    Navigator Auth allows us to authenticate/authorize users over an aiohttp application.
 """
 
 __title__ = "navigator_auth"
 __description__ = (
     "Navigator Auth is an Authentication/Authorization Toolkit for aiohttp."
 )
-__version__ = "0.6.9"  # pragma: no cover
+__version__ = "0.7.0"  # pragma: no cover
 __author__ = "Jesus Lara"
 __author_email__ = "jesuslarag@gmail.com"
 __license__ = "Apache 2.0 license"
 
 
 def get_version() -> tuple:  # pragma: no cover
     """
```

## navigator_auth/handlers/__init__.py

```diff
@@ -1,12 +1,12 @@
 from .clients import ClientHandler
 from .orgs import OrganizationHandler, UserOrganizationHandler
 from .permissions import PermissionHandler
 from .users import UserHandler, UserSession
-from .program import ProgramCatHandler, ProgramHandler, ProgramClientHandler
+from .program import ProgramCatHandler, ProgramHandler, ProgramClientHandler, ProgramGroupHandler
 from .groups import GroupHandler, GroupPermissionHandler, UserGroupHandler
 from .userattrs import UserAccountHandler, UserIdentityHandler
 
 ## TODO migration of login/logout handlers:
 
 
 def handler_routes(router) -> None:
@@ -106,14 +106,21 @@
     # User Account:
     router.add_view(
         r"/api/v1/user_identity/{id:.*}", UserIdentityHandler, name="api_auth_useridentity_id"
     )
     router.add_view(
         r"/api/v1/user_identity{meta:\:?.*}", UserIdentityHandler, name="api_auth_useridentity"
     )
+    ## Program Group:
+    router.add_view(
+        r"/api/v1/program_groups/{id:.*}", ProgramGroupHandler, name="api_auth_programgroup_id"
+    )
+    router.add_view(
+        r"/api/v1/program_groups{meta:\:?.*}", ProgramGroupHandler, name="api_auth_programgroup"
+    )
     ### User Session Methods:
     usr = UserSession()
     router.add_get("/api/v2/user/logout", usr.logout, allow_head=True)
     router.add_delete("/api/v2/user/logout", usr.logout)
     router.add_get("/api/v2/user/session", usr.user_session, allow_head=True)
     router.add_get("/api/v2/user/profile", usr.user_profile, allow_head=True)
     router.add_put("/api/v2/user/in_session", usr.in_session)
```

## navigator_auth/handlers/base.py

```diff
@@ -145,25 +145,29 @@
         reason: Union[dict, str] = None,
         exception: Exception = None,
         headers: dict = None,
         content_type: str = "application/json",
         status: int = 400,
         **kwargs,
     ) -> web.Response:
+        if isinstance(reason, dict):
+            reason = self._json.dumps(reason)
         response_obj = {
             "reason": reason if reason else str(exception),
             "content_type": content_type,
             **kwargs,
         }
         if headers:
             response_obj["headers"] = headers
         if isinstance(exception, dict):
             response_obj["text"] = self._json.dumps(exception)
-        else:
+        elif exception is not None:
             response_obj["text"] = str(exception)
+        else:
+            response_obj["text"] = reason
         # defining the error
         if status == 400:  # bad request
             obj = web.HTTPBadRequest(**response_obj)
         elif status == 401:  # unauthorized
             obj = web.HTTPUnauthorized(**response_obj)
         elif status == 403:  # forbidden
             obj = web.HTTPForbidden(**response_obj)
@@ -195,15 +199,14 @@
         if headers:
             response_obj["headers"] = headers
         response = HTTPNotImplemented(**response_obj)
         raise response
 
     def not_allowed(
         self,
-        request: web.Request = None,
         response: dict = None,
         headers: dict = None,
         allowed: dict = None,
         content_type: str = "application/json",
         **kwargs,
     ) -> web.Response:
         if not request:
```

## navigator_auth/handlers/program.py

```diff
@@ -1,13 +1,14 @@
 from typing import Any
 from navigator_auth.models import (
     ProgramCategory,
     Program,
     ProgramAttribute,
     ProgramClient,
+    ProgramGroup
 )
 from navigator_auth.conf import (
     AUTH_PROGRAM_MODEL,
     AUTH_PROGRAM_CLIENT_MODEL,
     AUTH_PROGRAM_CATEGORY_MODEL,
 )
 from .model import ModelHandler
@@ -34,7 +35,14 @@
 
 
 class ProgramClientHandler(ModelHandler):
     model: Any = ProgramClient
     model_name: str = AUTH_PROGRAM_CLIENT_MODEL
     name: str = "Program Client"
     pk: list = ["program_id", "client_id"]
+
+
+class ProgramGroupHandler(ModelHandler):
+    model: Any = ProgramGroup
+    model_name: str = None
+    name: str = "Program Groups"
+    pk: list = ["program_id", "group_id"]
```

## navigator_auth/handlers/userattrs.py

```diff
@@ -1,31 +1,146 @@
 from typing import Any
-from navigator_auth.models import (
-    UserAccount, UserIdentity, VwUserIdentity
+from asyncdb.exceptions import (
+    NoDataFound,
+    StatementError
 )
+from datamodel.exceptions import ValidationError
+from asyncdb.exceptions import DriverError
 from navigator_session import get_session, AUTH_SESSION_OBJECT
 from navigator_auth.exceptions import AuthException
-from datamodel.exceptions import ValidationError
-from asyncdb.exceptions import DriverError, ProviderError, NoDataFound, StatementError
-from .model import ModelHandler
+from navigator_auth.models import (
+    UserAccount, UserIdentity, VwUserIdentity
+)
 from navigator_auth.conf import (
     AUTH_USER_IDENTITY_MODEL
 )
+from .model import ModelHandler
+
 
 class UserAccountHandler(ModelHandler):
     model: Any = UserAccount
-    name: str = "User Accounts"
+    name: str = "User Account"
     pk: str = "account_id"
 
+    async def _get_user_id(self, value, column, data):
+        return await self.get_userid(session=self._session)
+
+    async def _get_address(self, value, column, data):
+        db = self.request.app['authdb']
+        try:
+            userid = data['uid']
+        except KeyError:
+            return self.error(
+                reason=f"Invalid User ID for {self.name}", status=410
+            )
+        try:
+            provider = data['provider']
+        except KeyError:
+            provider = None
+        if provider:
+            try:
+                async with await db.acquire() as conn:
+                    qry = f"SELECT social_url FROM auth.social_networks WHERE social_network = '{provider}'"
+                    result = await conn.fetchval(qry, column='social_url')
+                    return result.format(uid=userid)
+            except DriverError:
+                pass
+            except Exception as ex:
+                self.logger.error(str(ex))
+        return None
+
+    async def get(self):
+        db = self.request.app["database"]
+        params = self.match_parameters(self.request)
+        try:
+            if params["meta"] == ":meta":
+                response = self.model.schema(as_dict=True)
+                return self.json_response(content=response)
+        except KeyError:
+            pass
+        try:
+            session = await self.session()
+            user_id = await self.get_userid(session=session)
+        except (KeyError, TypeError):
+            user_id = None
+
+        args = {}
+        if isinstance(self.pk, str):
+            try:
+                objid = params["id"]
+            except KeyError:
+                objid = None
+            if objid:
+                args = {self.pk: objid}
+        elif isinstance(self.pk, list):
+            try:
+                paramlist = params["id"].split("/")
+                if len(paramlist) != len(self.pk):
+                    return self.error(
+                        reason=f"Invalid Number of URL elements for PK: {self.pk}, {paramlist!r}",
+                        status=410,
+                    )
+                args = {}
+                for key in self.pk:
+                    args[key] = paramlist.pop(0)
+            except KeyError:
+                pass
+        else:
+            return self.error(
+                reason=f"Invalid PK definition for {self.name}: {self.pk}", status=410
+            )
+        if args:
+            # get data for specific client:
+            async with await db.acquire() as conn:
+                self.model.Meta.connection = conn
+                # look for this client, after, save changes
+                error = {"error": f"{self.name} was not Found"}
+                try:
+                    result = await self.model.get(**args)
+                except NoDataFound:
+                    self.error(exception=error, status=403)
+                if not result:
+                    self.error(exception=error, status=403)
+                return self.json_response(content=result)
+        else:
+            async with await db.acquire() as conn:
+                self.model.Meta.connection = conn
+                
+                try:
+                    filter = {
+                                "user_id": user_id
+                            }
+
+                    UserAccounts = await self.model.filter(**filter)
+                    if not UserAccounts:
+                        headers = {
+                            "X-STATUS": "EMPTY",
+                            "X-MESSAGE": "UserAccounts not Found",
+                        }
+                        data = {"message": "No Content"}
+                        code = 204
+
+                        return self.response(response=data, headers=headers, status=code)
+                    else:
+                        headers = {"x-status": "OK", "x-message": "User Account Data"}
+                        return self.json_response(content=UserAccounts, headers=headers, status=200)
+                except Exception as err:
+                    print(err)
+                    return self.error(exception=err, status=500)
+
+
 class UserIdentityHandler(ModelHandler):
     model: Any = UserIdentity
     model_name: str = AUTH_USER_IDENTITY_MODEL
     name: str = "User Identity"
     pk: str = "identity_id"
 
+    async def _get_user_id(self, value, column, data):
+        return await self.get_userid(session=self._session)
+
     async def get(self):
         db = self.request.app["database"]
         params = self.match_parameters(self.request)
         try:
             if params["meta"] == ":meta":
                 # returning JSON schema of Model:
                 response = self.model.schema(as_dict=True)
@@ -33,15 +148,15 @@
         except KeyError:
             pass
         try:
             session = await get_session(self.request)
             user_id = session[AUTH_SESSION_OBJECT]["user_id"]
         except (KeyError, TypeError):
             user_id = None
-            
+
         args = {}
         if isinstance(self.pk, str):
             try:
                 objid = params["id"]
             except KeyError:
                 objid = None
             if objid:
@@ -79,71 +194,24 @@
         else:
             async with await db.acquire() as conn:
                 VwUserIdentity.Meta.connection = conn
                 try:
                     filter = {
                                 "user_id": user_id
                             }
-                    
+
                     UserIdentity = await VwUserIdentity.filter(**filter)
                     if not UserIdentity:
                         headers = {
                             "X-STATUS": "EMPTY",
                             "X-MESSAGE": "UserIdentity not Found",
                         }
                         data = {"message": "No Content"}
                         code = 204
 
                         return self.response(response=data, headers=headers, status=code)
                     else:
                         headers = {"x-status": "OK", "x-message": "User Identity Data"}
-                        print(UserIdentity)
                         return self.json_response(content=UserIdentity, headers=headers, status=200)
                 except Exception as err:
                     print(err)
-                return self.error(exception=err, status=500)
-    
-    async def put(self):
-        """Creating Model information."""
-        session = await self.session()
-        if not session:
-            return self.error(reason="Unauthorized", status=403)
-        ### get session Data:
-        try:
-            user_id = session[AUTH_SESSION_OBJECT]["user_id"]
-        except (KeyError, TypeError):
-            user_id = None
-        try:
-            data = await self.json_data()
-            data['user_id'] = user_id
-        except (TypeError, ValueError, AuthException):
-            return self.error(reason=f"Invalid {self.name} Data", status=403)
-        ## validate directly with model:
-        try:
-            print(data)
-            resultset = self.model(**data)  # pylint: disable=E1102
-            db = self.request.app["authdb"]
-            async with await db.acquire() as conn:
-                resultset.Meta.connection = conn
-                result = await resultset.insert()
-                return self.json_response(content=result, status=201)
-        except ValidationError as ex:
-            error = {
-                "error": f"Unable to insert {self.name} info",
-                "payload": ex.payload,
-            }
-            return self.error(reason=error, status=406)
-        except StatementError as ex:
-            # UniqueViolation, already exists:
-            error = {
-                "error": f"Record already exists for {self.name}",
-                "payload": str(ex),
-            }
-            return self.error(exception=error, status=412)
-        except (TypeError, AttributeError, ValueError) as ex:
-            error = {
-                "error": f"Invalid payload for {self.name}",
-                "payload": str(ex),
-            }
-            return self.error(exception=error, status=406)
-
-        
+                    return self.error(exception=err, status=500)
```

## navigator_auth/handlers/model.py

```diff
@@ -1,15 +1,16 @@
 """
 Model Handler: Abstract Model for managing Model with Views.
 """
-from typing import Union
+from typing import Union, Optional, Any
 import importlib
+from aiohttp import web
 from datamodel import BaseModel
 from datamodel.exceptions import ValidationError
-from asyncdb.exceptions import DriverError, ProviderError, NoDataFound, StatementError
+from asyncdb.exceptions import DriverError, ProviderError, NoDataFound, StatementError, ModelError
 from navigator_session import get_session
 from navigator_auth.exceptions import AuthException
 from .base import BaseView
 
 
 class ModelHandler(BaseView):
     model: BaseModel = None
@@ -34,29 +35,90 @@
             module = importlib.import_module(classpath, package=name)
             obj = getattr(module, name)
             return obj
         except ImportError:
             ## Using fallback Model
             return self.model
 
+    async def get_userid(self, session, idx: str = 'user_id') -> int:
+        if not session:
+            self.error(
+                reason="Unauthorized",
+                status=403
+            )
+        try:
+            if 'session' in session:
+                return session['session'][idx]
+            else:
+                return session[idx]
+        except KeyError:
+            self.error(reason="Unauthorized", status=403)
+
+    async def _get_data(self, session: Optional[Any] = None) -> Any:
+        """_get_data.
+
+        Get and pre-processing POST data before use it.
+        """
+        data = {}
+        try:
+            data = await self.json_data()
+            for name, column in self.model.get_columns().items():
+                ### if a function with name _get_{column name} exists
+                ### then that function is called for getting the field value
+                if hasattr(self, f'_get_{name}'):
+                    fn = getattr(self, f'_get_{name}')
+                    data[name] = await fn(value=data.get(name, None), column=column, data=data)
+        except (TypeError, ValueError, AttributeError):
+            self.error(
+                reason=f"Invalid {self.name} Data", status=400
+            )
+        return data
+
+    async def _post_get(self, result: Any, fields: list[str] = None) -> web.Response:
+        """_post_get.
+
+        Extensible for post-processing the GET response.
+        """
+        if not result:
+            return self.no_content()
+        else:
+            if fields is not None:
+                if isinstance(result, list):
+                    new = []
+                    for r in result:
+                        row = {}
+                        for field in fields:
+                            row[field] = getattr(r, field, None)
+                        new.append(row)
+                    result = new
+                else:
+                    ## filtering result to returning only fields asked:
+                    result = {}
+                    for field in fields:
+                        result[field] = getattr(result, field, None)
+            return self.json_response(content=result)
+
     async def session(self):
-        session = None
+        self._session = None
         try:
-            session = await get_session(self.request)
+            self._session = await get_session(self.request)
         except (ValueError, RuntimeError) as err:
             return self.critical(
                 reason="Error Decoding Session", request=self.request, exception=err
             )
-        return session
+        if not self._session:
+            self.error(
+                response={"message": "Unauthorized"},
+                status=403
+            )
+        return self._session
 
     async def head(self):
         """Getting Client information."""
         session = await self.session()
-        if not session:
-            return self.error(reason="Unauthorized", status=403)
         ## calculating resource:
         response = self.model.schema(as_dict=True)
         columns = list(response["properties"].keys())
         size = len(str(response))
         headers = {
             "Content-Length": size,
             "X-Columns": f"{columns!r}",
@@ -65,36 +127,36 @@
             "X-Schema": self.model.Meta.schema,
         }
         return self.no_content(headers=headers)
 
     async def get(self):
         """Getting Client information."""
         session = await self.session()
-        if not session:
-            return self.error(reason="Unauthorized", status=403)
         ## getting all clients:
         params = self.match_parameters(self.request)
         try:
             if params["meta"] == ":meta":
                 # returning JSON schema of Model:
                 response = self.model.schema(as_dict=True)
                 return self.json_response(content=response)
         except KeyError:
             pass
-        try:
-            data = await self.json_data()
-        except (TypeError, ValueError, AuthException):
-            data = None
         ## validate directly with model:
         db = self.request.app["authdb"]
         ## getting first the id from params or data:
         args = {}
+        qp = self.query_parameters(request=self.request)
+        try:
+            fields = qp['fields'].split(',')
+            del qp['fields']
+        except KeyError:
+            fields = None
         if isinstance(self.pk, str):
             try:
-                objid = data[self.pk]
+                objid = params[self.pk]
             except (TypeError, KeyError):
                 try:
                     objid = params["id"]
                 except KeyError:
                     objid = None
             if objid:
                 args = {self.pk: objid}
@@ -119,101 +181,112 @@
             # get data for specific client:
             async with await db.acquire() as conn:
                 self.model.Meta.connection = conn
                 # look for this client, after, save changes
                 error = {"error": f"{self.name} was not Found"}
                 try:
                     result = await self.model.get(**args)
+                except ModelError as ex:
+                    error = {
+                        "error": f"Missing Info for Model {self.name}",
+                        "payload": str(ex)
+                    }
+                    return self.error(reason=error, status=400)
                 except NoDataFound:
-                    self.error(exception=error, status=403)
+                    self.error(reason=error, status=404)
                 if not result:
-                    self.error(exception=error, status=403)
-                return self.json_response(content=result)
+                    self.error(reason=error, status=404)
+                return await self._post_get(result, fields=fields)
         else:
-            # TODO: add FILTER method
             try:
                 async with await db.acquire() as conn:
                     self.model.Meta.connection = conn
-                    result = await self.model.all()
-                    return self.json_response(content=result)
+                    if qp:
+                        result = await self.model.filter(**qp)
+                    else:
+                        result = await self.model.all()
+                    return await self._post_get(result, fields=fields)
+            except ModelError as ex:
+                error = {
+                    "error": f"Missing Info for Model {self.name}",
+                    "payload": str(ex)
+                }
+                return self.error(reason=error, status=400)
             except ValidationError as ex:
                 error = {
                     "error": f"Unable to load {self.name} info from Database",
                     "payload": ex.payload,
                 }
-                return self.critical(reason=error, statu=501)
+                return self.critical(reason=error, status=501)
             except TypeError as ex:
                 error = {
                     "error": f"Invalid payload for {self.name}",
                     "payload": str(ex),
                 }
-                return self.error(exception=error, statu=406)
-            except (DriverError, ProviderError, RuntimeError):
+                return self.error(reason=error, status=406)
+            except (DriverError, ProviderError, RuntimeError) as ex:
                 error = {
                     "error": "Database Error",
                     "payload": str(ex),
                 }
-                return self.critical(reason=error, statu=500)
+                return self.critical(reason=error, status=500)
 
     async def put(self):
         """Creating Model information."""
         session = await self.session()
-        if not session:
-            return self.error(reason="Unauthorized", status=403)
         ### get session Data:
-        try:
-            data = await self.json_data()
-        except (TypeError, ValueError, AuthException):
-            return self.error(reason=f"Invalid {self.name} Data", status=403)
+        data = await self._get_data(session=session)
         ## validate directly with model:
         try:
             resultset = self.model(**data)  # pylint: disable=E1102
             db = self.request.app["authdb"]
             async with await db.acquire() as conn:
                 resultset.Meta.connection = conn
                 result = await resultset.insert()
                 return self.json_response(content=result, status=201)
+        except ModelError as ex:
+            error = {
+                "error": f"Missing Info for Model {self.name}",
+                "payload": str(ex)
+            }
+            return self.error(reason=error, status=400)
         except ValidationError as ex:
             error = {
                 "error": f"Unable to insert {self.name} info",
                 "payload": ex.payload,
             }
             return self.error(reason=error, status=406)
         except StatementError as ex:
             # UniqueViolation, already exists:
             error = {
                 "error": f"Record already exists for {self.name}",
                 "payload": str(ex),
             }
-            return self.error(exception=error, status=412)
+            return self.error(reason=error, status=412)
         except (TypeError, AttributeError, ValueError) as ex:
             error = {
                 "error": f"Invalid payload for {self.name}",
                 "payload": str(ex),
             }
-            return self.error(exception=error, status=406)
+            return self.error(reason=error, status=406)
 
     async def patch(self):
         """Patch an existing Client or retrieve the column names."""
         session = await self.session()
-        if not session:
-            return self.error(reason="Unauthorized", status=403)
         ### get session Data:
         params = self.match_parameters()
         try:
             if params["meta"] == ":meta":
                 ## returning the columns on Model:
                 fields = self.model.__fields__
                 return self.json_response(content=fields)
         except KeyError:
             pass
-        try:
-            data = await self.json_data()
-        except (TypeError, ValueError, AuthException):
-            return self.error(reason=f"Invalid {self.name} Data", status=403)
+        ### get session Data:
+        data = await self._get_data(session=session)
         ## validate directly with model:
         ## getting first the id from params or data:
         args = {}
         if isinstance(self.pk, str):
             try:
                 objid = data[self.pk]
             except (TypeError, KeyError):
@@ -239,40 +312,41 @@
         db = self.request.app["authdb"]
         if args:
             ## getting client
             async with await db.acquire() as conn:
                 self.model.Meta.connection = conn
                 try:
                     result = await self.model.get(**args)
+                except ModelError as ex:
+                    error = {
+                        "error": f"Missing Info for Model {self.name}",
+                        "payload": str(ex)
+                    }
+                    return self.error(reason=error, status=400)
                 except NoDataFound:
                     headers = {"x-error": f"{self.name} was not Found"}
                     self.no_content(headers=headers)
                 if not result:
                     headers = {"x-error": f"{self.name} was not Found"}
                     self.no_content(headers=headers)
                 ## saved with new changes:
                 for key, val in data.items():
                     if key in result.get_fields():
                         result.set(key, val)
                 data = await result.update()
                 return self.json_response(content=data, status=202)
         else:
-            self.error(reason=f"Invalid {self.name} Data to Patch", status=403)
+            self.error(reason=f"Invalid {self.name} Data to Patch", status=400)
 
     async def post(self):
         """Create or Update a Client."""
         session = await self.session()
-        if not session:
-            return self.error(reason="Unauthorized", status=403)
         ### get session Data:
         params = self.match_parameters()
-        try:
-            data = await self.json_data()
-        except (TypeError, ValueError, AuthException):
-            return self.error(reason=f"Invalid {self.name} Data", status=403)
+        data = await self._get_data(session=session)
         ## validate directly with model:
         ## getting first the id from params or data:
         args = {}
         if isinstance(self.pk, str):
             try:
                 objid = data[self.pk]
             except (TypeError, KeyError):
@@ -299,22 +373,28 @@
         if args:
             async with await db.acquire() as conn:
                 self.model.Meta.connection = conn
                 # look for this client, after, save changes
                 error = {"error": f"{self.name} was not Found"}
                 try:
                     result = await self.model.get(**args)
-                except NoDataFound:
+                except (NoDataFound, ModelError):
                     # create new Record
                     result = None
                 if not result:
                     try:
                         resultset = self.model(**data)  # pylint: disable=E1102
                         result = await resultset.insert()
                         return self.json_response(content=result, status=201)
+                    except ModelError as ex:
+                        error = {
+                            "error": f"Missing Info for Model {self.name}",
+                            "payload": str(ex)
+                        }
+                        return self.error(reason=error, status=400)
                     except ValidationError as ex:
                         error = {
                             "error": f"Unable to insert {self.name} info",
                             "payload": ex.payload,
                         }
                         return self.error(reason=error, status=406)
                 ## saved with new changes:
@@ -327,14 +407,20 @@
             # create a new client based on data:
             try:
                 resultset = self.model(**data)  # pylint: disable=E1102
                 async with await db.acquire() as conn:
                     resultset.Meta.connection = conn
                     result = await resultset.insert()  # TODO: migrate to use save()
                     return self.json_response(content=result, status=201)
+            except ModelError as ex:
+                error = {
+                    "error": f"Missing Info for Model {self.name}",
+                    "payload": str(ex)
+                }
+                return self.error(reason=error, status=400)
             except ValidationError as ex:
                 error = {
                     "error": f"Unable to insert {self.name} info",
                     "payload": ex.payload,
                 }
                 return self.error(reason=error, status=406)
             except (TypeError, AttributeError, ValueError) as ex:
@@ -343,24 +429,24 @@
                     "payload": str(ex),
                 }
                 return self.error(exception=error, status=406)
 
     async def delete(self):
         """Delete a Client."""
         session = await self.session()
-        if not session:
-            self.error(reason="Unauthorized", status=403)
         ### get session Data:
         params = self.match_parameters()
         try:
-            data = await self.json_data()
+            data = await self._get_data(session=session)
         except AuthException:
             data = None
         except (TypeError, ValueError):
-            self.error(reason=f"Invalid {self.name} Data", status=403)
+            self.error(
+                reason=f"Invalid {self.name} Data", status=406
+            )
         ## getting first the id from params or data:
         args = {}
         if isinstance(self.pk, str):
             try:
                 objid = data[self.pk]
             except (TypeError, KeyError):
                 objid = params["id"]
```

## navigator_auth/abac/pdp.py

```diff
@@ -1,94 +1,153 @@
-from typing import List, Optional, Any
+from typing import List, Optional, Union, Any
+import asyncio
 from aiohttp import web
 from navconfig.logging import logger
 from navigator_session import SessionData
 from navigator_auth.conf import AUTH_SESSION_OBJECT
-from .policies import Policy
-from .policies import PolicyEffect
-from .errors import PreconditionFailed, Unauthorized, AccessDenied
+from .policies import Exp, Policy, ObjectPolicy, FilePolicy, PolicyEffect, Environment
+from .errors import PreconditionFailed, AccessDenied
 from .context import EvalContext
-from .guardian import Guardian
+from .guardian import Guardian, PEP
 from .storages.abstract import AbstractStorage
 from .audit import AuditLog
 from .middleware import abac_middleware
 
 
 async def find_deny_policy(ctx, policies):
     for policy in policies:
         answer = await policy.allowed(ctx)
         if answer.effect == PolicyEffect.DENY:
             return answer
     return None
 
+
 class PDP:
     """ABAC Policy Decision Point implementation.
     """
     def __init__(self, storage: AbstractStorage, policies: Optional[List[Policy]] = None):
         self._policies: list = []
         if isinstance(policies, list):
             self._policies = policies
         ### Loading an Storage and registering for Load Policies.
         self.storage = storage
         self.logger = logger
-        self.auditlog = AuditLog()
+        self._auditlog = AuditLog()
 
     def add_policy(self, policy: Policy):
         self._policies.append(policy)
         self.sorted_policies()
 
     def sorted_policies(self):
         self._policies.sort(key=lambda policy: policy.priority)
 
+    async def on_startup(self, app: web.Application):
+        """Signal Handler for loading Policies from Storage.
+        """
+        policies = await self.storage.load_policies()
+        for policy in policies:
+            try:
+                policy_type = policy['policy_type']
+                del policy['policy_type']
+            except KeyError:
+                policy_type = 'policy'
+            if policy['effect'] == 'ALLOW':
+                policy['effect'] = PolicyEffect.ALLOW
+            else:
+                policy['effect'] = PolicyEffect.DENY
+            if policy_type == 'policy':
+                p = Policy(**policy)
+            elif policy_type == 'file':
+                p = FilePolicy(**policy)
+            self._policies.append(p)
+        self._policies.sort(key=lambda policy: policy.priority)
+
+    async def on_shutdown(self, app: web.Application):
+        await self.storage.close()
+
+    def setup(self, app: web.Application):
+        if isinstance(app, web.Application):
+            self.app = app # register the app into the Extension
+        elif hasattr(app, "get_app"):
+            self.app = app.get_app()
+        else:
+            raise TypeError(
+                f"Invalid type for Application Setup: {app}:{type(app)}"
+            )
+        ### Also creates a PEP (Policy Enforcing Point) on backend
+        self.app['security'] = Guardian(pdp=self)
+        ## and the PDP itself:
+        self.app['abac'] = self
+        # startup operations over storage backend
+        self.app.on_startup.append(
+            self.on_startup
+        )
+        # cleanup operations over storage backend
+        self.app.on_shutdown.append(
+            self.on_shutdown
+        )
+        # the backend add a middleware to the app
+        mdl = self.app.middlewares
+        # add the middleware for this backend Authentication
+        mdl.append(abac_middleware)
+        ### create the API endpoint for this ABAC
+        pep = PEP()
+        self.app.router.add_post(
+            "/api/v1/abac/authorize", pep.authorize
+        )
+        self.app.router.add_post(
+            "/api/v1/abac/is_allowed", pep.is_allowed
+        )
+
     async def authorize(
             self,
             request: web.Request,
             session: SessionData = None,
             user: Any = None,
             effect: PolicyEffect = PolicyEffect.ALLOW
         ):
         try:
             userinfo = session[AUTH_SESSION_OBJECT]
         except KeyError:
             userinfo = None
         ctx = EvalContext(request, user, userinfo, session)
-
         # Get filtered policies based on targets from storage
         # Filter policies that fit Inquiry by its attributes.
-        filtered = [p for p in self._policies if p.fits(ctx)]
-
-        self.logger.debug(f'FILTERED POLICIES > {filtered!r}')
+        filtered = [p for p in self._policies if type(p) == Policy and p.fits(ctx)]
+        self.logger.verbose(f'FILTERED POLICIES > {filtered!r}')
         # no policies -> deny access!
         if len(filtered) == 0:
             raise PreconditionFailed(
                 "No Matching Policies were found, Deny access."
             )
         # we have policies - all of them should have allow effect, otherwise -> deny access!
         answer = False
-        # try:
-        #     answer = await find_deny_policy(ctx, filtered)
-        #     if answer is not None:
-        #         raise Unauthorized(
-        #             f"Access Denied: {answer.response}"
-        #         )
-        # except StopAsyncIteration:
-        #     pass
         for policy in filtered:
-            answer = await policy.allowed(ctx)
-            if answer.effect == PolicyEffect.DENY:
-                ## Audit Log
-                await self.auditlog.log(answer, PolicyEffect(answer.effect).name, user)
-                raise Unauthorized(
-                    f"Access Denied: {answer.response}"
-                )
-        ## Audit Log
-        await self.auditlog.log(answer, PolicyEffect(answer.effect).name , user)
-        ## return default effect:
+            self.logger.notice(f'Policy: {policy}')
+            #answer = await policy.allowed(ctx)
+            answer = await asyncio.to_thread(policy.evaluate, ctx, Environment())
+            if answer.effect == effect:
+                await self.auditlog(answer, user)
+                ## return default effect:
+                return answer
+        if answer and answer.effect == PolicyEffect.DENY:
+            ## Audit Log
+            await self.auditlog(answer, user)
+            raise AccessDenied(
+                f"Access Denied: {answer.response}"
+            )
         return answer
 
+    ## Audit Log
+    async def auditlog(self, answer, user):
+        try:
+            await self._auditlog.log(answer, PolicyEffect(answer.effect).name, user)
+        except Exception as exc:
+            self.logger.warning(f'Error saving policy Log: {exc}')
+
     async def allowed_groups(
             self,
             request: web.Request,
             session: SessionData = None,
             user: Any = None,
             groups: list = None,
             effect: PolicyEffect = PolicyEffect.ALLOW
@@ -102,57 +161,154 @@
         else:
             for group in user.groups:
                 if group.group in groups:
                     member = True
                     break
         if member is True:
             ## TODO: Return an ABAC Response (allow/deny with )
-            # await self.auditlog.log(answer, PolicyEffect(effect).name , user)
+            # await self.auditlog(answer, PolicyEffect(effect).name , user)
             return effect
         else:
             ## TODO migrate to a custom response.
             # await self.auditlog.log(answer, PolicyEffect('deny').name , user)
             raise AccessDenied(
                 "Access Denied"
             )
 
-    async def on_startup(self, app: web.Application):
-        """Signal Handler for loading Policies from Storage.
-        """
-        policies = await self.storage.load_policies()
-        for policy in policies:
-            if policy['effect'] == 'ALLOW':
-                policy['effect'] = PolicyEffect.ALLOW
-            else:
-                policy['effect'] = PolicyEffect.DENY
-            p = Policy(**policy)
-            self._policies.append(p)
-        self._policies.sort(key=lambda policy: policy.priority)
+    async def filter_files(
+            self,
+            request: web.Request,
+            files: list[str],
+            session: SessionData = None,
+            user: Any = None
+        ):
+        try:
+            userinfo = session[AUTH_SESSION_OBJECT]
+        except KeyError:
+            userinfo = None
+        ctx = EvalContext(request, user, userinfo, session)
+        ctx.objects = files
+        # Get filtered policies based on targets from storage
+        # Filter policies that fit Inquiry by its attributes.
+        filtered = [p for p in self._policies if type(p) == FilePolicy and p.fits(ctx)]  # pylint: disable=C0123
+        self.logger.verbose(f'FILTERED POLICIES > {filtered!r}')
+        # no policies -> deny access!
+        if len(filtered) == 0:
+            raise PreconditionFailed(
+                "No Matching Policies were found, Deny access."
+            )
+        _files = set(files)
+        denied_files_set = set()
+        for policy in filtered:
+            self.logger.notice(f'Filter Policy: {policy}')
+            #answer = await policy.allowed(ctx)
+            files_allowed = await asyncio.to_thread(policy.filter_files, ctx, Environment())
+            files_allowed_set = set(files_allowed)
+            if policy.effect == PolicyEffect.ALLOW:
+                _files = _files.intersection(files_allowed_set)
+            elif policy.effect == PolicyEffect.DENY:
+                denied_files = set(ctx.objects).difference(files_allowed_set)
+                denied_files_set = denied_files_set.union(denied_files)
+        final_allowed_files = list(_files.difference(denied_files_set))
+        return final_allowed_files
 
-    async def on_shutdown(self, app: web.Application):
-        await self.storage.close()
 
-    def setup(self, app: web.Application):
-        if isinstance(app, web.Application):
-            self.app = app # register the app into the Extension
-        elif hasattr(app, "get_app"):
-            self.app = app.get_app()
+    async def is_allowed(
+            self,
+            request: web.Request,
+            session: SessionData = None,
+            user: Any = None,
+            **kwargs
+        ):
+        try:
+            userinfo = session[AUTH_SESSION_OBJECT]
+        except KeyError:
+            userinfo = None
+        ctx = EvalContext(request, user, userinfo, session)
+        # Get filtered policies based on targets from storage
+        # Filter policies that fit Inquiry by its attributes.
+        obj = kwargs.get('resource', None)
+        if obj:
+            if isinstance(obj, str):
+                ctx.objects = Exp(obj)
+            else:
+                ctx.objects = [Exp(r) for r in obj]
+            filtered = [
+                p for p in self._policies if isinstance(p, ObjectPolicy) and p.fits(ctx)
+            ]
         else:
-            raise TypeError(
-                f"Invalid type for Application Setup: {app}:{type(app)}"
+            filtered = [p for p in self._policies if p.fits(ctx)]
+        self.logger.verbose(f'FILTERED ALLOWED POLICIES > {filtered!r}')
+        # no policies -> deny access!
+        if len(filtered) == 0:
+            raise PreconditionFailed(
+                "No Matching Policies were found, Deny access."
             )
-        ### Also creates a PEP (Policy Enforcing Point)
-        self.app['security'] = Guardian(pdp=self)
-        ## and the PDP itself:
-        self.app['abac'] = self
-        # startup operations over storage backend
-        self.app.on_startup.append(
-            self.on_startup
-        )
-        # cleanup operations over storage backend
-        self.app.on_shutdown.append(
-            self.on_shutdown
-        )
-        # the backend add a middleware to the app
-        mdl = self.app.middlewares
-        # add the middleware for this backend Authentication
-        mdl.append(abac_middleware)
+        # we have policies - all of them should have allow, otherwise -> deny access
+        answer = False
+        for policy in filtered:
+            self.logger.notice(f'Allowed Policy: {policy!r}')
+            answer = await asyncio.to_thread(
+                policy.is_allowed,
+                ctx,
+                Environment(),
+                **kwargs
+            )
+            if answer.effect == PolicyEffect.ALLOW:
+                await self.auditlog(answer, user)
+                ## return default effect:
+                return answer
+        ## Audit Log
+        await self.auditlog(answer, user)
+        return answer
+
+
+    async def filter_obj(
+            self,
+            request: web.Request,
+            objects: Union[str, list],
+            _type: str,
+            session: SessionData = None,
+            user: Any = None,
+            effect: PolicyEffect = PolicyEffect.ALLOW
+        ):
+        try:
+            userinfo = session[AUTH_SESSION_OBJECT]
+        except KeyError:
+            userinfo = None
+        ctx = EvalContext(request, user, userinfo, session)
+        if not isinstance(objects, list):
+            objects = [objects]
+        ctx.objects = objects
+        ctx.objectype = _type
+        # Get filtered policies based on targets from storage
+        # Filter policies that fit Inquiry by its attributes.
+        filtered = [p for p in self._policies if hasattr(p, '_filter') and p.fits(ctx)]
+        self.logger.verbose(f'FILTERED POLICIES > {filtered!r}')
+        # no policies -> deny access!
+        if len(filtered) == 0:
+            raise PreconditionFailed(
+                "No Matching Policies were found, Deny access."
+            )
+        # we have policies - all of them should have allow, otherwise -> deny access
+        answer = False
+        for policy in filtered:
+            self.logger.notice(f'Policy: {policy!r}')
+            #answer = await policy.allowed(ctx)
+            answer = await asyncio.to_thread(
+                policy._filter,
+                objects,
+                _type,
+                ctx,
+                Environment()
+            )
+            if answer.effect == effect:
+                await self.auditlog(answer, user)
+                ## return default effect:
+                return answer
+        if answer and answer.effect == PolicyEffect.DENY:
+            ## Audit Log
+            await self.auditlog(answer, user)
+            raise AccessDenied(
+                f"Access Denied: {answer.response}"
+            )
+        return answer
```

## navigator_auth/abac/context.py

```diff
@@ -1,29 +1,31 @@
 from typing import Any
 from collections.abc import MutableMapping, Iterator
-import time
-from datetime import datetime
 from aiohttp import web
 from datamodel import BaseModel
 
 class EvalContext(dict, MutableMapping):
     """EvalContext.
 
     Build The Evaluation Context from Request and User Data.
     """
-    def __init__(self, request: web.Request, user: Any, userinfo: Any, session: Any, *args, **kwargs):
+    def __init__(
+        self,
+        request: web.Request,
+        user: Any,
+        userinfo: Any,
+        session: Any,
+        *args,
+        **kwargs
+    ):
         ## initialize the mutable mapping:
         self.store = dict()
         self.store['ip_addr'] = request.remote
         self.store['method'] = request.method
         self.store['referer'] = request.headers.get('referer', None)
-        self.store['time'] = time.time()
-        dow = datetime.today().weekday()
-        self.store['dow'] = dow
-        self.store['day_of_week'] = dow
         self.store['path_qs'] = request.path_qs
         self.store['path'] = request.path
         self.store['headers'] = request.headers
         self.store['url'] = request.rel_url
         self.store['user'] = user
         if isinstance(user, BaseModel):
             self.store['user_keys'] = user.get_fields()
@@ -45,15 +47,15 @@
         return zip(self._columns, self.store)
 
     def keys(self) -> list:
         return self._columns
 
     def set(self, key, value) -> None:
         self.store[key] = value
-        if not key in self._columns:
+        if key not in self._columns:
             self._columns.append(key)
 
     ### Section: Simple magic methods
     def __len__(self) -> int:
         return len(self.store)
 
     def __str__(self) -> str:
@@ -72,15 +74,15 @@
     def __delitem__(self, key) -> None:
         value = self.store[key]
         del self.store[key]
         self._columns.pop(value, None)
 
     def __setitem__(self, key, value):
         self.store[key] = value
-        if not key in self._columns:
+        if key not in self._columns:
             self._columns.append(key)
 
     def __getattr__(self, key):
         try:
             return super().__getattribute__('store')[key]
         except KeyError as ex:
             raise AttributeError(key) from ex
```

## navigator_auth/abac/middleware.py

```diff
@@ -1,14 +1,19 @@
 from collections.abc import Awaitable, Callable
 from aiohttp import web, hdrs
 from aiohttp.web_urldispatcher import SystemRoute
 from navconfig.logging import logging
 from navigator_auth.conf import exclude_list
 
 
+exceptions = (
+    "/api/v1/abac/authorize",
+    "/api/v1/abac/is_allowed",
+)
+
 @web.middleware
 async def abac_middleware(
     request: web.Request,
     handler: Callable[[web.Request], Awaitable[web.StreamResponse]],
 ) -> web.StreamResponse:
     """
     Basic AUthorizacion/Access Middleware.
@@ -22,14 +27,16 @@
         if isinstance(request.match_info.route, SystemRoute):  # eg. 404
             return await handler(request)
     except Exception:  # pylint: disable=W0703
         pass
     # avoid authorization on exclude list
     if request.path in exclude_list:
         return await handler(request)
+    if request.path in exceptions:
+        return await handler(request)
     logging.debug(' == ABAC MIDDLEWARE == ')
     ### get Guardian:
     try:
         guardian = request.app['security']
         response = await guardian.authorize(request=request)
         logging.info(
             f"Access based on Authorize response: {response!r}"
```

## navigator_auth/abac/guardian.py

```diff
@@ -1,9 +1,11 @@
+from typing import List
 from collections.abc import Callable
 from aiohttp import web
+from navigator.views import BaseHandler
 from navigator_session import get_session
 from .errors import PreconditionFailed, AccessDenied
 from .policies import PolicyEffect
 
 
 class Guardian:
     """Guardian.
@@ -38,27 +40,43 @@
         return (session, user)
 
     async def authorize(self, request: web.Request):
         """authorize.
 
             Check if user has access based on PDP Policies.
         Args:
-            request (web.Request): _description_
+            request (web.Request): Web Request.
 
         Raises:
             web.HTTPUnauthorized: Access is Denied.
         """
         self.is_authenticated(request=request)
         session, user = await self.get_user(request)
         return await self.pdp.authorize(
             request=request,
             session=session,
             user=user
         )
 
+    async def filter_files(self, files: List[str], request: web.Request):
+        """filter_files.
+
+            Retrieve filtered list of files with permissions.
+        Args:
+            request (web.Request): Web Request.
+        """
+        self.is_authenticated(request=request)
+        session, user = await self.get_user(request)
+        return await self.pdp.filter_files(
+            request=request,
+            session=session,
+            user=user,
+            files=files
+        )
+
     async def has_permission(self, request: web.Request, permissions: list):
         """has_permission.
 
             Check if user has the permission to access this resource.
         Args:
             request (web.Request): Web Request.
             permissions (list): List of requested permissions.
@@ -83,21 +101,176 @@
         ):
         """allowed_groups.
 
             Check if user is belong to any permitted groups.
         Args:
             request (web.Request): Web request.
             groups (list): List of allowed groups.
-            effect (PolicyEffect, optional): Effect to be applied, Defaults to PolicyEffect.ALLOW.
+            effect (PolicyEffect): Effect to be applied, Defaults to PolicyEffect.ALLOW.
 
         Raises:
             web.HTTPUnauthorized: Access is Denied.
         """
         self.is_authenticated(request=request)
         session, user = await self.get_user(request)
         return await self.pdp.allowed_groups(
             request=request,
             session=session,
             user=user,
             groups=groups,
             effect=effect
         )
+
+    async def is_allowed(
+            self,
+            request: web.Request,
+            **kwargs
+        ):
+        """is_allowed.
+
+            Check if user is allowed to access some object resources and return
+            (in response) the list of allowed objects.
+        Args:
+            request (web.Request): Web request.
+            objects (list): List of objects to be evaluated.
+            objtype (str): kind of object to be evaluated (default=file)
+        Raises:
+            web.HTTPUnauthorized: Access is Denied.
+        """
+        self.is_authenticated(request=request)
+        session, user = await self.get_user(request)
+        _type = type
+        return await self.pdp.is_allowed(
+            request=request,
+            session=session,
+            user=user,
+            **kwargs
+        )
+
+
+    async def filter(
+            self,
+            request: web.Request,
+            objects: list,
+            type: str = 'file',
+            effect: PolicyEffect = PolicyEffect.ALLOW
+        ):
+        """filter.
+
+            Check if user is allowed to access some object resources and return filtered
+            list of resources. (in response) the list of allowed objects.
+        Args:
+            request (web.Request): Web request.
+            objects (list): List of objects to be evaluated.
+            objtype (str): kind of object to be evaluated (default=file)
+            effect (PolicyEffect, optional): Effect to be applied,
+              Defaults to PolicyEffect.ALLOW.
+
+        Raises:
+            web.HTTPUnauthorized: Access is Denied.
+        """
+        self.is_authenticated(request=request)
+        session, user = await self.get_user(request)
+        return await self.pdp.filter_obj(
+            request=request,
+            session=session,
+            user=user,
+            objects=objects,
+            _type=type,
+            effect=effect
+        )
+
+
+class PEP(BaseHandler):
+
+    def get_guardian(self, request: web.Request):
+        try:
+            return request.app['security']
+        except (ValueError, KeyError):
+            self.critical(
+                reason="ABAC System is not Installed."
+            )
+
+    async def authorize(self, request: web.Request) -> web.Response:
+        """authorize.
+
+            Check if user has access based on PDP Policies.
+        Args:
+            request (web.Request): Web Request.
+
+        Raises:
+            web.HTTPUnauthorized: Access is Denied.
+        """
+        guardian = self.get_guardian(request)
+        policy = await guardian.authorize(request=request)
+        if policy.effect:
+            msg = {
+                "message": "Access Granted",
+                "response": policy.response,
+                "policy": policy.rule
+            }
+            return self.json_response(
+                response=msg,
+                status=202
+            )
+        else:
+            msg = {
+                "error": "Access Denied",
+                "response": policy.response,
+                "policy": policy.rule
+            }
+            return self.json_response(
+                response=msg,
+                status=403
+            )
+
+
+    async def is_allowed(self, request: web.Request) -> web.Response:
+        """is_allowed.
+
+            Check if user has access based on PDP Policies.
+        Args:
+            request (web.Request): Web Request.
+
+        Raises:
+            web.HTTPUnauthorized: Access is Denied.
+        """
+        guardian = self.get_guardian(request)
+        data = await self.data(request)
+        try:
+            actions = data['actions']
+        except KeyError:
+            self.error(
+                reason="IS_ALLOWED Method requires *actions* list on request",
+                status=401
+            )
+        args = {
+            "actions": actions,
+            "request": request
+        }
+        try:
+            args['resource'] = data['resource']
+        except KeyError:
+            pass
+        policy = await guardian.is_allowed(
+            **args
+        )
+        if policy.effect:
+            msg = {
+                "message": f"Action(s) {actions!s} Granted",
+                "response": policy.response,
+                "policy": policy.rule
+            }
+            return self.json_response(
+                response=msg,
+                status=202
+            )
+        else:
+            msg = {
+                "error": "Access Denied",
+                "response": policy.response,
+                "policy": policy.rule
+            }
+            return self.json_response(
+                response=msg,
+                status=403
+            )
```

## navigator_auth/abac/storages/pg.py

```diff
@@ -8,16 +8,18 @@
     Getting Policies from Postgres Database.
     """
     driver: str = 'pg'
     timeout: int = 10
 
     async def load_policies(self):
         policy_table = """
-        SELECT policy_id, name, resource, actions, method, effect, groups, context, environment, description, priority, org_id, client_id
+        SELECT policy_id, policy_type, name, resource, actions, method, effect, groups,
+        context, environment, description, objects, objects_attr, priority, org_id,
+        client_id
         FROM auth.policies;"""
         async with self.connection() as conn:
             result, error = await conn.query(policy_table)
             if error:
                 raise ConfigError(
-                    "ABAC: Error loading policies: {error}"
+                    f"ABAC: Error loading policies: {error}"
                 )
         return result
```

## Comparing `navigator_auth-0.6.9.dist-info/LICENSE` & `navigator_auth-0.7.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `navigator_auth-0.6.9.dist-info/RECORD` & `navigator_auth-0.7.0.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,74 +1,76 @@
-navigator_auth/models.py,sha256=QWOah6tYsikhCEp3c0zKRyAyl-FvKb70sRhU4f5ZgQ4,15408
-navigator_auth/exceptions.cpython-39-x86_64-linux-gnu.so,sha256=MUDYTxYydQs-Tb_MVnSzvzVD9IAb7i58BQLe0Oxemls,830832
-navigator_auth/__init__.py,sha256=uKLeEyWC6vEfebc6-3qh5xex2Ab2T4O6yOKWm2le1Zo,270
 navigator_auth/responses.py,sha256=X3lrclLdeeqF_LWLf9V98kHWP_Q_lqbA9EI2_P8wt98,2291
-navigator_auth/identities.py,sha256=rg1n-BaBjhq2SHI4JSrHlRBP2LNmluEoh6pqJ7Ckg9Q,3361
+navigator_auth/identities.py,sha256=DLJRxQTT4_Hfv3WDan6FDOKo6GPjRK2sjibHSppbjTE,3529
+navigator_auth/__init__.py,sha256=uKLeEyWC6vEfebc6-3qh5xex2Ab2T4O6yOKWm2le1Zo,270
+navigator_auth/exceptions.cpython-39-x86_64-linux-gnu.so,sha256=MUDYTxYydQs-Tb_MVnSzvzVD9IAb7i58BQLe0Oxemls,830832
 navigator_auth/decorators.py,sha256=F7iA7m2RJ6DoJGWFekYgiErUhUtW4Gtfg__Wbr_rhbo,10464
-navigator_auth/conf.py,sha256=55_lEIIZ-QfZtktgJeyZe4vFD1wduAGmXg8cC7AW3qg,9004
 navigator_auth/auth.py,sha256=cIAirYq8REggFfxd-p8ywCC6whstuQ_3sWt5VrQ5aF8,23134
-navigator_auth/version.py,sha256=TcQBYXhwO4aflTyKL7Q7r6mLzKvCXNbXeyYZqj2YFxg,600
-navigator_auth/backends/azure.py,sha256=TilcJ8P0eI4qRhLHsSUw2gr0BvuJsa9yffygQAFPLK8,14373
-navigator_auth/backends/oauth.py,sha256=6AIWJyqhFK7vaoijN4rfUufy5bxfDG5wUhik-CsUvHA,1635
-navigator_auth/backends/abstract.py,sha256=1S7nAg3MW-LrMZo6C2LtE6jDOTQayTo4M5lWS8sModg,15394
-navigator_auth/backends/external.py,sha256=nY_A-hIefss4MN6JFUHdMlHiK-nu6uu85GmQ_jNBNeo,15344
-navigator_auth/backends/jwksutils.py,sha256=hcWnI668JW2c0gFokUZ_8lyfgPAhWQy2GmLgd_KAHrE,4135
-navigator_auth/backends/basic.py,sha256=LytUBA0r5mSkID1v5E_-YJmFM1v_mno8MRTh1_OztbI,8284
-navigator_auth/backends/noauth.py,sha256=I0QLMKHxKLbiiqVelwDXtO1w3BLDmIUeLVHjXP-1kG0,2256
-navigator_auth/backends/__init__.py,sha256=9bnI82EMYPejSvUOgisobn0ApOxNxdaG7fw5RAnUY_A,562
-navigator_auth/backends/google.py,sha256=essdkoUj_9olTkGpiMimJWOVUgielzo_fslgB57fChU,5143
-navigator_auth/backends/api.py,sha256=laNzQqlGp8hdNCPJMpG34vvldwqvjqTK6VZ0VoYaNIg,7225
-navigator_auth/backends/token.py,sha256=ziwKoTzIkRBnzVUq3tcyDuJPJ4ziapmYt2HWbnwhkrc,9251
-navigator_auth/backends/okta.py,sha256=Brh0ckLOmpR3d3qW1e07N9okxG2lX76KmUufef7KIQw,5377
-navigator_auth/backends/github.py,sha256=gT6inw30VG4Pu9oIVjVsO1zQVMlmuljVEN2SVwMLJhA,3640
-navigator_auth/backends/django.py,sha256=7kq6_zkyFfqY2bT38j8AxHqykjEBRXHe72VcjAWGMAQ,11471
-navigator_auth/backends/troc.py,sha256=JX_sRiCXOhdo3DPQyvqZMmjtvjY3-djjvuMFMXoY50Q,9719
-navigator_auth/backends/adfs.py,sha256=ejn7HnisI2D2BYiOcpeiHEqcofBxtmXUIoI-RlKcRLo,9599
-navigator_auth/handlers/__init__.py,sha256=EmjY_JjxgmsyBYpc6Xo_Nq0kz4CoWuVTeM54XpLuQN0,4624
-navigator_auth/handlers/clients.py,sha256=MLgtITylUnYpGkbzRanvR6g4dk3uieAUkPXRlXMLpFc,314
-navigator_auth/handlers/users.py,sha256=WUyvuyEVsbZBNdcd9tTVmMthQGO69RXnF-LJsDpwUqM,26477
-navigator_auth/handlers/base.py,sha256=4nBUYzpAuPsMsTBPTcumHf0uZtdIvIldYSCSJea6aks,10869
-navigator_auth/handlers/permissions.py,sha256=xBdioQmInqomgbjqzOgmRxGM8jyvfZAfrhUa1TkGyJg,342
-navigator_auth/handlers/orgs.py,sha256=bRlV6NxJ8yTHU-9VNB2nrBZ_jw-dm2FExQTK0GfMDJw,838
-navigator_auth/handlers/program.py,sha256=WW_q9EEkpyX6V5IImueDHZ4Y-Tb1YcdGHwa47yAGhwg,978
-navigator_auth/handlers/userattrs.py,sha256=K-QUlzhpGxd9RxJkzUlAYAq3F1ubRyCU1w3YHnzvY18,5791
-navigator_auth/handlers/groups.py,sha256=4PeYTuoLmG5XooTAEmVYsyv-asgB_VsUSm040nNqVK4,708
-navigator_auth/handlers/model.py,sha256=9AXQPqycEKbroEk1gk4ALbGvHK_zaKNj07wdoYgK9A4,15819
+navigator_auth/version.py,sha256=GLqZtGXtXaN1QZ9m9gHRBi8mQbljnUmmv3SGrAWB1uk,600
+navigator_auth/models.py,sha256=Lh5TCbIGMyYW7xVpHtUCky4zjJuCe6tRO1utLFsAdI0,15539
+navigator_auth/conf.py,sha256=rKw-1-v9IxqADCykaNWgNyc_MzauWK9Y5SEMHPfnc8c,9333
+navigator_auth/libs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+navigator_auth/libs/cipher.cpython-39-x86_64-linux-gnu.so,sha256=gnnCZngzpO3D6Dm9F8AmvfWm1HxgR6KWwO3V87Z3uhk,503728
+navigator_auth/libs/json.cpython-39-x86_64-linux-gnu.so,sha256=5QWVbLYA2DK1aKjP_aOC2r0Mcn4cGxdBj4tAGn9YXC8,451736
+navigator_auth/authorizations/abstract.py,sha256=Qt1XwRo9AhCWg1B5brebduNEAAyU-ZywHDg2zIwaSkY,842
+navigator_auth/authorizations/hosts.py,sha256=PD0wNJIKcBb6h8OF15o3qfoRKnqIC83aAp1msHsk5uE,733
+navigator_auth/authorizations/__init__.py,sha256=DLgshAKGceH25yCYnCzIWiyv7iIuMGxxZurDBeSmMFw,170
+navigator_auth/authorizations/allow_hosts.py,sha256=95BSIGjAzWTbDaew2D0eOIRmyLnlEEz_cWDAVnCdgLo,674
 navigator_auth/storages/abstract.py,sha256=e9TaeW6rAh3XysWJFgU1zRsylZ6hFT2PXUCJBbEJTm8,2314
 navigator_auth/storages/__init__.py,sha256=nFeThELbvG6cA79DhMYw0KLf_qNoc0wXWLrs0xPVCPA,59
 navigator_auth/storages/postgres.py,sha256=RZX2ernisWcBfueKf-rqZJ289XqWyFp1fZPXruU9N2A,1288
 navigator_auth/storages/redis.py,sha256=ry2CDmSK2hiw5yKGWhJSFtSY1pzcAHjLIVtjPVXvy6c,776
-navigator_auth/libs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-navigator_auth/libs/cipher.cpython-39-x86_64-linux-gnu.so,sha256=gnnCZngzpO3D6Dm9F8AmvfWm1HxgR6KWwO3V87Z3uhk,503728
-navigator_auth/libs/json.cpython-39-x86_64-linux-gnu.so,sha256=5QWVbLYA2DK1aKjP_aOC2r0Mcn4cGxdBj4tAGn9YXC8,451736
-navigator_auth/abac/pdp.py,sha256=K0eE6O0IR2tsvoeo02v3ITjKJvcI1o_KmyGj8sPN71c,5711
-navigator_auth/abac/errors.py,sha256=73_2GlbF564GexsagFqQ_tE4nNWgmfXXVwgT_TghnKw,3126
-navigator_auth/abac/context.py,sha256=pQuuXh-V4n0V97kC2dK_eyIqYXtZvTsjukaVRcuDEjI,3118
-navigator_auth/abac/audit.py,sha256=mJ_N-_bbLvOtvOwCAHkqxgqftk6kwQzebkNx7Mm2eV0,2262
-navigator_auth/abac/policies.py,sha256=N0KD3qawI_ADwcEhGgxC_P2mMgC7G4YP_P8SWdX1wJo,5579
+navigator_auth/abac/pdp.py,sha256=HSKFl48eD55RPv0VSuztcPDCoF8kLaPKWmZH2hCvmYU,11772
+navigator_auth/abac/guardian.py,sha256=bkPQZeIunHLEleTc71TltQBYGE0nmj80dulJFXF_4MQ,8379
+navigator_auth/abac/context.py,sha256=_MISyKssF2MqjbopmFlTRKUsqhrrUJZsJOdVkvpxHEI,2984
 navigator_auth/abac/__init__.py,sha256=LKvXfhzC0agppQZUvPOrReEXPIQZYXQcIng2mlgudTU,113
+navigator_auth/abac/errors.py,sha256=73_2GlbF564GexsagFqQ_tE4nNWgmfXXVwgT_TghnKw,3126
+navigator_auth/abac/middleware.py,sha256=6pke7m-V4viO1zqXTR8l-puHv04eDGikuKyik06x0BU,1645
 navigator_auth/abac/decorators.py,sha256=nzOIn4b-OkINDBxY6c_41z6ZbHazevL1ZmzorA3S1zA,2403
-navigator_auth/abac/middleware.py,sha256=qU3ZqDBk9nSSWPZV6ynWii18rIGk-nWszANZ9P9b400,1493
-navigator_auth/abac/guardian.py,sha256=rnhUtEl1XWuhE9FLjHrn5wHsmaNfTUDFp7GOKYiwc_o,3206
+navigator_auth/abac/audit.py,sha256=mJ_N-_bbLvOtvOwCAHkqxgqftk6kwQzebkNx7Mm2eV0,2262
+navigator_auth/abac/policies/policy.py,sha256=OG6k1NYbHPNKqHtBv9IKVR9tWnpW0PiJ_3al4yHc-BM,5999
+navigator_auth/abac/policies/environment.py,sha256=Zujn5WD56m6SZd_n5eEiPgEdQvj4BvXfjw7SWJcSN3Q,595
+navigator_auth/abac/policies/abstract.py,sha256=OH48seb92BnOtLBEUK0d5L7WhM7W3WNfbB9jZb28DX4,6251
+navigator_auth/abac/policies/__init__.py,sha256=FrYrjOX4s5mCx-rVVH6FY6NiCXyEqehJEwY_B8CIum4,340
+navigator_auth/abac/policies/obj.py,sha256=svs0R8OA61bV3Qs4m4pTE4z4O39MgjwhwAEkaR4BB64,9127
+navigator_auth/abac/policies/file.py,sha256=BJCnoq_INiV2Nm5yM9kDlyTiPOXpPEocjgx5cWBXb-w,4287
 navigator_auth/abac/storages/db.py,sha256=1YjLFJkmhlbICGt7EC3ECXKdE8Q1MzTjDJnrN6RY8ho,2604
 navigator_auth/abac/storages/abstract.py,sha256=yzmhg3kBFrBxm4kKDmHNfznCjdOz6lkW0zr9XnMynz0,487
-navigator_auth/abac/storages/pg.py,sha256=tbdfn8bXOeFl5CWvXhZ-yFb81rNyEjGHAi3v5EPWsRw,717
 navigator_auth/abac/storages/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-navigator_auth/authorizations/abstract.py,sha256=Qt1XwRo9AhCWg1B5brebduNEAAyU-ZywHDg2zIwaSkY,842
-navigator_auth/authorizations/__init__.py,sha256=DLgshAKGceH25yCYnCzIWiyv7iIuMGxxZurDBeSmMFw,170
-navigator_auth/authorizations/allow_hosts.py,sha256=95BSIGjAzWTbDaew2D0eOIRmyLnlEEz_cWDAVnCdgLo,674
-navigator_auth/authorizations/hosts.py,sha256=PD0wNJIKcBb6h8OF15o3qfoRKnqIC83aAp1msHsk5uE,733
+navigator_auth/abac/storages/pg.py,sha256=oM-_kwvshSypq14jMNqtCIeTZke1osaOJ7f2UUDQBAw,770
+navigator_auth/backends/adfs.py,sha256=ejn7HnisI2D2BYiOcpeiHEqcofBxtmXUIoI-RlKcRLo,9599
+navigator_auth/backends/okta.py,sha256=Brh0ckLOmpR3d3qW1e07N9okxG2lX76KmUufef7KIQw,5377
+navigator_auth/backends/api.py,sha256=laNzQqlGp8hdNCPJMpG34vvldwqvjqTK6VZ0VoYaNIg,7225
+navigator_auth/backends/github.py,sha256=gT6inw30VG4Pu9oIVjVsO1zQVMlmuljVEN2SVwMLJhA,3640
+navigator_auth/backends/django.py,sha256=7kq6_zkyFfqY2bT38j8AxHqykjEBRXHe72VcjAWGMAQ,11471
+navigator_auth/backends/abstract.py,sha256=1S7nAg3MW-LrMZo6C2LtE6jDOTQayTo4M5lWS8sModg,15394
+navigator_auth/backends/jwksutils.py,sha256=hcWnI668JW2c0gFokUZ_8lyfgPAhWQy2GmLgd_KAHrE,4135
+navigator_auth/backends/token.py,sha256=ziwKoTzIkRBnzVUq3tcyDuJPJ4ziapmYt2HWbnwhkrc,9251
+navigator_auth/backends/__init__.py,sha256=9bnI82EMYPejSvUOgisobn0ApOxNxdaG7fw5RAnUY_A,562
+navigator_auth/backends/azure.py,sha256=TilcJ8P0eI4qRhLHsSUw2gr0BvuJsa9yffygQAFPLK8,14373
+navigator_auth/backends/noauth.py,sha256=I0QLMKHxKLbiiqVelwDXtO1w3BLDmIUeLVHjXP-1kG0,2256
+navigator_auth/backends/troc.py,sha256=JX_sRiCXOhdo3DPQyvqZMmjtvjY3-djjvuMFMXoY50Q,9719
+navigator_auth/backends/basic.py,sha256=LytUBA0r5mSkID1v5E_-YJmFM1v_mno8MRTh1_OztbI,8284
+navigator_auth/backends/external.py,sha256=nY_A-hIefss4MN6JFUHdMlHiK-nu6uu85GmQ_jNBNeo,15344
+navigator_auth/backends/oauth.py,sha256=6AIWJyqhFK7vaoijN4rfUufy5bxfDG5wUhik-CsUvHA,1635
+navigator_auth/backends/google.py,sha256=essdkoUj_9olTkGpiMimJWOVUgielzo_fslgB57fChU,5143
+navigator_auth/middlewares/jwt.py,sha256=FWnFdpny3j7kYPMw-A5oMq58sZPxUogLvEc-Tkc7iVM,4520
+navigator_auth/middlewares/apikey.py,sha256=tBW8Azx_kaOOzlXjXrmCUoIcNC5GrywaJtcmD3fGTIU,3707
+navigator_auth/middlewares/django.py,sha256=iqjCgaoyAaQzV7X5rY3wM-HQwQZ9eg0lDti4of8vvVg,3192
 navigator_auth/middlewares/abstract.py,sha256=BQJi-bJsRufrthjGyv4pN1A8MDXawydaltKB9Jw-gRM,3442
-navigator_auth/middlewares/__init__.py,sha256=IWLjJNNoKNfvJaFa6XGqhYdvMmUV14SjUQtcCRzAL88,384
 navigator_auth/middlewares/token.py,sha256=PZJ7m4cg_ds1lliagl_miIEnH_FblYZROXxKauPaFAo,2912
-navigator_auth/middlewares/django.py,sha256=iqjCgaoyAaQzV7X5rY3wM-HQwQZ9eg0lDti4of8vvVg,3192
+navigator_auth/middlewares/__init__.py,sha256=IWLjJNNoKNfvJaFa6XGqhYdvMmUV14SjUQtcCRzAL88,384
 navigator_auth/middlewares/troc.py,sha256=bBOhZ1rXiHk74RMFG8FO_GFJmyCBdul_3NE995WutOs,2838
-navigator_auth/middlewares/apikey.py,sha256=tBW8Azx_kaOOzlXjXrmCUoIcNC5GrywaJtcmD3fGTIU,3707
-navigator_auth/middlewares/jwt.py,sha256=FWnFdpny3j7kYPMw-A5oMq58sZPxUogLvEc-Tkc7iVM,4520
-examples/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-examples/test_handler.py,sha256=8E9Wj2ozn4OzTgaovlC8HHIF3t4Q_NyXzhy2VEY1gbQ,2362
-examples/test_abac.py,sha256=CIwoYQ_uH3BzUB7lkI-mlgTXrixXnJowJLBIlZkKHd0,5060
-navigator_auth-0.6.9.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-navigator_auth-0.6.9.dist-info/WHEEL,sha256=D79CBkaJekx7HMK1NaBe_KU1GVla4HlolbFXT3at6fg,148
-navigator_auth-0.6.9.dist-info/top_level.txt,sha256=G6cXu0xd0iegkX9N9Oc_HBs19YaCpDprvPmXCdrW02A,24
-navigator_auth-0.6.9.dist-info/RECORD,,
-navigator_auth-0.6.9.dist-info/METADATA,sha256=GtE95T3KWUPox8STt52Leu8z1z5ouWtTtq-02QYdTlQ,3145
+navigator_auth/handlers/userattrs.py,sha256=ZwOzlMt2y7x1v7Z43rleEFt6YnchQlM8hJC-TNTPvnM,8174
+navigator_auth/handlers/groups.py,sha256=4PeYTuoLmG5XooTAEmVYsyv-asgB_VsUSm040nNqVK4,708
+navigator_auth/handlers/__init__.py,sha256=fL2t0iXw555ByhV95dxtW9Rr4KT6Mrq4D6lCIuEFEEA,4914
+navigator_auth/handlers/model.py,sha256=EkAoetyHUVLdZn9uO6XfOe5Q4iA4LYWJIDA-heqM4AE,19074
+navigator_auth/handlers/orgs.py,sha256=bRlV6NxJ8yTHU-9VNB2nrBZ_jw-dm2FExQTK0GfMDJw,838
+navigator_auth/handlers/clients.py,sha256=MLgtITylUnYpGkbzRanvR6g4dk3uieAUkPXRlXMLpFc,314
+navigator_auth/handlers/base.py,sha256=zR5hPpVjs6UfozPfCQg5BjeS8aFenM2soAW63ewZM0I,10993
+navigator_auth/handlers/permissions.py,sha256=xBdioQmInqomgbjqzOgmRxGM8jyvfZAfrhUa1TkGyJg,342
+navigator_auth/handlers/users.py,sha256=WUyvuyEVsbZBNdcd9tTVmMthQGO69RXnF-LJsDpwUqM,26477
+navigator_auth/handlers/program.py,sha256=agCxFTFI1dvKBxm5u7KDxDBYu1msGc4TVbTN36l5WkM,1170
+navigator_auth-0.7.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+navigator_auth-0.7.0.dist-info/WHEEL,sha256=gREe7-l-MJWbGZG46A7WHnwwUSxA3XJYHQvGGLzmBNU,148
+navigator_auth-0.7.0.dist-info/top_level.txt,sha256=8D2uk_d6Igj2B2ahU5xZ8lAb1vTvazTjxzRQTc0vJw4,15
+navigator_auth-0.7.0.dist-info/RECORD,,
+navigator_auth-0.7.0.dist-info/METADATA,sha256=d5iDeQKc_WOzCjdVq7OSuTMLPxM1XZdokmtF6Q0hyyg,3198
```

## Comparing `navigator_auth-0.6.9.dist-info/METADATA` & `navigator_auth-0.7.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: navigator-auth
-Version: 0.6.9
+Version: 0.7.0
 Summary: Navigator Auth is an Authentication/Authorization Toolkit for aiohttp.
 Home-page: https://github.com/phenobarbital/navigator-auth
 Author: Jesus Lara
 Author-email: jesuslarag@gmail.com
 License: Apache 2.0 license
 Project-URL: Source, https://github.com/phenobarbital/navigator-auth
 Project-URL: Funding, https://paypal.me/phenobarbital
@@ -16,20 +16,21 @@
 Classifier: Operating System :: POSIX :: Linux
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Environment :: Web Environment
 Classifier: Topic :: Software Development :: Build Tools
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Topic :: System :: Systems Administration
 Classifier: Topic :: System :: Networking
-Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 Classifier: Framework :: AsyncIO
 Classifier: Framework :: aiohttp
-Requires-Python: >=3.8.0
+Requires-Python: >=3.9.14
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: PyNaCl (==1.5.0)
 Requires-Dist: aiohttp (==3.8.4)
 Requires-Dist: uvloop (==0.17.0)
 Requires-Dist: asyncio (==3.4.3)
 Requires-Dist: asyncdb (>=2.2.0)
```

