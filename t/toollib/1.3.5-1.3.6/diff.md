# Comparing `tmp/toollib-1.3.5-py3-none-any.whl.zip` & `tmp/toollib-1.3.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,84 +1,84 @@
-Zip file size: 505069 bytes, number of entries: 82
--rw-rw-rw-  2.0 fat      239 b- defN 22-Nov-04 14:21 toollib/__debug__.py
--rw-rw-rw-  2.0 fat      223 b- defN 23-Apr-24 07:33 toollib/__init__.py
--rw-rw-rw-  2.0 fat     5333 b- defN 22-Nov-04 14:21 toollib/autodriver.py
--rw-rw-rw-  2.0 fat     5568 b- defN 22-Nov-04 14:21 toollib/crypto.py
--rw-rw-rw-  2.0 fat     3140 b- defN 23-Apr-24 07:32 toollib/decorator.py
--rw-rw-rw-  2.0 fat     7768 b- defN 22-Dec-04 15:23 toollib/guid.py
--rw-rw-rw-  2.0 fat     6762 b- defN 22-Nov-04 14:21 toollib/kvalue.py
--rw-rw-rw-  2.0 fat     3471 b- defN 22-Nov-26 14:21 toollib/locker.py
--rw-rw-rw-  2.0 fat     5112 b- defN 23-Apr-24 07:32 toollib/py2pyder.py
--rw-rw-rw-  2.0 fat     2040 b- defN 23-Apr-10 03:19 toollib/redis_cli.py
--rw-rw-rw-  2.0 fat     1592 b- defN 22-Nov-04 14:21 toollib/regexp.py
--rw-rw-rw-  2.0 fat   127411 b- defN 22-Nov-04 14:21 toollib/useragent.py
--rw-rw-rw-  2.0 fat    10691 b- defN 23-Apr-24 07:32 toollib/utils.py
--rw-rw-rw-  2.0 fat     3635 b- defN 23-Apr-23 02:49 toollib/validator.py
--rw-rw-rw-  2.0 fat     7534 b- defN 22-Nov-04 14:21 toollib/xlsx.py
+Zip file size: 504310 bytes, number of entries: 82
+-rw-rw-rw-  2.0 fat      222 b- defN 23-Apr-24 08:48 toollib/__debug__.py
+-rw-rw-rw-  2.0 fat      223 b- defN 23-Apr-24 09:02 toollib/__init__.py
+-rw-rw-rw-  2.0 fat     5194 b- defN 23-Apr-24 08:48 toollib/autodriver.py
+-rw-rw-rw-  2.0 fat     5393 b- defN 23-Apr-24 08:48 toollib/crypto.py
+-rw-rw-rw-  2.0 fat     3017 b- defN 23-Apr-24 08:48 toollib/decorator.py
+-rw-rw-rw-  2.0 fat     7560 b- defN 23-Apr-24 08:48 toollib/guid.py
+-rw-rw-rw-  2.0 fat     6558 b- defN 23-Apr-24 08:48 toollib/kvalue.py
+-rw-rw-rw-  2.0 fat     3355 b- defN 23-Apr-24 08:48 toollib/locker.py
+-rw-rw-rw-  2.0 fat     4976 b- defN 23-Apr-24 08:48 toollib/py2pyder.py
+-rw-rw-rw-  2.0 fat     1960 b- defN 23-Apr-24 08:48 toollib/redis_cli.py
+-rw-rw-rw-  2.0 fat     1545 b- defN 23-Apr-24 08:48 toollib/regexp.py
+-rw-rw-rw-  2.0 fat   126354 b- defN 23-Apr-24 08:48 toollib/useragent.py
+-rw-rw-rw-  2.0 fat    10327 b- defN 23-Apr-24 08:48 toollib/utils.py
+-rw-rw-rw-  2.0 fat     3522 b- defN 23-Apr-24 08:48 toollib/validator.py
+-rw-rw-rw-  2.0 fat     7320 b- defN 23-Apr-24 08:48 toollib/xlsx.py
 -rw-rw-rw-  2.0 fat      379 b- defN 23-Apr-20 06:34 toollib/__pycache__/__init__.cpython-37.pyc
--rw-rw-rw-  2.0 fat      383 b- defN 23-Apr-24 07:32 toollib/__pycache__/__init__.cpython-38.pyc
+-rw-rw-rw-  2.0 fat      383 b- defN 23-Apr-24 08:58 toollib/__pycache__/__init__.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     4695 b- defN 22-Nov-25 09:25 toollib/__pycache__/autodriver.cpython-37.pyc
--rw-rw-rw-  2.0 fat     4669 b- defN 23-Apr-07 13:24 toollib/__pycache__/autodriver.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     4669 b- defN 23-Apr-24 08:58 toollib/__pycache__/autodriver.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     4952 b- defN 22-Nov-25 09:25 toollib/__pycache__/crypto.cpython-37.pyc
--rw-rw-rw-  2.0 fat     4953 b- defN 23-Apr-07 13:24 toollib/__pycache__/crypto.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     4953 b- defN 23-Apr-24 08:58 toollib/__pycache__/crypto.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     3373 b- defN 22-Nov-25 09:25 toollib/__pycache__/decorator.cpython-37.pyc
--rw-rw-rw-  2.0 fat     3578 b- defN 23-Apr-23 06:41 toollib/__pycache__/decorator.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     3578 b- defN 23-Apr-24 08:58 toollib/__pycache__/decorator.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     6572 b- defN 23-Mar-29 04:25 toollib/__pycache__/guid.cpython-37.pyc
--rw-rw-rw-  2.0 fat     6676 b- defN 23-Apr-07 13:24 toollib/__pycache__/guid.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     6676 b- defN 23-Apr-24 08:58 toollib/__pycache__/guid.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     6615 b- defN 22-Nov-25 09:25 toollib/__pycache__/kvalue.cpython-37.pyc
--rw-rw-rw-  2.0 fat     6635 b- defN 23-Apr-07 13:24 toollib/__pycache__/kvalue.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     6635 b- defN 23-Apr-24 08:58 toollib/__pycache__/kvalue.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     3163 b- defN 22-Dec-03 14:44 toollib/__pycache__/locker.cpython-37.pyc
--rw-rw-rw-  2.0 fat     3193 b- defN 23-Apr-07 13:24 toollib/__pycache__/locker.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     3193 b- defN 23-Apr-24 08:58 toollib/__pycache__/locker.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     2620 b- defN 23-Apr-07 13:16 toollib/__pycache__/py2pyder.cpython-37.pyc
--rw-rw-rw-  2.0 fat     4687 b- defN 23-Apr-23 06:41 toollib/__pycache__/py2pyder.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     4687 b- defN 23-Apr-24 08:58 toollib/__pycache__/py2pyder.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     2404 b- defN 22-Dec-03 14:44 toollib/__pycache__/redis_cli.cpython-37.pyc
--rw-rw-rw-  2.0 fat     2433 b- defN 23-Apr-10 10:03 toollib/__pycache__/redis_cli.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     2433 b- defN 23-Apr-24 08:58 toollib/__pycache__/redis_cli.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     1487 b- defN 22-Nov-25 09:25 toollib/__pycache__/regexp.cpython-37.pyc
--rw-rw-rw-  2.0 fat     1491 b- defN 23-Apr-07 13:24 toollib/__pycache__/regexp.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     1491 b- defN 23-Apr-24 08:58 toollib/__pycache__/regexp.cpython-38.pyc
 -rw-rw-rw-  2.0 fat   126034 b- defN 22-Nov-25 09:25 toollib/__pycache__/useragent.cpython-37.pyc
--rw-rw-rw-  2.0 fat   125990 b- defN 23-Apr-07 13:24 toollib/__pycache__/useragent.cpython-38.pyc
+-rw-rw-rw-  2.0 fat   125990 b- defN 23-Apr-24 08:58 toollib/__pycache__/useragent.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     9234 b- defN 23-Apr-20 06:34 toollib/__pycache__/utils.cpython-37.pyc
--rw-rw-rw-  2.0 fat     9986 b- defN 23-Apr-23 09:30 toollib/__pycache__/utils.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     9986 b- defN 23-Apr-24 08:58 toollib/__pycache__/utils.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     3526 b- defN 22-Nov-25 09:25 toollib/__pycache__/validator.cpython-37.pyc
--rw-rw-rw-  2.0 fat     3154 b- defN 23-Apr-23 02:50 toollib/__pycache__/validator.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     3154 b- defN 23-Apr-24 08:58 toollib/__pycache__/validator.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     6010 b- defN 22-Nov-25 09:25 toollib/__pycache__/xlsx.cpython-37.pyc
--rw-rw-rw-  2.0 fat     6003 b- defN 23-Apr-07 13:24 toollib/__pycache__/xlsx.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     6003 b- defN 23-Apr-24 08:58 toollib/__pycache__/xlsx.cpython-38.pyc
 -rw-rw-rw-  2.0 fat   369880 b- defN 22-Nov-04 14:21 toollib/common/UnRAR.exe
--rw-rw-rw-  2.0 fat      104 b- defN 22-Nov-04 14:21 toollib/common/__init__.py
--rw-rw-rw-  2.0 fat     1217 b- defN 23-Apr-20 09:52 toollib/common/constor.py
--rw-rw-rw-  2.0 fat      492 b- defN 22-Nov-04 14:21 toollib/common/error.py
--rw-rw-rw-  2.0 fat   103206 b- defN 22-Nov-04 14:21 toollib/common/rarfile.py
--rw-rw-rw-  2.0 fat    83375 b- defN 22-Nov-04 14:21 toollib/common/zipfile.py
+-rw-rw-rw-  2.0 fat       96 b- defN 23-Apr-24 08:48 toollib/common/__init__.py
+-rw-rw-rw-  2.0 fat     1198 b- defN 23-Apr-24 08:48 toollib/common/constor.py
+-rw-rw-rw-  2.0 fat      464 b- defN 23-Apr-24 08:48 toollib/common/error.py
+-rw-rw-rw-  2.0 fat    99841 b- defN 23-Apr-24 08:48 toollib/common/rarfile.py
+-rw-rw-rw-  2.0 fat    81196 b- defN 23-Apr-24 08:48 toollib/common/zipfile.py
 -rw-rw-rw-  2.0 fat      244 b- defN 22-Nov-25 09:25 toollib/common/__pycache__/__init__.cpython-37.pyc
--rw-rw-rw-  2.0 fat      248 b- defN 23-Apr-07 13:24 toollib/common/__pycache__/__init__.cpython-38.pyc
+-rw-rw-rw-  2.0 fat      248 b- defN 23-Apr-24 08:58 toollib/common/__pycache__/__init__.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     1305 b- defN 23-Apr-20 06:34 toollib/common/__pycache__/constor.cpython-37.pyc
--rw-rw-rw-  2.0 fat     1313 b- defN 23-Apr-22 12:18 toollib/common/__pycache__/constor.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     1313 b- defN 23-Apr-24 08:58 toollib/common/__pycache__/constor.cpython-38.pyc
 -rw-rw-rw-  2.0 fat     1086 b- defN 22-Nov-25 09:25 toollib/common/__pycache__/error.cpython-37.pyc
--rw-rw-rw-  2.0 fat     1093 b- defN 23-Apr-07 13:24 toollib/common/__pycache__/error.cpython-38.pyc
+-rw-rw-rw-  2.0 fat     1093 b- defN 23-Apr-24 08:58 toollib/common/__pycache__/error.cpython-38.pyc
 -rw-rw-rw-  2.0 fat    84047 b- defN 22-Nov-25 09:25 toollib/common/__pycache__/rarfile.cpython-37.pyc
--rw-rw-rw-  2.0 fat    84059 b- defN 23-Apr-07 13:24 toollib/common/__pycache__/rarfile.cpython-38.pyc
+-rw-rw-rw-  2.0 fat    84059 b- defN 23-Apr-24 08:58 toollib/common/__pycache__/rarfile.cpython-38.pyc
 -rw-rw-rw-  2.0 fat    50340 b- defN 22-Nov-25 09:25 toollib/common/__pycache__/zipfile.cpython-37.pyc
--rw-rw-rw-  2.0 fat    50637 b- defN 23-Apr-07 13:24 toollib/common/__pycache__/zipfile.cpython-38.pyc
--rw-rw-rw-  2.0 fat      173 b- defN 22-Nov-04 14:21 toollib/tcli/__init__.py
--rw-rw-rw-  2.0 fat      212 b- defN 22-Nov-04 14:21 toollib/tcli/__main__.py
--rw-rw-rw-  2.0 fat     2836 b- defN 23-Apr-24 07:32 toollib/tcli/base.py
--rw-rw-rw-  2.0 fat     1543 b- defN 23-Apr-24 07:32 toollib/tcli/cmder.py
--rw-rw-rw-  2.0 fat     1640 b- defN 23-Apr-20 09:52 toollib/tcli/helper.py
--rw-rw-rw-  2.0 fat     2326 b- defN 22-Nov-04 14:21 toollib/tcli/option.py
--rw-rw-rw-  2.0 fat      104 b- defN 22-Nov-04 14:21 toollib/tcli/commands/__init__.py
--rw-rw-rw-  2.0 fat     4761 b- defN 23-Apr-24 07:32 toollib/tcli/commands/_docker.py
--rw-rw-rw-  2.0 fat     1483 b- defN 23-Apr-24 07:32 toollib/tcli/commands/_py2pyd.py
--rw-rw-rw-  2.0 fat      867 b- defN 23-Apr-20 09:52 toollib/tcli/commands/_set_conda.py
--rw-rw-rw-  2.0 fat      932 b- defN 23-Apr-24 07:32 toollib/tcli/commands/_set_mirrors.py
--rw-rw-rw-  2.0 fat     1095 b- defN 23-Apr-20 09:52 toollib/tcli/commands/_set_pip.py
--rw-rw-rw-  2.0 fat     1313 b- defN 23-Apr-24 07:32 toollib/tcli/commands/_set_sshkey.py
--rw-rw-rw-  2.0 fat      102 b- defN 22-Nov-04 14:21 toollib/tcli/commands/plugins/__init__.py
--rw-rw-rw-  2.0 fat     2176 b- defN 23-Apr-23 06:03 toollib/tcli/commands/plugins/docker-compose.yml
--rw-rw-rw-  2.0 fat     4802 b- defN 23-Apr-23 04:51 toollib/tcli/commands/plugins/set_mirrors.sh
--rw-rw-rw-  2.0 fat     2583 b- defN 23-Apr-24 07:32 toollib/tcli/commands/plugins/set_sshkey.sh
--rw-rw-rw-  2.0 fat     1074 b- defN 23-Apr-24 07:33 toollib-1.3.5.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1996 b- defN 23-Apr-24 07:33 toollib-1.3.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-24 07:33 toollib-1.3.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       54 b- defN 23-Apr-24 07:33 toollib-1.3.5.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        8 b- defN 23-Apr-24 07:33 toollib-1.3.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     7448 b- defN 23-Apr-24 07:33 toollib-1.3.5.dist-info/RECORD
-82 files, 1427680 bytes uncompressed, 493149 bytes compressed:  65.5%
+-rw-rw-rw-  2.0 fat    50637 b- defN 23-Apr-24 08:58 toollib/common/__pycache__/zipfile.cpython-38.pyc
+-rw-rw-rw-  2.0 fat      162 b- defN 23-Apr-24 08:48 toollib/tcli/__init__.py
+-rw-rw-rw-  2.0 fat      195 b- defN 23-Apr-24 08:48 toollib/tcli/__main__.py
+-rw-rw-rw-  2.0 fat     2745 b- defN 23-Apr-24 08:48 toollib/tcli/base.py
+-rw-rw-rw-  2.0 fat     1487 b- defN 23-Apr-24 08:48 toollib/tcli/cmder.py
+-rw-rw-rw-  2.0 fat     1570 b- defN 23-Apr-24 08:48 toollib/tcli/helper.py
+-rw-rw-rw-  2.0 fat     2249 b- defN 23-Apr-24 08:48 toollib/tcli/option.py
+-rw-rw-rw-  2.0 fat       96 b- defN 23-Apr-24 08:48 toollib/tcli/commands/__init__.py
+-rw-rw-rw-  2.0 fat     4638 b- defN 23-Apr-24 08:48 toollib/tcli/commands/_docker.py
+-rw-rw-rw-  2.0 fat     1438 b- defN 23-Apr-24 08:48 toollib/tcli/commands/_py2pyd.py
+-rw-rw-rw-  2.0 fat      830 b- defN 23-Apr-24 08:48 toollib/tcli/commands/_set_conda.py
+-rw-rw-rw-  2.0 fat      894 b- defN 23-Apr-24 08:48 toollib/tcli/commands/_set_mirrors.py
+-rw-rw-rw-  2.0 fat     1053 b- defN 23-Apr-24 08:48 toollib/tcli/commands/_set_pip.py
+-rw-rw-rw-  2.0 fat     1267 b- defN 23-Apr-24 08:48 toollib/tcli/commands/_set_sshkey.py
+-rw-rw-rw-  2.0 fat       94 b- defN 23-Apr-24 08:48 toollib/tcli/commands/plugins/__init__.py
+-rw-rw-rw-  2.0 fat     2176 b- defN 23-Apr-24 08:48 toollib/tcli/commands/plugins/docker-compose.yml
+-rw-rw-rw-  2.0 fat     4802 b- defN 23-Apr-24 08:48 toollib/tcli/commands/plugins/set_mirrors.sh
+-rw-rw-rw-  2.0 fat     2481 b- defN 23-Apr-24 08:48 toollib/tcli/commands/plugins/set_sshkey.sh
+-rw-rw-rw-  2.0 fat     1055 b- defN 23-Apr-24 09:02 toollib-1.3.6.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1996 b- defN 23-Apr-24 09:02 toollib-1.3.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-24 09:02 toollib-1.3.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       54 b- defN 23-Apr-24 09:02 toollib-1.3.6.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        8 b- defN 23-Apr-24 09:02 toollib-1.3.6.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     7444 b- defN 23-Apr-24 09:02 toollib-1.3.6.dist-info/RECORD
+82 files, 1418294 bytes uncompressed, 492390 bytes compressed:  65.3%
```

## zipnote {}

```diff
@@ -222,26 +222,26 @@
 
 Filename: toollib/tcli/commands/plugins/set_mirrors.sh
 Comment: 
 
 Filename: toollib/tcli/commands/plugins/set_sshkey.sh
 Comment: 
 
-Filename: toollib-1.3.5.dist-info/LICENSE
+Filename: toollib-1.3.6.dist-info/LICENSE
 Comment: 
 
-Filename: toollib-1.3.5.dist-info/METADATA
+Filename: toollib-1.3.6.dist-info/METADATA
 Comment: 
 
-Filename: toollib-1.3.5.dist-info/WHEEL
+Filename: toollib-1.3.6.dist-info/WHEEL
 Comment: 
 
-Filename: toollib-1.3.5.dist-info/entry_points.txt
+Filename: toollib-1.3.6.dist-info/entry_points.txt
 Comment: 
 
-Filename: toollib-1.3.5.dist-info/top_level.txt
+Filename: toollib-1.3.6.dist-info/top_level.txt
 Comment: 
 
-Filename: toollib-1.3.5.dist-info/RECORD
+Filename: toollib-1.3.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## toollib/__debug__.py

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2021/12/14 20:20
-@abstract
-@description
-@history
-"""
-import unittest
-
-from toollib import here
-
-
-class TestDebug(unittest.TestCase):
-
-    def test_001(self):
-        print(here)
+"""
+@author axiner
+@version v1.0.0
+@created 2021/12/14 20:20
+@abstract
+@description
+@history
+"""
+import unittest
+
+from toollib import here
+
+
+class TestDebug(unittest.TestCase):
+
+    def test_001(self):
+        print(here)
```

## toollib/__init__.py

```diff
@@ -6,8 +6,8 @@
 @description
 @history
 """
 from pathlib import Path
 
 here = Path(__file__).absolute().parent
 
-__version__ = "1.3.5"
+__version__ = "1.3.6"
```

## toollib/autodriver.py

 * *Ordering differences only*

```diff
@@ -1,139 +1,139 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/1/18 21:05
-@abstract web驱动
-@description
-@history
-"""
-import os
-import re
-import shutil
-import typing as t
-import urllib.request as urlrequest
-from pathlib import Path
-
-from toollib.validator import choicer
-
-
-__all__ = ['chromedriver']
-
-
-def chromedriver(driver_dir: t.Union[str, Path] = '.', version: str = 'LATEST_RELEASE', platform: str = 'win64') -> str:
-    """
-    自动下载谷歌驱动（注：若指定目录存在与浏览器版本一致的驱动则会跳过）
-    使用示例：
-        # 不指定浏览器版本，则下载当前浏览器对应的版本（针对win平台，mac|linux则下载最新版本（可查看浏览器版本自行指定））
-        import time
-        from selenium import webdriver
-        from selenium.webdriver.chrome.service import Service
-        from toollib import autodriver
-
-        driver_path = autodriver.chromedriver()  # 自动下载驱动
-        driver = webdriver.Chrome(service=Service(driver_path))
-        driver.get('https://www.baidu.com')
-        driver.find_element(value='kw').send_keys('python toollib')
-        driver.find_element(value='su').click()
-        time.sleep(29)
-        driver.close()
-        +++++[更多详见参数或源码]+++++
-    :param driver_dir: 驱动目录（默认当前执行目录）
-    :param version: 版本（谷歌浏览器）
-    :param platform: 平台（默认：win64）-支持：['win32', 'win64', 'mac64', 'linux64']
-    """
-    driver_path = ChromeDriver.download(driver_dir, version, platform)
-    return driver_path
-
-
-class ChromeDriver:
-    """
-    谷歌驱动
-    """
-
-    @classmethod
-    def download(cls, driver_dir: str, version: str, platform: str) -> str:
-        driver_dir = Path(driver_dir).absolute()
-        if driver_dir.is_file():
-            raise TypeError('"driver_dir" is dir')
-        else:
-            driver_dir.mkdir(parents=True, exist_ok=True)
-        platform = choicer(
-            platform,
-            choices=['win32', 'win64', 'mac64', 'linux64'],
-            lable='platform')
-        if platform.startswith('win'):
-            platform = 'win32'
-            version = cls.__get_version(version)
-            exec_file = 'chromedriver.exe'
-        else:
-            exec_file = 'chromedriver'
-        driver_file = driver_dir.joinpath(exec_file)
-        if driver_file.is_file():
-            if cls.__check_driver_version(driver_file, version, platform):
-                return driver_file.as_posix()
-        __version = cls.__find_similar_version(version)
-        if not __version:
-            raise ValueError('This version may not exist')
-        __driver_zip = driver_dir.joinpath(f'chromedriver_{platform}.zip')
-        __download_url = f'https://chromedriver.storage.googleapis.com/' \
-                         f'{__version}/{__driver_zip.name}'
-        try:
-            print(f'Download driver({__driver_zip.stem}) start.....')
-            urlrequest.urlretrieve(__download_url, __driver_zip.as_posix())
-            shutil.unpack_archive(__driver_zip, driver_dir, 'zip')
-            os.remove(__driver_zip)
-            return driver_file.as_posix()
-        except:
-            raise
-
-    @staticmethod
-    def __get_version(version: str) -> str:
-        if version == 'LATEST_RELEASE' or not version:
-            try:
-                import winreg
-                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Google\Chrome\BLBeacon')
-                value, _type = winreg.QueryValueEx(key, 'version')
-                version = value or 'LATEST_RELEASE'
-            except Exception as err:
-                print(str(err))
-                print('将版本赋值为最新版本"LATEST_RELEASE"')
-                version = 'LATEST_RELEASE'
-        version = '.'.join(version.split('.')[:3])
-        return version
-
-    @staticmethod
-    def __check_driver_version(driver_file: str, version: str, platform: str) -> bool:
-        is_eq = True
-        try:
-            if platform.startswith('win'):
-                outstd = os.popen(f'"{driver_file}" --version').read()
-                cv_split = outstd.split()[1].split('.')[:3]
-                v_split = version.split('.')
-                if cv_split != v_split:
-                    if len(v_split) > 1:
-                        is_eq = '.'.join(cv_split).startswith('.'.join(v_split))
-                    else:
-                        is_eq = (v_split == cv_split[:1])
-        except:
-            is_eq = False
-        return is_eq
-
-    @staticmethod
-    def __find_similar_version(version: str) -> str:
-        url = 'https://chromedriver.storage.googleapis.com/'
-        if version == 'LATEST_RELEASE':
-            url += version
-        sml_version = None
-        try:
-            version_resp = urlrequest.urlopen(url)
-            htm = version_resp.read().decode('utf8')
-            if version == 'LATEST_RELEASE':
-                sml_version = htm
-            else:
-                pat = rf'<Key>({version}[\d.]*)/chromedriver_[\w.]+.zip</Key>'
-                result = re.findall(pat, htm)
-                if result:
-                    sml_version = max(result)
-        finally:
-            pass
-        return sml_version
+"""
+@author axiner
+@version v1.0.0
+@created 2022/1/18 21:05
+@abstract web驱动
+@description
+@history
+"""
+import os
+import re
+import shutil
+import typing as t
+import urllib.request as urlrequest
+from pathlib import Path
+
+from toollib.validator import choicer
+
+
+__all__ = ['chromedriver']
+
+
+def chromedriver(driver_dir: t.Union[str, Path] = '.', version: str = 'LATEST_RELEASE', platform: str = 'win64') -> str:
+    """
+    自动下载谷歌驱动（注：若指定目录存在与浏览器版本一致的驱动则会跳过）
+    使用示例：
+        # 不指定浏览器版本，则下载当前浏览器对应的版本（针对win平台，mac|linux则下载最新版本（可查看浏览器版本自行指定））
+        import time
+        from selenium import webdriver
+        from selenium.webdriver.chrome.service import Service
+        from toollib import autodriver
+
+        driver_path = autodriver.chromedriver()  # 自动下载驱动
+        driver = webdriver.Chrome(service=Service(driver_path))
+        driver.get('https://www.baidu.com')
+        driver.find_element(value='kw').send_keys('python toollib')
+        driver.find_element(value='su').click()
+        time.sleep(29)
+        driver.close()
+        +++++[更多详见参数或源码]+++++
+    :param driver_dir: 驱动目录（默认当前执行目录）
+    :param version: 版本（谷歌浏览器）
+    :param platform: 平台（默认：win64）-支持：['win32', 'win64', 'mac64', 'linux64']
+    """
+    driver_path = ChromeDriver.download(driver_dir, version, platform)
+    return driver_path
+
+
+class ChromeDriver:
+    """
+    谷歌驱动
+    """
+
+    @classmethod
+    def download(cls, driver_dir: str, version: str, platform: str) -> str:
+        driver_dir = Path(driver_dir).absolute()
+        if driver_dir.is_file():
+            raise TypeError('"driver_dir" is dir')
+        else:
+            driver_dir.mkdir(parents=True, exist_ok=True)
+        platform = choicer(
+            platform,
+            choices=['win32', 'win64', 'mac64', 'linux64'],
+            lable='platform')
+        if platform.startswith('win'):
+            platform = 'win32'
+            version = cls.__get_version(version)
+            exec_file = 'chromedriver.exe'
+        else:
+            exec_file = 'chromedriver'
+        driver_file = driver_dir.joinpath(exec_file)
+        if driver_file.is_file():
+            if cls.__check_driver_version(driver_file, version, platform):
+                return driver_file.as_posix()
+        __version = cls.__find_similar_version(version)
+        if not __version:
+            raise ValueError('This version may not exist')
+        __driver_zip = driver_dir.joinpath(f'chromedriver_{platform}.zip')
+        __download_url = f'https://chromedriver.storage.googleapis.com/' \
+                         f'{__version}/{__driver_zip.name}'
+        try:
+            print(f'Download driver({__driver_zip.stem}) start.....')
+            urlrequest.urlretrieve(__download_url, __driver_zip.as_posix())
+            shutil.unpack_archive(__driver_zip, driver_dir, 'zip')
+            os.remove(__driver_zip)
+            return driver_file.as_posix()
+        except:
+            raise
+
+    @staticmethod
+    def __get_version(version: str) -> str:
+        if version == 'LATEST_RELEASE' or not version:
+            try:
+                import winreg
+                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Google\Chrome\BLBeacon')
+                value, _type = winreg.QueryValueEx(key, 'version')
+                version = value or 'LATEST_RELEASE'
+            except Exception as err:
+                print(str(err))
+                print('将版本赋值为最新版本"LATEST_RELEASE"')
+                version = 'LATEST_RELEASE'
+        version = '.'.join(version.split('.')[:3])
+        return version
+
+    @staticmethod
+    def __check_driver_version(driver_file: str, version: str, platform: str) -> bool:
+        is_eq = True
+        try:
+            if platform.startswith('win'):
+                outstd = os.popen(f'"{driver_file}" --version').read()
+                cv_split = outstd.split()[1].split('.')[:3]
+                v_split = version.split('.')
+                if cv_split != v_split:
+                    if len(v_split) > 1:
+                        is_eq = '.'.join(cv_split).startswith('.'.join(v_split))
+                    else:
+                        is_eq = (v_split == cv_split[:1])
+        except:
+            is_eq = False
+        return is_eq
+
+    @staticmethod
+    def __find_similar_version(version: str) -> str:
+        url = 'https://chromedriver.storage.googleapis.com/'
+        if version == 'LATEST_RELEASE':
+            url += version
+        sml_version = None
+        try:
+            version_resp = urlrequest.urlopen(url)
+            htm = version_resp.read().decode('utf8')
+            if version == 'LATEST_RELEASE':
+                sml_version = htm
+            else:
+                pat = rf'<Key>({version}[\d.]*)/chromedriver_[\w.]+.zip</Key>'
+                result = re.findall(pat, htm)
+                if result:
+                    sml_version = max(result)
+        finally:
+            pass
+        return sml_version
```

## toollib/crypto.py

 * *Ordering differences only*

```diff
@@ -1,175 +1,175 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:46
-@abstract 加密
-@description
-@history
-"""
-import typing as t
-from pathlib import Path
-
-from toollib.validator import choicer
-
-__all__ = [
-    'cmd5',
-    'curl',
-    'cbase64',
-    'cdes',
-]
-
-
-def cmd5(obj, is_file: bool = False, saltstr: str = None):
-    """
-    md5加密
-    使用示例：
-        # 1）针对字符
-        obj = 'this is toollib'
-        cobj = crypto.cmd5(obj)
-        # 2）针对文件
-        obj = 'D:/tmp/t.txt'
-        cobj = crypto.cmd5(obj, is_file=True)
-        # ret: 返回obj的md5
-        +++++[更多详见参数或源码]+++++
-    :param obj: 对象
-    :param is_file: 是否针对文件对象
-    :param saltstr: 加盐字符串
-    :return:
-    """
-    from hashlib import md5
-    _obj = md5()
-    if is_file is True:
-        with open(obj, 'rb') as f:
-            while True:
-                b = f.read(10240)
-                if not b:
-                    break
-                _obj.update(b)
-    else:
-        _obj.update(obj.encode('utf8'))
-    if saltstr:
-        _obj.update(saltstr.encode('utf8'))
-    return _obj.hexdigest()
-
-
-def curl(obj, mode: int = 1):
-    """
-    url加密与解密
-    使用示例：
-        # 加密
-        obj = 'https:www.baidu.com/'
-        cobj = crypto.curl(obj)
-        # 解密
-        obj = crypto.curl(cobj, mode=2)
-        # res: 返回相应结果
-        +++++[更多详见参数或源码]+++++
-    :param obj: 对象
-    :param mode: 模式（1-加密；2-解密）
-    :return:
-    """
-    from urllib import parse
-    mode = choicer(mode, choices=[1, 2], lable='mode')
-    if mode == 1:
-        _obj = parse.quote(obj)
-    else:
-        _obj = parse.unquote(obj)
-    return _obj
-
-
-def cbase64(obj, mode: int = 1, to_file: t.Union[str, Path] = None, altchars=None, validate=False):
-    """
-    base64加密与解密
-    使用示例：
-        # 1）针对字符
-        obj = b'这是一个示例'
-        cobj = crypto.cbase64(obj)
-        # 2）针对文件
-        obj = 'D:/tmp/t.txt'
-        to_file = 'D:/tmp/t.c'
-        cobj = crypto.cbase64(obj, to_file=to_file)
-        # 另：解密详见参数
-        # res: 返回相应结果
-        +++++[更多详见参数或源码]+++++
-    :param obj: 对象
-    :param mode: 模式（1-加密；2-解密）
-    :param to_file: 输出指定文件（针对obj为文件对象）
-    :param altchars: altchars（2 bytes, 用于指定替换'/'和'+'）
-    :param validate:
-    :return:
-    """
-    import base64
-    mode = choicer(mode, choices=[1, 2], lable='mode')
-    if to_file:
-        with open(obj, 'rb') as f, open(to_file, 'wb') as f2:
-            for line in f.readlines():
-                if mode == 1:
-                    f2.write(base64.b64encode(line, altchars))
-                    f2.write(b'\n')
-                else:
-                    f2.write(base64.b64decode(line, altchars))
-        return to_file
-    else:
-        if mode == 1:
-            _obj = base64.b64encode(obj, altchars)
-        else:
-            _obj = base64.b64decode(obj, altchars, validate)
-        return _obj
-
-
-def cdes(obj, deskey='12345678', desiv='abcdefgh', mode: int = 1,
-         to_file: t.Union[str, Path] = None,
-         desmode='CBC', despadmode='PAD_PKCS5'):
-    """
-    des加密与解密（des mode: ECB or CBC）
-    使用示例：
-        # 1）针对字符
-        obj = b'这是一个示例'
-        deskey = b'asdfhjkl'  #  8 bytes
-        desiv = b'aaaaaaaa'  # 8 bytes
-        cobj = crypto.cdes(obj, deskey=deskey, desiv=desiv)
-        # 2）针对文件
-        obj = 'D:/tmp/t.txt'
-        deskey = b'asdfhjkl'  #  8 bytes
-        desiv = b'aaaaaaaa'  # 8 bytes
-        to_file = 'D:/tmp/t.c'
-        cobj = crypto.cdes(obj, deskey=deskey, desiv=desiv, to_file=to_file)
-        # 另：解密详见参数
-        # res: 返回相应结果
-        +++++[更多详见参数或源码]+++++
-    :param obj: 对象
-    :param deskey: des key（8 bytes）
-    :param desiv: des iv向量（8 bytes）
-    :param mode: 模式（1-加密；2-解密）
-    :param to_file: 输出指定文件（针对obj为文件对象）
-    :param desmode: des mode (ECB or CBC, 默认为 CBC)
-    :param despadmode: despad mode (PAD_NORMAL or PAD_PKCS5, 默认为 PAD_PKCS5)
-    :return:
-    """
-    import base64
-    try:
-        import pyDes
-    except ImportError:
-        raise
-    desmode = choicer(desmode, choices=['ECB', 'CBC'], lable='desmod')
-    despadmode = choicer(despadmode, choices=['PAD_NORMAL', 'PAD_PKCS5'], lable='despadmode')
-    despad = None
-    desmode = {'ECB': pyDes.ECB, 'CBC': pyDes.CBC}.get(desmode)
-    despadmode = {'PAD_NORMAL': pyDes.PAD_NORMAL, 'PAD_PKCS5': pyDes.PAD_NORMAL}.get(despadmode)
-    if despadmode == pyDes.PAD_NORMAL:
-        despad = 'z'
-    _des = pyDes.des(deskey, desmode, desiv, pad=despad, padmode=despadmode)
-    if to_file:
-        with open(obj, 'rb') as f, open(to_file, 'wb') as f2:
-            for line in f.readlines():
-                if mode == 1:
-                    f2.write(base64.b64encode(_des.encrypt(line)))
-                    f2.write(b'\n')
-                else:
-                    f2.write(_des.decrypt(base64.b64decode(line)))
-        return to_file
-    else:
-        if mode == 1:
-            _obj = base64.b64encode(_des.encrypt(obj))
-        else:
-            _obj = _des.decrypt(base64.b64decode(obj))
-        return _obj
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:46
+@abstract 加密
+@description
+@history
+"""
+import typing as t
+from pathlib import Path
+
+from toollib.validator import choicer
+
+__all__ = [
+    'cmd5',
+    'curl',
+    'cbase64',
+    'cdes',
+]
+
+
+def cmd5(obj, is_file: bool = False, saltstr: str = None):
+    """
+    md5加密
+    使用示例：
+        # 1）针对字符
+        obj = 'this is toollib'
+        cobj = crypto.cmd5(obj)
+        # 2）针对文件
+        obj = 'D:/tmp/t.txt'
+        cobj = crypto.cmd5(obj, is_file=True)
+        # ret: 返回obj的md5
+        +++++[更多详见参数或源码]+++++
+    :param obj: 对象
+    :param is_file: 是否针对文件对象
+    :param saltstr: 加盐字符串
+    :return:
+    """
+    from hashlib import md5
+    _obj = md5()
+    if is_file is True:
+        with open(obj, 'rb') as f:
+            while True:
+                b = f.read(10240)
+                if not b:
+                    break
+                _obj.update(b)
+    else:
+        _obj.update(obj.encode('utf8'))
+    if saltstr:
+        _obj.update(saltstr.encode('utf8'))
+    return _obj.hexdigest()
+
+
+def curl(obj, mode: int = 1):
+    """
+    url加密与解密
+    使用示例：
+        # 加密
+        obj = 'https:www.baidu.com/'
+        cobj = crypto.curl(obj)
+        # 解密
+        obj = crypto.curl(cobj, mode=2)
+        # res: 返回相应结果
+        +++++[更多详见参数或源码]+++++
+    :param obj: 对象
+    :param mode: 模式（1-加密；2-解密）
+    :return:
+    """
+    from urllib import parse
+    mode = choicer(mode, choices=[1, 2], lable='mode')
+    if mode == 1:
+        _obj = parse.quote(obj)
+    else:
+        _obj = parse.unquote(obj)
+    return _obj
+
+
+def cbase64(obj, mode: int = 1, to_file: t.Union[str, Path] = None, altchars=None, validate=False):
+    """
+    base64加密与解密
+    使用示例：
+        # 1）针对字符
+        obj = b'这是一个示例'
+        cobj = crypto.cbase64(obj)
+        # 2）针对文件
+        obj = 'D:/tmp/t.txt'
+        to_file = 'D:/tmp/t.c'
+        cobj = crypto.cbase64(obj, to_file=to_file)
+        # 另：解密详见参数
+        # res: 返回相应结果
+        +++++[更多详见参数或源码]+++++
+    :param obj: 对象
+    :param mode: 模式（1-加密；2-解密）
+    :param to_file: 输出指定文件（针对obj为文件对象）
+    :param altchars: altchars（2 bytes, 用于指定替换'/'和'+'）
+    :param validate:
+    :return:
+    """
+    import base64
+    mode = choicer(mode, choices=[1, 2], lable='mode')
+    if to_file:
+        with open(obj, 'rb') as f, open(to_file, 'wb') as f2:
+            for line in f.readlines():
+                if mode == 1:
+                    f2.write(base64.b64encode(line, altchars))
+                    f2.write(b'\n')
+                else:
+                    f2.write(base64.b64decode(line, altchars))
+        return to_file
+    else:
+        if mode == 1:
+            _obj = base64.b64encode(obj, altchars)
+        else:
+            _obj = base64.b64decode(obj, altchars, validate)
+        return _obj
+
+
+def cdes(obj, deskey='12345678', desiv='abcdefgh', mode: int = 1,
+         to_file: t.Union[str, Path] = None,
+         desmode='CBC', despadmode='PAD_PKCS5'):
+    """
+    des加密与解密（des mode: ECB or CBC）
+    使用示例：
+        # 1）针对字符
+        obj = b'这是一个示例'
+        deskey = b'asdfhjkl'  #  8 bytes
+        desiv = b'aaaaaaaa'  # 8 bytes
+        cobj = crypto.cdes(obj, deskey=deskey, desiv=desiv)
+        # 2）针对文件
+        obj = 'D:/tmp/t.txt'
+        deskey = b'asdfhjkl'  #  8 bytes
+        desiv = b'aaaaaaaa'  # 8 bytes
+        to_file = 'D:/tmp/t.c'
+        cobj = crypto.cdes(obj, deskey=deskey, desiv=desiv, to_file=to_file)
+        # 另：解密详见参数
+        # res: 返回相应结果
+        +++++[更多详见参数或源码]+++++
+    :param obj: 对象
+    :param deskey: des key（8 bytes）
+    :param desiv: des iv向量（8 bytes）
+    :param mode: 模式（1-加密；2-解密）
+    :param to_file: 输出指定文件（针对obj为文件对象）
+    :param desmode: des mode (ECB or CBC, 默认为 CBC)
+    :param despadmode: despad mode (PAD_NORMAL or PAD_PKCS5, 默认为 PAD_PKCS5)
+    :return:
+    """
+    import base64
+    try:
+        import pyDes
+    except ImportError:
+        raise
+    desmode = choicer(desmode, choices=['ECB', 'CBC'], lable='desmod')
+    despadmode = choicer(despadmode, choices=['PAD_NORMAL', 'PAD_PKCS5'], lable='despadmode')
+    despad = None
+    desmode = {'ECB': pyDes.ECB, 'CBC': pyDes.CBC}.get(desmode)
+    despadmode = {'PAD_NORMAL': pyDes.PAD_NORMAL, 'PAD_PKCS5': pyDes.PAD_NORMAL}.get(despadmode)
+    if despadmode == pyDes.PAD_NORMAL:
+        despad = 'z'
+    _des = pyDes.des(deskey, desmode, desiv, pad=despad, padmode=despadmode)
+    if to_file:
+        with open(obj, 'rb') as f, open(to_file, 'wb') as f2:
+            for line in f.readlines():
+                if mode == 1:
+                    f2.write(base64.b64encode(_des.encrypt(line)))
+                    f2.write(b'\n')
+                else:
+                    f2.write(_des.decrypt(base64.b64decode(line)))
+        return to_file
+    else:
+        if mode == 1:
+            _obj = base64.b64encode(_des.encrypt(obj))
+        else:
+            _obj = _des.decrypt(base64.b64decode(obj))
+        return _obj
```

## toollib/decorator.py

 * *Ordering differences only*

```diff
@@ -1,123 +1,123 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2021/12/14 20:28
-@abstract 装饰器
-@description
-@history
-"""
-import re
-import sys
-import time
-import traceback
-import typing as t
-from functools import wraps
-
-from toollib.utils import sysname
-
-__all__ = [
-    'print_return',
-    'catch_exception',
-    'timer',
-    'sys_required',
-]
-
-# config of print
-FLWIDTH = 66
-FLCHAR = '-'
-
-
-def print_return(is_print: bool = True):
-    """
-    打印返回结果
-    使用示例：
-        @decorator.print_return()
-        def foo():
-            return 'this is toollib'
-    :param is_print: 是否打印
-    :return:
-    """
-    def wrapper(func: t.Callable):
-        @wraps(func)
-        def inner(*args, **kwargs):
-            result = func(*args, **kwargs)
-            if is_print is True:
-                print('func: "{0}", return: {1}\t【@type: {2}】'.format(
-                    func.__name__, result, type(result)).center(FLWIDTH, FLCHAR))
-            return result
-        return inner
-    return wrapper
-
-
-def catch_exception(is_raise: bool = True):
-    """
-    捕获异常
-    使用示例：
-        @decorator.catch_exception()
-        def foo():
-            pass
-    :param is_raise: 是否raise
-    :return:
-    """
-    def wrapper(func: t.Callable):
-        @wraps(func)
-        def inner(*args, **kwargs):
-            try:
-                return func(*args, **kwargs)
-            except:
-                if is_raise is True:
-                    raise
-                else:
-                    traceback.print_exc()
-        return inner
-    return wrapper
-
-
-def timer(func: t.Callable):
-    """
-    计时器
-    使用示例：
-        @decorator.timer()
-        def foo():
-            pass
-    :param func:
-    :return:
-    """
-    @wraps(func)
-    def wrapper(*args, **kwargs):
-        print('func: "{0}", start.....'.format(func.__name__).center(FLWIDTH, FLCHAR))
-        start_time = time.time()
-        result = func(*args, **kwargs)
-        end_time = time.time()
-        print('func: "{0}" finished, spent time: {1:.2f}s'.format(
-            func.__name__, end_time - start_time).center(FLWIDTH, FLCHAR))
-        return result
-    return wrapper
-
-
-def sys_required(supported_sys: str = None, errmsg: str = None, is_raise: bool = False):
-    """
-    系统要求
-    使用示例：
-        @decorator.sys_required()
-        def foo():
-            pass
-    :param supported_sys: 支持的系统（正则表达示）
-    :param errmsg: 匹配失败信息
-    :param is_raise: 是否raise
-    :return:
-    """
-    errmsg = errmsg or 'System only supported: %s' % supported_sys
-
-    def wrapper(func):
-        @wraps(func)
-        def inner(*args, **kwargs):
-            if supported_sys and not re.search(supported_sys, sysname(), re.I):
-                if is_raise is True:
-                    raise TypeError(errmsg)
-                else:
-                    sys.stderr.write(errmsg+'\n')
-                    sys.exit(1)
-            return func(*args, **kwargs)
-        return inner
-    return wrapper
+"""
+@author axiner
+@version v1.0.0
+@created 2021/12/14 20:28
+@abstract 装饰器
+@description
+@history
+"""
+import re
+import sys
+import time
+import traceback
+import typing as t
+from functools import wraps
+
+from toollib.utils import sysname
+
+__all__ = [
+    'print_return',
+    'catch_exception',
+    'timer',
+    'sys_required',
+]
+
+# config of print
+FLWIDTH = 66
+FLCHAR = '-'
+
+
+def print_return(is_print: bool = True):
+    """
+    打印返回结果
+    使用示例：
+        @decorator.print_return()
+        def foo():
+            return 'this is toollib'
+    :param is_print: 是否打印
+    :return:
+    """
+    def wrapper(func: t.Callable):
+        @wraps(func)
+        def inner(*args, **kwargs):
+            result = func(*args, **kwargs)
+            if is_print is True:
+                print('func: "{0}", return: {1}\t【@type: {2}】'.format(
+                    func.__name__, result, type(result)).center(FLWIDTH, FLCHAR))
+            return result
+        return inner
+    return wrapper
+
+
+def catch_exception(is_raise: bool = True):
+    """
+    捕获异常
+    使用示例：
+        @decorator.catch_exception()
+        def foo():
+            pass
+    :param is_raise: 是否raise
+    :return:
+    """
+    def wrapper(func: t.Callable):
+        @wraps(func)
+        def inner(*args, **kwargs):
+            try:
+                return func(*args, **kwargs)
+            except:
+                if is_raise is True:
+                    raise
+                else:
+                    traceback.print_exc()
+        return inner
+    return wrapper
+
+
+def timer(func: t.Callable):
+    """
+    计时器
+    使用示例：
+        @decorator.timer()
+        def foo():
+            pass
+    :param func:
+    :return:
+    """
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        print('func: "{0}", start.....'.format(func.__name__).center(FLWIDTH, FLCHAR))
+        start_time = time.time()
+        result = func(*args, **kwargs)
+        end_time = time.time()
+        print('func: "{0}" finished, spent time: {1:.2f}s'.format(
+            func.__name__, end_time - start_time).center(FLWIDTH, FLCHAR))
+        return result
+    return wrapper
+
+
+def sys_required(supported_sys: str = None, errmsg: str = None, is_raise: bool = False):
+    """
+    系统要求
+    使用示例：
+        @decorator.sys_required()
+        def foo():
+            pass
+    :param supported_sys: 支持的系统（正则表达示）
+    :param errmsg: 匹配失败信息
+    :param is_raise: 是否raise
+    :return:
+    """
+    errmsg = errmsg or 'System only supported: %s' % supported_sys
+
+    def wrapper(func):
+        @wraps(func)
+        def inner(*args, **kwargs):
+            if supported_sys and not re.search(supported_sys, sysname(), re.I):
+                if is_raise is True:
+                    raise TypeError(errmsg)
+                else:
+                    sys.stderr.write(errmsg+'\n')
+                    sys.exit(1)
+            return func(*args, **kwargs)
+        return inner
+    return wrapper
```

## toollib/guid.py

 * *Ordering differences only*

```diff
@@ -1,208 +1,208 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/7/30 16:07
-@abstract 全局唯一id
-@description
-@history
-"""
-import time
-from datetime import datetime, timedelta
-
-import typing as t
-
-from toollib.common.error import InvalidSystemClock
-from toollib.utils import Singleton, now2str
-
-__all__ = [
-    'SnowFlake',
-    'RedisUid',
-]
-
-
-NoneType = type(None)
-
-
-class SnowFlake(metaclass=Singleton):
-    """
-    雪花算法（全局唯一id）
-    （最早是Twitter公司在其内部用于分布式环境下生成唯一ID）
-    # Twitter's Snowflake algorithm implementation which is used to generate distributed IDs.
-    # https://github.com/twitter-archive/snowflake/blob/snowflake-2010/src/main/scala/com/twitter/service/snowflake/IdWorker.scala
-    使用示例：
-        from toollib.guid import SnowFlake
-        snow = SnowFlake()
-        uid = snow.gen_uid()
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(
-            self,
-            worker_id: int = 0,
-            datacenter_id: int = 0,
-            sequence=0,
-            epoch_timestamp: int = 1639286040000,
-            worker_id_bits: int = 5,
-            datacenter_id_bits: int = 5,
-            sequence_bits: int = 12,
-            to_str: bool = False,
-    ):
-        """
-        初始化
-            注：分布式可通过映射指定不同的'worker_id'+'datacenter_id'来区分
-        :param worker_id: 机器ID
-        :param datacenter_id: 数据中心ID
-        :param sequence: 序号
-        :param epoch_timestamp: 纪元（[默认:1639286040000=>20211212131400][Twitter:1288834974657=>20101104094254]）
-        :param worker_id_bits: 机器id位数
-        :param datacenter_id_bits: 服务id位数
-        :param sequence_bits: 序号位数
-        :param to_str: 是否转为字符串
-        """
-        if not isinstance(worker_id, (int, type(None))):
-            raise TypeError('"worker_id" only supported: int')
-        if not isinstance(datacenter_id, (int, type(None))):
-            raise TypeError('"datacenter_id" only supported: int')
-        max_worker_id = -1 ^ (-1 << worker_id_bits)
-        max_datacenter_id = -1 ^ (-1 << datacenter_id_bits)
-        if worker_id > max_worker_id or worker_id < 0:
-            raise ValueError(f'"worker_id" only supported: 0, {max_worker_id}')
-        if datacenter_id > max_datacenter_id or datacenter_id < 0:
-            raise ValueError(f'"datacenter_id" only supported: 0, {max_datacenter_id}')
-
-        self.worker_id = worker_id
-        self.datacenter_id = datacenter_id
-        self.sequence = sequence
-        self.epoch_timestamp = epoch_timestamp
-        self.last_timestamp = -1
-
-        self.worker_id_shift = sequence_bits
-        self.datacenter_id_shift = sequence_bits + worker_id_bits
-        self.timestamp_left_shift = sequence_bits + worker_id_bits + datacenter_id_bits
-        self.sequence_mask = -1 ^ (-1 << sequence_bits)
-
-        self.to_str = to_str
-
-    def gen_uid(self, to_str: bool = None):
-        """
-        生成唯一id
-        :param to_str: 是否转为字符串(可覆盖cls中的to_str)
-        :return:
-        """
-        if to_str is None:
-            to_str = self.to_str
-        timestamp = self._current_timestamp()
-        if timestamp < self.last_timestamp:
-            raise InvalidSystemClock("Clock moved backwards. Refusing to generate id for %s milliseconds" % (
-                    self.last_timestamp - timestamp))
-        if timestamp == self.last_timestamp:
-            self.sequence = (self.sequence + 1) & self.sequence_mask
-            if self.sequence == 0:
-                timestamp = self._til_next_millis(self.last_timestamp)
-        else:
-            self.sequence = 0
-        self.last_timestamp = timestamp
-        uid = ((timestamp - self.epoch_timestamp) << self.timestamp_left_shift) | \
-              (self.datacenter_id << self.datacenter_id_shift) | \
-              (self.worker_id << self.worker_id_shift) | self.sequence
-        if to_str is True:
-            uid = str(uid)
-        return uid
-
-    def _til_next_millis(self, last_timestamp):
-        timestamp = self._current_timestamp()
-        while timestamp <= last_timestamp:
-            timestamp = self._current_timestamp()
-        return timestamp
-
-    @staticmethod
-    def _current_timestamp():
-        return int(time.time() * 1000)
-
-
-class RedisUid:
-    """
-    全局唯一id，基于redis实现（可用于分布式）
-    使用示例：
-        from toollib.guid import RedisUid
-        ruid = RedisUid(redis_cli, prefix='ABC')
-        uid = ruid.gen_uid()
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(
-            self,
-            redis_cli,
-            prefix: str = None,
-            seq_name: str = None,
-            seq_beg: int = 0,
-            seq_len: int = 9,
-            seq_ex: datetime = None,
-            date_fmt: t.Union[str, NoneType] = '%Y%m%d',
-            sep: str = '',
-    ):
-        """
-        初始化
-        :param redis_cli: redis客户端对象
-        :param prefix: 前缀，为空则没有前缀拼接
-        :param seq_name: 序列名称，作为redis存储键(为空则默认取prefix，但两者不能同时为空)
-        :param seq_beg: 序列开始，默认为0
-        :param seq_len: 序列长度，默认为9(不足则0填充)
-        :param seq_ex: 序列过期时间，为空则默认第二天凌晨
-        :param date_fmt: 日期格式，为空则没有日期拼接
-        :param sep: 分隔符，默认为空
-        """
-        self.redis_cli = redis_cli
-        self.prefix = prefix
-        self.seq_name = seq_name or self.prefix
-        self.seq_beg = seq_beg
-        self.seq_len = seq_len
-        self.seq_ex = seq_ex
-        self.date_fmt = date_fmt
-        self.sep = sep
-        self._check_params()
-
-    def _check_params(self):
-        if not isinstance(self.prefix, (str, NoneType)):
-            raise TypeError("'prefix'只支持字符串型与None")
-        if not isinstance(self.seq_name, (str, NoneType)):
-            raise TypeError("'seq_name'只支持字符串型与None")
-        if not self.seq_name:
-            raise ValueError("'prefix'与'seq_name'不能同时为空")
-        if not isinstance(self.seq_beg, int):
-            raise TypeError("'seq_beg'只支持整型")
-        if self.seq_ex is not None and not isinstance(self.seq_ex, datetime):
-            raise TypeError("'seq_ex'只支持datetime型")
-        if not isinstance(self.sep, str):
-            raise TypeError("'sep'只支持字符串型")
-
-    def gen_uid(self, seq_step: int = 1):
-        """
-        生成唯一id
-        :param seq_step: 序列步长，默认为1
-        :return:
-        """
-        if not isinstance(seq_step, int):
-            raise TypeError("'seq_step'只支持整型")
-        if self.redis_cli.ttl(self.seq_name) < 0:
-            self.redis_cli.set(self.seq_name, self.seq_beg)
-            self.redis_cli.expireat(self.seq_name, self._set_ex(self.seq_ex))
-        _prefix = self.prefix or ''
-        _date_value = now2str(self.date_fmt) if self.date_fmt else ''
-        _seq_value = self.redis_cli.incrby(self.seq_name, seq_step)
-        uid = self.sep.join([
-            _prefix,
-            _date_value,
-            str(_seq_value).zfill(self.seq_len)]).lstrip(self.sep)
-        return uid
-
-    @staticmethod
-    def _set_ex(ex):
-        if not ex:
-            ex = (datetime.now() + timedelta(days=1)).replace(
-                hour=0,
-                minute=0,
-                second=0,
-                microsecond=0,
-            )
-        return ex
+"""
+@author axiner
+@version v1.0.0
+@created 2022/7/30 16:07
+@abstract 全局唯一id
+@description
+@history
+"""
+import time
+from datetime import datetime, timedelta
+
+import typing as t
+
+from toollib.common.error import InvalidSystemClock
+from toollib.utils import Singleton, now2str
+
+__all__ = [
+    'SnowFlake',
+    'RedisUid',
+]
+
+
+NoneType = type(None)
+
+
+class SnowFlake(metaclass=Singleton):
+    """
+    雪花算法（全局唯一id）
+    （最早是Twitter公司在其内部用于分布式环境下生成唯一ID）
+    # Twitter's Snowflake algorithm implementation which is used to generate distributed IDs.
+    # https://github.com/twitter-archive/snowflake/blob/snowflake-2010/src/main/scala/com/twitter/service/snowflake/IdWorker.scala
+    使用示例：
+        from toollib.guid import SnowFlake
+        snow = SnowFlake()
+        uid = snow.gen_uid()
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(
+            self,
+            worker_id: int = 0,
+            datacenter_id: int = 0,
+            sequence=0,
+            epoch_timestamp: int = 1639286040000,
+            worker_id_bits: int = 5,
+            datacenter_id_bits: int = 5,
+            sequence_bits: int = 12,
+            to_str: bool = False,
+    ):
+        """
+        初始化
+            注：分布式可通过映射指定不同的'worker_id'+'datacenter_id'来区分
+        :param worker_id: 机器ID
+        :param datacenter_id: 数据中心ID
+        :param sequence: 序号
+        :param epoch_timestamp: 纪元（[默认:1639286040000=>20211212131400][Twitter:1288834974657=>20101104094254]）
+        :param worker_id_bits: 机器id位数
+        :param datacenter_id_bits: 服务id位数
+        :param sequence_bits: 序号位数
+        :param to_str: 是否转为字符串
+        """
+        if not isinstance(worker_id, (int, type(None))):
+            raise TypeError('"worker_id" only supported: int')
+        if not isinstance(datacenter_id, (int, type(None))):
+            raise TypeError('"datacenter_id" only supported: int')
+        max_worker_id = -1 ^ (-1 << worker_id_bits)
+        max_datacenter_id = -1 ^ (-1 << datacenter_id_bits)
+        if worker_id > max_worker_id or worker_id < 0:
+            raise ValueError(f'"worker_id" only supported: 0, {max_worker_id}')
+        if datacenter_id > max_datacenter_id or datacenter_id < 0:
+            raise ValueError(f'"datacenter_id" only supported: 0, {max_datacenter_id}')
+
+        self.worker_id = worker_id
+        self.datacenter_id = datacenter_id
+        self.sequence = sequence
+        self.epoch_timestamp = epoch_timestamp
+        self.last_timestamp = -1
+
+        self.worker_id_shift = sequence_bits
+        self.datacenter_id_shift = sequence_bits + worker_id_bits
+        self.timestamp_left_shift = sequence_bits + worker_id_bits + datacenter_id_bits
+        self.sequence_mask = -1 ^ (-1 << sequence_bits)
+
+        self.to_str = to_str
+
+    def gen_uid(self, to_str: bool = None):
+        """
+        生成唯一id
+        :param to_str: 是否转为字符串(可覆盖cls中的to_str)
+        :return:
+        """
+        if to_str is None:
+            to_str = self.to_str
+        timestamp = self._current_timestamp()
+        if timestamp < self.last_timestamp:
+            raise InvalidSystemClock("Clock moved backwards. Refusing to generate id for %s milliseconds" % (
+                    self.last_timestamp - timestamp))
+        if timestamp == self.last_timestamp:
+            self.sequence = (self.sequence + 1) & self.sequence_mask
+            if self.sequence == 0:
+                timestamp = self._til_next_millis(self.last_timestamp)
+        else:
+            self.sequence = 0
+        self.last_timestamp = timestamp
+        uid = ((timestamp - self.epoch_timestamp) << self.timestamp_left_shift) | \
+              (self.datacenter_id << self.datacenter_id_shift) | \
+              (self.worker_id << self.worker_id_shift) | self.sequence
+        if to_str is True:
+            uid = str(uid)
+        return uid
+
+    def _til_next_millis(self, last_timestamp):
+        timestamp = self._current_timestamp()
+        while timestamp <= last_timestamp:
+            timestamp = self._current_timestamp()
+        return timestamp
+
+    @staticmethod
+    def _current_timestamp():
+        return int(time.time() * 1000)
+
+
+class RedisUid:
+    """
+    全局唯一id，基于redis实现（可用于分布式）
+    使用示例：
+        from toollib.guid import RedisUid
+        ruid = RedisUid(redis_cli, prefix='ABC')
+        uid = ruid.gen_uid()
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(
+            self,
+            redis_cli,
+            prefix: str = None,
+            seq_name: str = None,
+            seq_beg: int = 0,
+            seq_len: int = 9,
+            seq_ex: datetime = None,
+            date_fmt: t.Union[str, NoneType] = '%Y%m%d',
+            sep: str = '',
+    ):
+        """
+        初始化
+        :param redis_cli: redis客户端对象
+        :param prefix: 前缀，为空则没有前缀拼接
+        :param seq_name: 序列名称，作为redis存储键(为空则默认取prefix，但两者不能同时为空)
+        :param seq_beg: 序列开始，默认为0
+        :param seq_len: 序列长度，默认为9(不足则0填充)
+        :param seq_ex: 序列过期时间，为空则默认第二天凌晨
+        :param date_fmt: 日期格式，为空则没有日期拼接
+        :param sep: 分隔符，默认为空
+        """
+        self.redis_cli = redis_cli
+        self.prefix = prefix
+        self.seq_name = seq_name or self.prefix
+        self.seq_beg = seq_beg
+        self.seq_len = seq_len
+        self.seq_ex = seq_ex
+        self.date_fmt = date_fmt
+        self.sep = sep
+        self._check_params()
+
+    def _check_params(self):
+        if not isinstance(self.prefix, (str, NoneType)):
+            raise TypeError("'prefix'只支持字符串型与None")
+        if not isinstance(self.seq_name, (str, NoneType)):
+            raise TypeError("'seq_name'只支持字符串型与None")
+        if not self.seq_name:
+            raise ValueError("'prefix'与'seq_name'不能同时为空")
+        if not isinstance(self.seq_beg, int):
+            raise TypeError("'seq_beg'只支持整型")
+        if self.seq_ex is not None and not isinstance(self.seq_ex, datetime):
+            raise TypeError("'seq_ex'只支持datetime型")
+        if not isinstance(self.sep, str):
+            raise TypeError("'sep'只支持字符串型")
+
+    def gen_uid(self, seq_step: int = 1):
+        """
+        生成唯一id
+        :param seq_step: 序列步长，默认为1
+        :return:
+        """
+        if not isinstance(seq_step, int):
+            raise TypeError("'seq_step'只支持整型")
+        if self.redis_cli.ttl(self.seq_name) < 0:
+            self.redis_cli.set(self.seq_name, self.seq_beg)
+            self.redis_cli.expireat(self.seq_name, self._set_ex(self.seq_ex))
+        _prefix = self.prefix or ''
+        _date_value = now2str(self.date_fmt) if self.date_fmt else ''
+        _seq_value = self.redis_cli.incrby(self.seq_name, seq_step)
+        uid = self.sep.join([
+            _prefix,
+            _date_value,
+            str(_seq_value).zfill(self.seq_len)]).lstrip(self.sep)
+        return uid
+
+    @staticmethod
+    def _set_ex(ex):
+        if not ex:
+            ex = (datetime.now() + timedelta(days=1)).replace(
+                hour=0,
+                minute=0,
+                second=0,
+                microsecond=0,
+            )
+        return ex
```

## toollib/kvalue.py

 * *Ordering differences only*

```diff
@@ -1,204 +1,204 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2021/12/18 22:21
-@abstract key-value容器（基于sqlite3）
-@description
-@history
-"""
-import os
-import sqlite3
-import time
-import typing as t
-from pathlib import Path
-
-from toollib.common.error import ExpireError
-from toollib.utils import json, Singleton
-
-__all__ = ['KV']
-
-
-class KV(metaclass=Singleton):
-    """
-    key-value容器
-    使用示例：
-        # 创建一个kv实例
-        kv = kvalue.KV(kvfile='D:/tmp/kv.db')
-        # 增改查删操作
-        kv.set(key='name', value='xxx')
-        kv.expire(key='name', ex=60)  # 过期时间
-        kv.get(key='name')
-        kv.exists(key='name')
-        kv.delete(key='name')
-        # res: 结果存储于kvfile的db文件里
-        +++++[更多详见参数或源码]+++++
-    """
-
-    # __slots__ = ('__kvfile', '__kvtable')
-
-    __support_types = (str, list,  dict, int, float, bool, type(None))
-
-    def __init__(self, kvfile: t.Union[str, Path], kvtable: str = 'kvalues', *args, **kwargs):
-        self.__kvfile, self.__kvtable = self.__check_g(kvfile, kvtable)
-        self.__new_db()
-        super(KV, self).__init__(*args, **kwargs)
-
-    def __check_g(self, kvfile, kvtable):
-        if isinstance(kvfile, (str, Path)):
-            if not kvfile:
-                raise ValueError('"kvfile" cannot be empty')
-            kvfile = str(kvfile)
-        else:
-            raise TypeError('"kvfile" only supported: str or Path')
-        if isinstance(kvtable, str):
-            if not kvtable:
-                raise ValueError('"kvtable" cannot be empty')
-        else:
-            raise TypeError('"kvtable" only supported: str')
-        return kvfile, kvtable
-
-    def __conn(self):
-        return sqlite3.connect(self.__kvfile)
-
-    def get(self, key: str, check_expire: bool = True, get_expire: bool = False):
-        """
-        获取key的value
-        :param key:
-        :param check_expire: 是否检测过期（True: 若过期则会raise）
-        :param get_expire: 是否返回过期时间（True: 返回格式为元组(value, expire)）
-        :return:
-        """
-        sql = 'select v, expire from {tb} where k=?'.format(tb=self.__kvtable)
-        parameters = (key,)
-        value, expire = self.__queryone(sql, parameters)
-        if isinstance(check_expire, bool):
-            if check_expire is True:
-                if expire > 0:
-                    is_expire = expire - time.time()
-                    if is_expire < 0:
-                        raise ExpireError('"%s" has expired' % key)
-        else:
-            raise TypeError('"check_expire" only supported: bool')
-        if value:
-            value = json(value)
-        if get_expire is True:
-            return value, expire
-        return value
-
-    def set(self, key: str, value, expire: t.Union[int, float] = 0) -> None:
-        """
-        设置kye-value
-        :param key:
-        :param value:
-        :param expire: 默认为0（表不设置过期时间）
-        :return:
-        """
-        parameters = self.__check_parameters(key, value, expire)
-        sql = 'replace into {tb} (k, v, expire) values(?, ?, ?)'.format(tb=self.__kvtable)
-        self.__execute(sql, parameters)
-
-    def expire(self, key: str, ex: t.Union[int, float] = 0):
-        """
-        设置key的过期时间
-        :param key:
-        :param ex: 默认为0（表不设置过期时间）
-        :return:
-        """
-        key, _, ex = self.__check_parameters(key=key, expire=ex)
-        parameters = (ex, key)
-        sql = 'update {tb} set expire=? where k=?'.format(tb=self.__kvtable)
-        self.__execute(sql, parameters)
-
-    def __check_parameters(self, key, value=None, expire=None):
-        if isinstance(key, str):
-            if not key:
-                raise ValueError('"key" cannot be empty')
-        else:
-            raise TypeError('"key" only supported: str')
-        if value is not None:
-            if not isinstance(value, self.__support_types):
-                raise TypeError('"value" only supported: %s' % [
-                    _t.__name__ for _t in self.__support_types])
-            else:
-                value = json(value, 'dumps')
-        if expire is not None:
-            if isinstance(expire, (int, float)):
-                if expire < 0:
-                    raise ValueError('"expire" greater than or equal to 0')
-                elif expire > 0:
-                    expire = round(time.time() + expire, 7)
-            else:
-                raise TypeError('"expire" only supported: int or float')
-        return key, value, expire
-
-    def __execute(self, sql: str, parameters: t.Iterable = None) -> None:
-        conn = self.__conn()
-        cursor = conn.cursor()
-        if parameters:
-            cursor.execute(sql, parameters)
-        else:
-            cursor.execute(sql)
-        conn.commit()
-        self.__close(cursor, conn)
-
-    def __close(self, cursor, conn) -> None:
-        cursor.close()
-        conn.close()
-
-    def __new_db(self) -> None:
-        sql = 'create table if not exists {tb}(' \
-              'k text not null primary key, ' \
-              'v text, ' \
-              'expire real)'.format(tb=self.__kvtable)
-        self.__execute(sql)
-
-    def __queryone(self, sql: str, parameters: t.Iterable):
-        conn = self.__conn()
-        cursor = conn.cursor()
-        cursor.execute(sql, parameters)
-        one = cursor.fetchone()
-        value, expire = one if one else (None, 0)
-        self.__close(cursor, conn)
-        return value, expire
-
-    def exists(self, key: str) -> bool:
-        """
-        检测key是否存在
-        :param key:
-        :return:
-        """
-        conn = self.__conn()
-        cursor = conn.cursor()
-        sql = 'select k from {tb} where k=?'.format(tb=self.__kvtable)
-        parameters = (key,)
-        cursor.execute(sql, parameters)
-        result = cursor.fetchone()
-        self.__close(cursor, conn)
-        if not result:
-            return False
-        return True
-
-    def delete(self, key: str) -> None:
-        """
-        删除key
-        :param key:
-        :return:
-        """
-        sql = 'delete from {tb} where k=?'.format(tb=self.__kvtable)
-        parameters = (key,)
-        self.__execute(sql, parameters)
-
-    def clear(self) -> None:
-        """
-        清除所有key-value
-        :return:
-        """
-        sql = 'delete from {tb}'.format(tb=self.__kvtable)
-        self.__execute(sql)
-
-    def remove(self) -> None:
-        """
-        移除KV实例的kvfile文件
-        :return:
-        """
-        os.remove(self.__kvfile)
+"""
+@author axiner
+@version v1.0.0
+@created 2021/12/18 22:21
+@abstract key-value容器（基于sqlite3）
+@description
+@history
+"""
+import os
+import sqlite3
+import time
+import typing as t
+from pathlib import Path
+
+from toollib.common.error import ExpireError
+from toollib.utils import json, Singleton
+
+__all__ = ['KV']
+
+
+class KV(metaclass=Singleton):
+    """
+    key-value容器
+    使用示例：
+        # 创建一个kv实例
+        kv = kvalue.KV(kvfile='D:/tmp/kv.db')
+        # 增改查删操作
+        kv.set(key='name', value='xxx')
+        kv.expire(key='name', ex=60)  # 过期时间
+        kv.get(key='name')
+        kv.exists(key='name')
+        kv.delete(key='name')
+        # res: 结果存储于kvfile的db文件里
+        +++++[更多详见参数或源码]+++++
+    """
+
+    # __slots__ = ('__kvfile', '__kvtable')
+
+    __support_types = (str, list,  dict, int, float, bool, type(None))
+
+    def __init__(self, kvfile: t.Union[str, Path], kvtable: str = 'kvalues', *args, **kwargs):
+        self.__kvfile, self.__kvtable = self.__check_g(kvfile, kvtable)
+        self.__new_db()
+        super(KV, self).__init__(*args, **kwargs)
+
+    def __check_g(self, kvfile, kvtable):
+        if isinstance(kvfile, (str, Path)):
+            if not kvfile:
+                raise ValueError('"kvfile" cannot be empty')
+            kvfile = str(kvfile)
+        else:
+            raise TypeError('"kvfile" only supported: str or Path')
+        if isinstance(kvtable, str):
+            if not kvtable:
+                raise ValueError('"kvtable" cannot be empty')
+        else:
+            raise TypeError('"kvtable" only supported: str')
+        return kvfile, kvtable
+
+    def __conn(self):
+        return sqlite3.connect(self.__kvfile)
+
+    def get(self, key: str, check_expire: bool = True, get_expire: bool = False):
+        """
+        获取key的value
+        :param key:
+        :param check_expire: 是否检测过期（True: 若过期则会raise）
+        :param get_expire: 是否返回过期时间（True: 返回格式为元组(value, expire)）
+        :return:
+        """
+        sql = 'select v, expire from {tb} where k=?'.format(tb=self.__kvtable)
+        parameters = (key,)
+        value, expire = self.__queryone(sql, parameters)
+        if isinstance(check_expire, bool):
+            if check_expire is True:
+                if expire > 0:
+                    is_expire = expire - time.time()
+                    if is_expire < 0:
+                        raise ExpireError('"%s" has expired' % key)
+        else:
+            raise TypeError('"check_expire" only supported: bool')
+        if value:
+            value = json(value)
+        if get_expire is True:
+            return value, expire
+        return value
+
+    def set(self, key: str, value, expire: t.Union[int, float] = 0) -> None:
+        """
+        设置kye-value
+        :param key:
+        :param value:
+        :param expire: 默认为0（表不设置过期时间）
+        :return:
+        """
+        parameters = self.__check_parameters(key, value, expire)
+        sql = 'replace into {tb} (k, v, expire) values(?, ?, ?)'.format(tb=self.__kvtable)
+        self.__execute(sql, parameters)
+
+    def expire(self, key: str, ex: t.Union[int, float] = 0):
+        """
+        设置key的过期时间
+        :param key:
+        :param ex: 默认为0（表不设置过期时间）
+        :return:
+        """
+        key, _, ex = self.__check_parameters(key=key, expire=ex)
+        parameters = (ex, key)
+        sql = 'update {tb} set expire=? where k=?'.format(tb=self.__kvtable)
+        self.__execute(sql, parameters)
+
+    def __check_parameters(self, key, value=None, expire=None):
+        if isinstance(key, str):
+            if not key:
+                raise ValueError('"key" cannot be empty')
+        else:
+            raise TypeError('"key" only supported: str')
+        if value is not None:
+            if not isinstance(value, self.__support_types):
+                raise TypeError('"value" only supported: %s' % [
+                    _t.__name__ for _t in self.__support_types])
+            else:
+                value = json(value, 'dumps')
+        if expire is not None:
+            if isinstance(expire, (int, float)):
+                if expire < 0:
+                    raise ValueError('"expire" greater than or equal to 0')
+                elif expire > 0:
+                    expire = round(time.time() + expire, 7)
+            else:
+                raise TypeError('"expire" only supported: int or float')
+        return key, value, expire
+
+    def __execute(self, sql: str, parameters: t.Iterable = None) -> None:
+        conn = self.__conn()
+        cursor = conn.cursor()
+        if parameters:
+            cursor.execute(sql, parameters)
+        else:
+            cursor.execute(sql)
+        conn.commit()
+        self.__close(cursor, conn)
+
+    def __close(self, cursor, conn) -> None:
+        cursor.close()
+        conn.close()
+
+    def __new_db(self) -> None:
+        sql = 'create table if not exists {tb}(' \
+              'k text not null primary key, ' \
+              'v text, ' \
+              'expire real)'.format(tb=self.__kvtable)
+        self.__execute(sql)
+
+    def __queryone(self, sql: str, parameters: t.Iterable):
+        conn = self.__conn()
+        cursor = conn.cursor()
+        cursor.execute(sql, parameters)
+        one = cursor.fetchone()
+        value, expire = one if one else (None, 0)
+        self.__close(cursor, conn)
+        return value, expire
+
+    def exists(self, key: str) -> bool:
+        """
+        检测key是否存在
+        :param key:
+        :return:
+        """
+        conn = self.__conn()
+        cursor = conn.cursor()
+        sql = 'select k from {tb} where k=?'.format(tb=self.__kvtable)
+        parameters = (key,)
+        cursor.execute(sql, parameters)
+        result = cursor.fetchone()
+        self.__close(cursor, conn)
+        if not result:
+            return False
+        return True
+
+    def delete(self, key: str) -> None:
+        """
+        删除key
+        :param key:
+        :return:
+        """
+        sql = 'delete from {tb} where k=?'.format(tb=self.__kvtable)
+        parameters = (key,)
+        self.__execute(sql, parameters)
+
+    def clear(self) -> None:
+        """
+        清除所有key-value
+        :return:
+        """
+        sql = 'delete from {tb}'.format(tb=self.__kvtable)
+        self.__execute(sql)
+
+    def remove(self) -> None:
+        """
+        移除KV实例的kvfile文件
+        :return:
+        """
+        os.remove(self.__kvfile)
```

## toollib/locker.py

 * *Ordering differences only*

```diff
@@ -1,116 +1,116 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/10/28 14:03
-@abstract 锁
-@description
-@history
-"""
-import time
-import typing as t
-
-try:
-    from redis.exceptions import WatchError
-except ImportError:
-    raise
-
-__all__ = [
-    'Locker',
-]
-
-
-class Locker:
-    """
-    锁，基于redis的分布式锁
-    使用示例：
-        a = 0
-        locker = Locker(redis_cli)  # 创建锁实例
-        if locker.acquire(acquire_timeout=2)  # 获取锁
-            for i in range(10):
-                a += 1
-                print(f'a: {a}')
-            locker.release()  # 释放锁
-
-        # 另：with方式
-        a = 0
-        locker = Locker(redis_cli, acquire_timeout=2)
-        with locker:
-            if locker.is_lock:  # 若获取锁
-                for i in range(10):
-                    a += 1
-                    print(f'a: {a}')
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(
-            self,
-            redis_cli,
-            acquire_timeout: int = 2,
-            timeout: int = 29,
-            lock_name: str = 'locker',
-            lock_value: str = 'locker!@#',
-    ):
-        """
-        初始化
-        :param redis_cli: redis客户端对象
-        :param acquire_timeout: 获取锁的超时时间
-        :param timeout: 锁的过期时间
-        :param lock_name: 锁名
-        :param lock_value: 锁值
-        """
-        self.rds = redis_cli
-        self.acquire_timeout = acquire_timeout
-        self.timeout = timeout
-        self.lock_name = lock_name if lock_name else 'locker'
-        self.lock_value = lock_value if lock_value else 'locker!@#'
-        self.is_lock = False
-
-    def acquire(self, acquire_timeout: t.Union[int, float] = None, timeout: int = None) -> bool:
-        """
-        获取锁
-        :param acquire_timeout: 获取锁的超时时间
-        :param timeout: 锁的过期时间
-        :return:
-        """
-        if acquire_timeout is not None:
-            self.acquire_timeout = acquire_timeout
-        if timeout is not None:
-            self.timeout = timeout
-        self._acquire_lock()
-        return self.is_lock
-
-    def _acquire_lock(self):
-        end_time = time.time() + self.acquire_timeout
-        while time.time() < end_time:
-            if self.rds.set(self.lock_name, self.lock_value, ex=self.timeout, nx=True):
-                self.is_lock = True
-                break
-            elif self.rds.ttl(self.lock_name) == -1:
-                self.rds.expire(self.lock_name, self.timeout)
-            time.sleep(0.002)
-
-    __enter__ = acquire
-
-    def release(self):
-        """释放锁"""
-        if not self.is_lock:
-            return
-        with self.rds.pipeline() as pipe:
-            while 1:
-                try:
-                    pipe.watch(self.lock_name)
-                    lock_value = pipe.get(self.lock_name)
-                    if isinstance(lock_value, bytes):
-                        lock_value = lock_value.decode()
-                    if not lock_value:
-                        break
-                    elif lock_value == self.lock_value:
-                        pipe.multi()
-                        pipe.delete(self.lock_name)
-                        pipe.execute()
-                        break
-                except WatchError:
-                    pipe.unwatch()
-
-    def __exit__(self, t, v, tb):
-        self.release()
+"""
+@author axiner
+@version v1.0.0
+@created 2022/10/28 14:03
+@abstract 锁
+@description
+@history
+"""
+import time
+import typing as t
+
+try:
+    from redis.exceptions import WatchError
+except ImportError:
+    raise
+
+__all__ = [
+    'Locker',
+]
+
+
+class Locker:
+    """
+    锁，基于redis的分布式锁
+    使用示例：
+        a = 0
+        locker = Locker(redis_cli)  # 创建锁实例
+        if locker.acquire(acquire_timeout=2)  # 获取锁
+            for i in range(10):
+                a += 1
+                print(f'a: {a}')
+            locker.release()  # 释放锁
+
+        # 另：with方式
+        a = 0
+        locker = Locker(redis_cli, acquire_timeout=2)
+        with locker:
+            if locker.is_lock:  # 若获取锁
+                for i in range(10):
+                    a += 1
+                    print(f'a: {a}')
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(
+            self,
+            redis_cli,
+            acquire_timeout: int = 2,
+            timeout: int = 29,
+            lock_name: str = 'locker',
+            lock_value: str = 'locker!@#',
+    ):
+        """
+        初始化
+        :param redis_cli: redis客户端对象
+        :param acquire_timeout: 获取锁的超时时间
+        :param timeout: 锁的过期时间
+        :param lock_name: 锁名
+        :param lock_value: 锁值
+        """
+        self.rds = redis_cli
+        self.acquire_timeout = acquire_timeout
+        self.timeout = timeout
+        self.lock_name = lock_name if lock_name else 'locker'
+        self.lock_value = lock_value if lock_value else 'locker!@#'
+        self.is_lock = False
+
+    def acquire(self, acquire_timeout: t.Union[int, float] = None, timeout: int = None) -> bool:
+        """
+        获取锁
+        :param acquire_timeout: 获取锁的超时时间
+        :param timeout: 锁的过期时间
+        :return:
+        """
+        if acquire_timeout is not None:
+            self.acquire_timeout = acquire_timeout
+        if timeout is not None:
+            self.timeout = timeout
+        self._acquire_lock()
+        return self.is_lock
+
+    def _acquire_lock(self):
+        end_time = time.time() + self.acquire_timeout
+        while time.time() < end_time:
+            if self.rds.set(self.lock_name, self.lock_value, ex=self.timeout, nx=True):
+                self.is_lock = True
+                break
+            elif self.rds.ttl(self.lock_name) == -1:
+                self.rds.expire(self.lock_name, self.timeout)
+            time.sleep(0.002)
+
+    __enter__ = acquire
+
+    def release(self):
+        """释放锁"""
+        if not self.is_lock:
+            return
+        with self.rds.pipeline() as pipe:
+            while 1:
+                try:
+                    pipe.watch(self.lock_name)
+                    lock_value = pipe.get(self.lock_name)
+                    if isinstance(lock_value, bytes):
+                        lock_value = lock_value.decode()
+                    if not lock_value:
+                        break
+                    elif lock_value == self.lock_value:
+                        pipe.multi()
+                        pipe.delete(self.lock_name)
+                        pipe.execute()
+                        break
+                except WatchError:
+                    pipe.unwatch()
+
+    def __exit__(self, t, v, tb):
+        self.release()
```

## toollib/py2pyder.py

 * *Ordering differences only*

```diff
@@ -1,136 +1,136 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2023/4/7 15:14
-@abstract py转pyd
-@description
-@history
-"""
-import os
-import re
-import shutil
-import subprocess
-import sys
-
-from toollib.common import constor
-from toollib.utils import listfile
-
-try:
-    from Cython.Build import cythonize
-except ImportError:
-    sys.stderr.write("ERROR: No module named 'Cython'\n")
-    sys.exit(1)
-
-__all__ = ['Py2Pyder']
-
-
-class Py2Pyder:
-    """
-    py转pyd
-    使用示例：
-        py2pyder = Py2Pyder(src=r'D:\pyprj', exclude=r'main.py|tests/')
-        py2pyder.run()
-        - 提醒：
-            - 自动跳过: __init__.py, 空文件，只存在注释的文件，当然还有非py文件
-            - 若编译不成功或编译后执行不成功：
-                - 确保python代码的正确性与严谨性
-                - 编译失败的，Pyd目录下对应的源文件不会删除
-                - 编译后的文件执行，需要与编译时的python版本、操作系统一致
-                - 实在编译不了或执行不了，可加入exclude用源文件代替
-            - exclude: 排除编译（适用正则）
-                - 文件夹加正斜杠'/'即可，如：tests/, tests/a/
-                - 多个则用'|'隔开，如：main.py|tests/
-                - 项目的入口文件一般是不编译的，加入exclude即可
-            - 输出：Pyd目录（默认源+Pyd），该目录与src结构一致
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(
-            self,
-            src: str,
-            postfix: str = 'Pyd',
-            exclude: str = None,
-            ignore: str = '.git,.idea,__pycache__',
-            clean: bool = False,
-    ):
-        """
-        初始化
-        :param src: 源（py目录或文件）
-        :param postfix: 后缀（默认为Pyd）
-        :param exclude: 排除编译（适用正则）
-        :param ignore: 忽略复制（多个逗号隔开）
-        :param clean: 清理临时
-        """
-        self.src = os.path.abspath(src)
-        if os.path.isdir(self.src):
-            self.src_is_dir = True
-            self.dest = self.src + (postfix or 'Pyd')
-        elif os.path.isfile(self.src):
-            self.src_is_dir = False
-            if self.src.endswith('.py'):
-                self.dest = os.path.join(
-                    os.path.dirname(self.src),
-                    os.path.basename(self.src)[:-3] + (postfix or 'Pyd'))
-            else:
-                sys.stderr.write(f'ERROR: Only supported py, not {src.split(".")[-1]}\n')
-                sys.exit(1)
-        else:
-            sys.stderr.write(f'ERROR: {src} does not exist\n')
-            sys.exit(1)
-        self.exclude = exclude
-        self.ignore = ignore
-        self.clean = clean
-        self.setuppy = os.path.join(self.dest, '.setuppy')
-
-    def run(self):
-        """执行"""
-        self._init_setup()
-        self._build()
-
-    def _init_setup(self):
-        if not os.path.isdir(self.dest):
-            os.mkdir(self.dest)
-        if self.src_is_dir:
-            ignore_cp = shutil.ignore_patterns(*self.ignore.split(',')) if self.ignore else None
-            shutil.copytree(self.src, self.dest, ignore=ignore_cp, dirs_exist_ok=True)
-        else:
-            shutil.copy(self.src, self.dest)
-        with open(self.setuppy, 'wb') as fp:
-            fp.write(constor.pyd_setup)
-
-    def _build(self):
-        os.chdir(self.dest)
-        _ = len(self.dest)
-        for pyfile in listfile(self.dest, '*.py', is_str=True, is_r=True):
-            if pyfile.endswith('__init__.py'):
-                print(f'跳过init：{pyfile}')
-                continue
-            if os.path.getsize(pyfile) == 0:
-                print(f'跳过为空：{pyfile}')
-                continue
-            with open(pyfile, 'r', encoding='utf8') as fp:
-                content = re.compile(r'^\s*""".*?"""', re.DOTALL | re.MULTILINE).sub(
-                    '', re.compile(r'^\s*#.*$', re.MULTILINE).sub(
-                        '', fp.read())).strip()
-                if not content:
-                    print(f'跳过注释：{pyfile}')
-                    continue
-            rpyfile = pyfile[_:].lstrip('/')
-            if self.exclude and re.search(self.exclude, rpyfile):
-                print(f'跳过排除：{pyfile}')
-                continue
-            print(f'正在处理：{pyfile}')
-            result = subprocess.run([
-                'python', self.setuppy, 'build_ext', '-i',
-                pyfile.replace('/', os.sep),
-                rpyfile[:-3].replace('/', '.'),
-            ])
-            if result.returncode == 0:
-                os.remove(pyfile)
-            cpyfile = pyfile[:-3] + '.c'
-            if os.path.isfile(cpyfile):
-                os.remove(cpyfile)
-        if self.clean is True:
-            subprocess.run(['python', self.setuppy, 'clean', 'xxx', 'xxx'])
-            shutil.rmtree(os.path.join(self.dest, 'build'), ignore_errors=True)
-        os.remove(self.setuppy)
+"""
+@author axiner
+@version v1.0.0
+@created 2023/4/7 15:14
+@abstract py转pyd
+@description
+@history
+"""
+import os
+import re
+import shutil
+import subprocess
+import sys
+
+from toollib.common import constor
+from toollib.utils import listfile
+
+try:
+    from Cython.Build import cythonize
+except ImportError:
+    sys.stderr.write("ERROR: No module named 'Cython'\n")
+    sys.exit(1)
+
+__all__ = ['Py2Pyder']
+
+
+class Py2Pyder:
+    """
+    py转pyd
+    使用示例：
+        py2pyder = Py2Pyder(src=r'D:\pyprj', exclude=r'main.py|tests/')
+        py2pyder.run()
+        - 提醒：
+            - 自动跳过: __init__.py, 空文件，只存在注释的文件，当然还有非py文件
+            - 若编译不成功或编译后执行不成功：
+                - 确保python代码的正确性与严谨性
+                - 编译失败的，Pyd目录下对应的源文件不会删除
+                - 编译后的文件执行，需要与编译时的python版本、操作系统一致
+                - 实在编译不了或执行不了，可加入exclude用源文件代替
+            - exclude: 排除编译（适用正则）
+                - 文件夹加正斜杠'/'即可，如：tests/, tests/a/
+                - 多个则用'|'隔开，如：main.py|tests/
+                - 项目的入口文件一般是不编译的，加入exclude即可
+            - 输出：Pyd目录（默认源+Pyd），该目录与src结构一致
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(
+            self,
+            src: str,
+            postfix: str = 'Pyd',
+            exclude: str = None,
+            ignore: str = '.git,.idea,__pycache__',
+            clean: bool = False,
+    ):
+        """
+        初始化
+        :param src: 源（py目录或文件）
+        :param postfix: 后缀（默认为Pyd）
+        :param exclude: 排除编译（适用正则）
+        :param ignore: 忽略复制（多个逗号隔开）
+        :param clean: 清理临时
+        """
+        self.src = os.path.abspath(src)
+        if os.path.isdir(self.src):
+            self.src_is_dir = True
+            self.dest = self.src + (postfix or 'Pyd')
+        elif os.path.isfile(self.src):
+            self.src_is_dir = False
+            if self.src.endswith('.py'):
+                self.dest = os.path.join(
+                    os.path.dirname(self.src),
+                    os.path.basename(self.src)[:-3] + (postfix or 'Pyd'))
+            else:
+                sys.stderr.write(f'ERROR: Only supported py, not {src.split(".")[-1]}\n')
+                sys.exit(1)
+        else:
+            sys.stderr.write(f'ERROR: {src} does not exist\n')
+            sys.exit(1)
+        self.exclude = exclude
+        self.ignore = ignore
+        self.clean = clean
+        self.setuppy = os.path.join(self.dest, '.setuppy')
+
+    def run(self):
+        """执行"""
+        self._init_setup()
+        self._build()
+
+    def _init_setup(self):
+        if not os.path.isdir(self.dest):
+            os.mkdir(self.dest)
+        if self.src_is_dir:
+            ignore_cp = shutil.ignore_patterns(*self.ignore.split(',')) if self.ignore else None
+            shutil.copytree(self.src, self.dest, ignore=ignore_cp, dirs_exist_ok=True)
+        else:
+            shutil.copy(self.src, self.dest)
+        with open(self.setuppy, 'wb') as fp:
+            fp.write(constor.pyd_setup)
+
+    def _build(self):
+        os.chdir(self.dest)
+        _ = len(self.dest)
+        for pyfile in listfile(self.dest, '*.py', is_str=True, is_r=True):
+            if pyfile.endswith('__init__.py'):
+                print(f'跳过init：{pyfile}')
+                continue
+            if os.path.getsize(pyfile) == 0:
+                print(f'跳过为空：{pyfile}')
+                continue
+            with open(pyfile, 'r', encoding='utf8') as fp:
+                content = re.compile(r'^\s*""".*?"""', re.DOTALL | re.MULTILINE).sub(
+                    '', re.compile(r'^\s*#.*$', re.MULTILINE).sub(
+                        '', fp.read())).strip()
+                if not content:
+                    print(f'跳过注释：{pyfile}')
+                    continue
+            rpyfile = pyfile[_:].lstrip('/')
+            if self.exclude and re.search(self.exclude, rpyfile):
+                print(f'跳过排除：{pyfile}')
+                continue
+            print(f'正在处理：{pyfile}')
+            result = subprocess.run([
+                'python', self.setuppy, 'build_ext', '-i',
+                pyfile.replace('/', os.sep),
+                rpyfile[:-3].replace('/', '.'),
+            ])
+            if result.returncode == 0:
+                os.remove(pyfile)
+            cpyfile = pyfile[:-3] + '.c'
+            if os.path.isfile(cpyfile):
+                os.remove(cpyfile)
+        if self.clean is True:
+            subprocess.run(['python', self.setuppy, 'clean', 'xxx', 'xxx'])
+            shutil.rmtree(os.path.join(self.dest, 'build'), ignore_errors=True)
+        os.remove(self.setuppy)
```

## toollib/redis_cli.py

 * *Ordering differences only*

```diff
@@ -1,80 +1,80 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/10/28 14:23
-@abstract redis
-@description
-@history
-"""
-try:
-    import redis
-except ImportError:
-    raise
-
-__all__ = ['RedisCli']
-
-
-class RedisCli:
-    """
-    redis客户端
-    使用示例：
-        1) 单个连接使用
-        r = RedisCli(host='127.0.0.1')
-        # 或
-        with RedisCli(host='127.0.0.1') as r:
-            pass
-        2）以连接池的方式
-        2.1）创建连接池
-        redis_cli = RedisCli(host='127.0.0.1', max_connections=100)
-        redis_conn = redis_cli.connection
-        2.2）调用连接（每次获取连接池中连接）
-        r = redis_conn()
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(
-            self,
-            host="localhost",
-            port=6379,
-            db=0,
-            password=None,
-            max_connections=None,
-            **kwargs,
-    ):
-        """
-        初始化
-        :param host: host
-        :param port: 端口
-        :param db: 数据库
-        :param password: 密码
-        :param max_connections: 最大连接数
-        :param kwargs: 其他参数
-        """
-        self._redis_pool = redis.ConnectionPool(
-            host=host,
-            port=port,
-            db=db,
-            password=password,
-            max_connections=max_connections,
-            **kwargs,
-        )
-        self.__conn = redis.StrictRedis(connection_pool=self._redis_pool)
-
-    def connection(self):
-        """创建连接"""
-        self.__conn = redis.StrictRedis(connection_pool=self._redis_pool)
-        return self.__conn
-
-    def __getattr__(self, cmd):
-        def exec_cmd(*args, **kwargs):
-            return getattr(self.__conn, cmd)(*args, **kwargs)
-        return exec_cmd
-
-    def __enter__(self):
-        return self.__conn
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        if exc_type is None:
-            self.__conn.close()
-        else:
-            return True
+"""
+@author axiner
+@version v1.0.0
+@created 2022/10/28 14:23
+@abstract redis
+@description
+@history
+"""
+try:
+    import redis
+except ImportError:
+    raise
+
+__all__ = ['RedisCli']
+
+
+class RedisCli:
+    """
+    redis客户端
+    使用示例：
+        1) 单个连接使用
+        r = RedisCli(host='127.0.0.1')
+        # 或
+        with RedisCli(host='127.0.0.1') as r:
+            pass
+        2）以连接池的方式
+        2.1）创建连接池
+        redis_cli = RedisCli(host='127.0.0.1', max_connections=100)
+        redis_conn = redis_cli.connection
+        2.2）调用连接（每次获取连接池中连接）
+        r = redis_conn()
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(
+            self,
+            host="localhost",
+            port=6379,
+            db=0,
+            password=None,
+            max_connections=None,
+            **kwargs,
+    ):
+        """
+        初始化
+        :param host: host
+        :param port: 端口
+        :param db: 数据库
+        :param password: 密码
+        :param max_connections: 最大连接数
+        :param kwargs: 其他参数
+        """
+        self._redis_pool = redis.ConnectionPool(
+            host=host,
+            port=port,
+            db=db,
+            password=password,
+            max_connections=max_connections,
+            **kwargs,
+        )
+        self.__conn = redis.StrictRedis(connection_pool=self._redis_pool)
+
+    def connection(self):
+        """创建连接"""
+        self.__conn = redis.StrictRedis(connection_pool=self._redis_pool)
+        return self.__conn
+
+    def __getattr__(self, cmd):
+        def exec_cmd(*args, **kwargs):
+            return getattr(self.__conn, cmd)(*args, **kwargs)
+        return exec_cmd
+
+    def __enter__(self):
+        return self.__conn
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        if exc_type is None:
+            self.__conn.close()
+        else:
+            return True
```

## toollib/regexp.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/8 20:37
-@abstract 正则表达式
-@description
-    有以下正则表达式：
-        1）中文，regexp.zh
-        2）表情：regexp.emoji
-
-        3）手机号：regexp.phone
-        4）座机号（有‘-’）：regexp.landline
-        5）座机号（‘-’可有可无）：regexp.landline2
-        6）手机号和座机号：regexp.phone_and_landline
-
-        7）邮箱：regexp.email
-        8）邮箱（可含中文字符）：regexp.email_contain_zh
-
-        9）ipv4: regexp.ipv4
-        10）ipv4（粗匹配）: regexp.ipv4_simple
-        11）ipv6（粗匹配）: regexp.ipv6_simple
-
-        12）url: regexp.url
-@history
-"""
-# 易混淆
-# 1）*: 0次、1次或多次匹配其前的原子
-# 2）+: 1次或多次匹配其前的原子
-# 3）?: 0次或1次匹配其前的原子
-# 4）.: 匹配除换行之外的任何一个字符
-# --------------------
-zh = r'[\u4e00-\u9fa5]+'
-emoji = r'[\u0000-\uFFFF]+'
-
-phone = r'1\d{10}'
-landline = r'\d{3}-\d{8}|\d{4}-\d{7}'
-landline2 = r'\d{3}-?\d{8}|\d{4}-?\d{7}'
-phone_and_landline = landline2
-
-email = r'[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+'
-email_contain_zh = r'[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+'
-
-ipv4 = r'(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'
-ipv4_simple = r'(?:[0-9]{1,3}\.){3}[0-9]{1,3}'
-ipv6_simple = r'(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}'
-
-url = r'(?:https?|ftp|file)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]'
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/8 20:37
+@abstract 正则表达式
+@description
+    有以下正则表达式：
+        1）中文，regexp.zh
+        2）表情：regexp.emoji
+
+        3）手机号：regexp.phone
+        4）座机号（有‘-’）：regexp.landline
+        5）座机号（‘-’可有可无）：regexp.landline2
+        6）手机号和座机号：regexp.phone_and_landline
+
+        7）邮箱：regexp.email
+        8）邮箱（可含中文字符）：regexp.email_contain_zh
+
+        9）ipv4: regexp.ipv4
+        10）ipv4（粗匹配）: regexp.ipv4_simple
+        11）ipv6（粗匹配）: regexp.ipv6_simple
+
+        12）url: regexp.url
+@history
+"""
+# 易混淆
+# 1）*: 0次、1次或多次匹配其前的原子
+# 2）+: 1次或多次匹配其前的原子
+# 3）?: 0次或1次匹配其前的原子
+# 4）.: 匹配除换行之外的任何一个字符
+# --------------------
+zh = r'[\u4e00-\u9fa5]+'
+emoji = r'[\u0000-\uFFFF]+'
+
+phone = r'1\d{10}'
+landline = r'\d{3}-\d{8}|\d{4}-\d{7}'
+landline2 = r'\d{3}-?\d{8}|\d{4}-?\d{7}'
+phone_and_landline = landline2
+
+email = r'[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+'
+email_contain_zh = r'[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+'
+
+ipv4 = r'(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'
+ipv4_simple = r'(?:[0-9]{1,3}\.){3}[0-9]{1,3}'
+ipv6_simple = r'(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}'
+
+url = r'(?:https?|ftp|file)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]'
```

## toollib/useragent.py

 * *Ordering differences only*

```diff
@@ -1,1057 +1,1057 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/8 20:36
-@abstract 用户代理
-@description
-    有以下属性：
-        1）uas列表1000条：useragent.uas
-        2）从1000条uas中随机选1条：useragent.random_ua
-        3）生成uas: useragent.gen_uas()
-@history
-"""
-import random
-import re
-import typing as t
-
-__all__ = [
-    'uas',
-    'random_ua',
-    'gen_uas',
-]
-
-uas = [
-    'Mozilla/5.0 (compatible; U; ABrowse 0.6; Syllable) AppleWebKit/420+ (KHTML, like Gecko)',
-    'Mozilla/5.0 (compatible; U; ABrowse 0.6;  Syllable) AppleWebKit/420+ (KHTML, like Gecko)',
-    'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser 1.98.744; .NET CLR 3.5.30729)',
-    'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser 1.98.744; .NET CLR   3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0;   Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;   SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; Acoo Browser; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; Avant Browser)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1;   .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Maxthon; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser 1.98.744; .NET CLR 3.5.30729); Windows NT 5.1; Trident/4.0)',
-    'Mozilla/4.0 (compatible; Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6; Acoo Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727); Windows NT 5.1; Trident/4.0; Maxthon; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser; GTB6; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6; Acoo Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; GTB5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Acoo Browser; InfoPath.2; .NET CLR 2.0.50727; Alexa Toolbar)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Acoo Browser; .NET CLR 2.0.50727; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Acoo Browser; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727; FDM; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; Acoo Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; Windows NT 5.1; (R1 1.5); .NET CLR 2.0.50727; InfoPath.1)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; InfoPath.1; .NET CLR 2.0.50727; Media Center PC 3.0; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.2; Windows NT 5.1; SV1; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; HbTools 4.7.0)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.1.4322; InfoPath.1; HbTools 4.8.0)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 3.1)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.1.4322; HbTools 4.7.1)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 3.1)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; FunWebProducts; (R1 1.5); HbTools 4.7.7)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; FunWebProducts)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; SV1; .NET CLR 1.1.4322; InfoPath.1)',
-    'Mozilla/5.0 (compatible; MSIE 9.0; AOL 9.7; AOLBuild 4343.19; Windows NT 6.1; WOW64; Trident/5.0; FunWebProducts)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.27; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.21; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.19; Windows NT 5.1; Trident/4.0; GTB7.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.19; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.7; AOLBuild 4343.19; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5004; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5001; Windows NT 5.1; Trident/4.0)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5000; Windows NT 5.1; Trident/4.0; FunWebProducts)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5000; Windows NT 5.1; Trident/4.0; .NET4.0C; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.27; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.27; Windows NT 5.1; Trident/4.0; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.17; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.168; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; MS-RTC LM 8)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.168; Windows NT 5.1; Trident/4.0; GTB7.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.130; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.130; Windows NT 5.1; Trident/4.0; FunWebProducts; GTB6.6; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; yie8)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.12; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.12; Windows NT 5.1; Trident/4.0; GTB6.3)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.124; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.122; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; MS-RTC LM 8)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.122; Windows NT 5.1; Trident/4.0; FunWebProducts)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.111; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.110; Windows NT 5.1; Trident/4.0; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.104; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.6; AOLBuild 4340.128; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.5; AOLBuild 4337.43; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.21022; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.5; AOLBuild 4337.29; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.21022; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.93; Windows NT 5.1; Trident/4.0; DigExt; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.89; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.81; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.81; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618) (Compatible;  ;  ; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET ',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.81; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.80; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.53; Windows NT 6.0; FunWebProducts; GTB6; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.43; Windows NT 6.0; WOW64; GTB5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.43; Windows NT 5.1; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.43; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.42; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 6.0; FunWebProducts; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 5.1; Trident/4.0; GTB6; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.36; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30618; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.36; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.36; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/5.0 (compatible; MSIE 9.0; AOL 9.1; AOLBuild 4334.5012; Windows NT 6.0; WOW64; Trident/5.0)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.1; AOLBuild 4334.5011; Windows NT 6.1; WOW64; Trident/4.0; GTB7.2; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5010; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5009; Windows NT 5.1; GTB5; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; Trident/4.0; DigExt; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; GTB5; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5000; Windows NT 5.1; Trident/4.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5000; Windows NT 5.1; Media Center PC 3.0; .NET CLR 1.0.3705; .NET CLR 1.1.4322; InfoPath.1)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.36; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 5.1; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.27; Windows NT 6.0; WOW64; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506; Media Center PC 5.0); UnAuth-State',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.27; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506); UnAuth-State',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.27; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; InfoPath.1); UnAuth-State',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4327.65535; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727); UnAuth-State',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.0; AOLBuild 4327.5201; Windows NT 6.0; WOW64; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.2; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Trident/4.0; FunWebProducts; GTB6.4; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 1.1.4322; .NET CLR 3.5.30729; OfficeLiveConnector.1.3; OfficeLivePatch.0.0; .NET CLR 3.0.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; Seekmo 10.0.406.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; FunWebProducts; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.2; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; FunWebProducts; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; Seekmo 10.0.341.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; FunWebProducts; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; Trident/4.0; GTB6; FunWebProducts; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 1.1.4322; .NET CLR 2.0.50727; OfficeLiveConnector.1.3; OfficeLivePatch.0.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 1.0.3705; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; FunWebProducts; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) )',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; GTB5; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.1; .NET CLR 3.0.04506.30)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; YComp 5.0.0.0; .NET CLR 1.0.3705)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; SV1; (R1 1.3); .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; FunWebProducts; SV1; .NET CLR 1.0.3705)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 7.0; Windows NT 5.1) (Compatible;  ;  ; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; YComp 5.0.2.6; Hotbar 4.2.8.0)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; SV1; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; Q312461; YComp 5.0.0.0)',
-    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows 98; Win 9x 4.90; .NET CLR 1.1.4322)',
-    'Mozilla/5.0 (X11; U; UNICOS lcLinux; en-US) Gecko/20140730 (KHTML, like Gecko, Safari/419.3) Arora/0.8.0',
-    'Mozilla/5.0 (X11; U; Linux; de-DE) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.8.0',
-    'Mozilla/5.0 (Windows; U; ; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.8.0',
-    'Mozilla/5.0 (Windows; U; ; en-NZ) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.8.0',
-    'Mozilla/5.0 (Windows; U; ; en-EN) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.8.0',
-    'Mozilla/5.0 (X11; U; Linux; ru-RU) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change: 802 025a17d)',
-    'Mozilla/5.0 (X11; U; Linux; fi-FI) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change: 754 46b659a)',
-    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6',
-    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change:  )',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change:  )',
-    'Mozilla/5.0 (X11; U; Linux; pt-PT) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; nb-NO) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; it-IT) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 413 12f13f8)',
-    'Mozilla/5.0 (X11; U; Linux; it-IT) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; hu-HU) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 388 835b3b6)',
-    'Mozilla/5.0 (X11; U; Linux; hu-HU) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; fr-FR) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; es-ES) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 388 835b3b6)',
-    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; en-GB) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 388 835b3b6)',
-    'Mozilla/5.0 (X11; U; Linux; en-GB) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; de-DE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
-    'Mozilla/5.0 (X11; U; Linux; cs-CZ) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 333 41e3bc6)',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; de-DE) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; pt-BR) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; de-DE) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
-    'Mozilla/5.0 (X11; U; Linux; en-GB) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 239 52c6958)',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 287 c9dfb30)',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; fr-BE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 287 c9dfb30)',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 287 c9dfb30)',
-    'Mozilla/5.0 (X11; U; Linux; sk-SK) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
-    'Mozilla/5.0 (X11; U; Linux; nb-NO) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
-    'Mozilla/5.0 (X11; U; Linux; es-CR) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
-    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 189 35c14e0)',
-    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
-    'Mozilla/5.0 (X11; U; Linux; de-DE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; de-DE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; nl-NL) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; de-CH) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Arora/0.11.0 Safari/533.3',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.34 (KHTML, like Gecko) Arora/0.11.0 Safari/534.34',
-    'Mozilla/5.0 (X11; U; Linux; pl-PL) AppleWebKit/532.4 (KHTML, like Gecko) Arora/0.10.2 Safari/532.4',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.34 (KHTML, like Gecko) Arora/0.10.2 Safari/534.34',
-    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527  (KHTML, like Gecko, Safari/419.3) Arora/0.10.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-MY) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.10.0',
-    'Mozilla/5.0 (Windows; U; ; hu-HU) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.10.0',
-    'Mozilla/5.0 (Windows; U; ; hu-HU) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.10.0',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; Avant Browser; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; InfoPath.1)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6.4; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; chromeframe; Avant Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; InfoPath.1; .NET CLR 3.0.4506.',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB5; Avant Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; Avant Browser; Avant Browser; .NET CLR 2.0.50727)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT; Avant Browser; Avant Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E; Avant Browser)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0; Avant Browser; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; WOW64; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; GTB6.3; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 1.1.4322; .NET CLR 3.5.30729; .NET CLR 3.0.30729',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; InfoPath.1)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322; InfoPath.2)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; InfoPath.2; OfficeLiveConnector.1.3; OfficeLivePatch.0.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; Tablet PC 2.0)',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
-    'Mozilla/5.0 (X11; U; Linux i686; nl; rv:1.8.1b2) Gecko/20060821 BonEcho/2.0b2 (Debian-1.99+2.0b2+dfsg-1)',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1b2) Gecko/20060826 BonEcho/2.0b2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.8.1b2) Gecko/20060831 BonEcho/2.0b2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-GB; rv:1.8.1b1) Gecko/20060601 BonEcho/2.0b1 (Ubuntu-edgy)',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1a3) Gecko/20060526 BonEcho/2.0a3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-GB; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X Mach-O; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
-    'Mozilla/5.0 (X11; U; OpenBSD ppc; en-US; rv:1.8.1.9) Gecko/20070223 BonEcho/2.0.0.9',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.9) Gecko/20071103 BonEcho/2.0.0.9',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.9) Gecko/20071113 BonEcho/2.0.0.9',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.8pre) Gecko/20071012 BonEcho/2.0.0.8pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.7pre) Gecko/20070901 BonEcho/2.0.0.7pre',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.7) Gecko/20070918 BonEcho/2.0.0.7',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.7) Gecko/20071018 BonEcho/2.0.0.7',
-    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.7) Gecko/20070917 BonEcho/2.0.0.7',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.6) Gecko/20070812 BonEcho/2.0.0.6',
-    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.6) Gecko/20070731 BonEcho/2.0.0.6',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; de; rv:1.8.1.5pre) Gecko/20070604 BonEcho/2.0.0.5pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.5pre) Gecko/20070622 BonEcho/2.0.0.5pre',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.4pre) Gecko/20070414 BonEcho/2.0.0.4pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1.4pre) Gecko/20070510 BonEcho/2.0.0.4pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4pre) Gecko/20070416 BonEcho/2.0.0.4pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4pre) Gecko/20070410 BonEcho/2.0.0.4pre',
-    'Mozilla/5.0 (X11; U; OpenBSD ppc; en-US; rv:1.8.1.4) Gecko/20070223 BonEcho/2.0.0.4',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.4) Gecko/20070531 BonEcho/2.0.0.4',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4) Gecko/20070416 BonEcho/2.0.0.4',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1.3pre) Gecko/20070302 BonEcho/2.0.0.3pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.3pre) Gecko/20070302 BonEcho/2.0.0.3pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.8.1.3pre) Gecko/20070301 BonEcho/2.0.0.3pre',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.3) Gecko/20070517 BonEcho/2.0.0.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.9a3) Gecko/20070409 BonEcho/2.0.0.3',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1.3) Gecko/20070329 BonEcho/2.0.0.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.3) Gecko/20070322 BonEcho/2.0.0.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1.2pre) Gecko/20070226 BonEcho/2.0.0.2pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070213 BonEcho/2.0.0.2pre',
-    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.21pre) Gecko/20090218 BonEcho/2.0.0.21pre',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.2) Gecko/20070302 BonEcho/2.0.0.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.2) Gecko/20070224 BonEcho/2.0.0.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2) Gecko/20070227 BonEcho/2.0.0.2',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1.2) Gecko/20070223 BonEcho/2.0.0.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1pre) Gecko/20061203 BonEcho/2.0.0.1pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1pre) Gecko/20061202 BonEcho/2.0.0.1pre',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1pre) Gecko/20061122 BonEcho/2.0.0.1pre',
-    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.18) Gecko/20081114 BonEcho/2.0.0.18',
-    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.17) Gecko/20080831 BonEcho/2.0.0.17',
-    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.17) Gecko/20080831 BonEcho/2.0.0.17',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.14) Gecko/20080417 BonEcho/2.0.0.14',
-    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.14) Gecko/20080429 BonEcho/2.0.0.14',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.13) Gecko/20080401 BonEcho/2.0.0.13',
-    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US; rv:1.8.1.12pre) Gecko/20080103 BonEcho/2.0.0.12pre',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.12) Gecko/20080208 BonEcho/2.0.0.12',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.12) Gecko/20080321 BonEcho/2.0.0.12 (SliTaz GNU/Linux)',
-    'Mozilla/5.0 (X11; U; SunOS sun4u; en-US; rv:1.8.1.11) Gecko/20080208 BonEcho/2.0.0.11',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.11) Gecko/20071204 BonEcho/2.0.0.11',
-    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.10) Gecko/20071128 BonEcho/2.0.0.10',
-    'Mozilla/5.0 (X11; U; Linux ppc; en-US; rv:1.8.1.1) Gecko/20061219 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux mips; en-US; rv:1.8.1.1) Gecko/20070628 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en; rv:1.8.1.1) Gecko/20070117 Epiphany/2.16 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070222 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070220 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070217 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070215 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070115 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-GB; rv:1.8.1.1) Gecko/20070110 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US; rv:1.8.1.1) Gecko/20070131 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061222 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.8.1.1) Gecko/20061230 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.1) Gecko/20061220 BonEcho/2.0.0.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061210 BonEcho/2.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061209 BonEcho/2.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061121 BonEcho/2.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061113 BonEcho/2.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061112 BonEcho/2.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20060930 BonEcho/2.0',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061026 BonEcho/2.0',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061025 BonEcho/2.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1) Gecko/20061024 BonEcho/2.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en; rv:1.9a1) Gecko/20061128 BonEcho/0.7b1',
-    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; Browzar)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; XH; rv:8.578.498) fr, Gecko/20121021 Camino/8.723+ (Firefox compatible)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; XH; rv:8.578.498) fr, Gecko/20121021 Camino/8.443+ (Firefox compatible)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.8; it; rv:1.9.2.28) Gecko/20130628 Camino/3.245.226 (MultiLang) (like Firefox/3.621.218)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.8; it; rv:1.93.26.2658) Gecko/20141026 Camino/2.176.223 (MultiLang) (like Firefox/3.64.2268)0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.2.14pre) Gecko/20101212 Camino/2.1a1pre (like Firefox/3.6.14pre)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.2.14pre)   Gecko/20101212 Camino/2.1a1pre (like Firefox/3.6.14pre)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.2.29pre) Gecko/20130101 Camino/2.1.3pre (like Firefox/3.6.29pre)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; de; rv:1.9.2.28) Gecko/20120308 Camino/2.1.2 (MultiLang) (like Firefox/3.6.28)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.8; it; rv:1.9.2.28) Gecko/20120308 Camino/2.1.2 (MultiLang) (like Firefox/3.6.28)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; fr; rv:1.9.2.28) Gecko/20120308 Camino/2.1.2 (MultiLang) (like Firefox/3.6.28)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.4; en; rv:1.9.2.24) Gecko/20111114 Camino/2.1 (like Firefox/3.6.24)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en; rv:1.9.0.8pre) Gecko/2009022800 Camino/2.0b3pre',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en; rv:1.9.0.10pre) Gecko/2009041800 Camino/2.0b3pre (like Firefox/3.0.10pre)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; it; rv:1.9.0.19) Gecko/2010111021 Camino/2.0.6 (MultiLang) (like Firefox/3.0.19)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.0.19) Gecko/2010111021 Camino/2.0.6 (MultiLang) (like Firefox/3.0.19)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.4; en; rv:1.9.0.19) Gecko/2010051911 Camino/2.0.3 (like Firefox/3.0.19)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; nl; rv:1.9.0.19) Gecko/2010051911 Camino/2.0.3 (MultiLang) (like Firefox/3.0.19)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.0.18) Gecko/2010021619 Camino/2.0.2 (like Firefox/3.0.18)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.4pre) Gecko/20070511 Camino/1.6pre',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; de; rv:1.8.1.5pre) Gecko/20070605 Camino/1.6a1pre',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4pre) Gecko/20070526 Camino/1.6a1pre',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4pre) Gecko/20070521 Camino/1.6a1pre',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; it; rv:1.8.1.21) Gecko/20090327 Camino/1.6.7 (MultiLang) (like Firefox/2.0.0.21pre)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; fr; rv:1.8.1.21) Gecko/20090327 Camino/1.6.7 (MultiLang) (like Firefox/2.0.0.21pre)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.21) Gecko/20090327 Camino/1.6.7 (like Firefox/2.0.0.21pre)',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.24) Gecko/20100305 Camino/1.6.11 (like Firefox/2.0.0.24)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.12) Gecko/20080206 Camino/1.5.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X Mach-O; en; rv:1.8.1.12) Gecko/20080206 Camino/1.5.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.11) Gecko/20071128 Camino/1.5.4',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Firefox/2.0.0.6 Camino/1.5.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6 Camino/1.5.1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.4) Gecko/20070509 Camino/1.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4) Gecko/20070609 Camino/1.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4) Gecko/20070607 Camino/1.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4) Gecko/20070509 Camino/1.5',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.9a4pre) Gecko/20070404 Camino/1.2+',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4pre) Gecko/20070417 Camino/1.1b+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.2pre) Gecko/20070227 Camino/1.1b',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.2pre) Gecko/20070223 Camino/1.1b',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.2pre) Gecko/20070108 Camino/1.1a2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.1pre) Gecko/20061126 Camino/1.1a1+',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1) Gecko/20061018 Camino/1.1a1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.1) Gecko/20060203 Camino/1.0rc1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.1) Gecko/20060119 Camino/1.0b2+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8) Gecko/20051229 Camino/1.0b2',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8) Gecko/20051228 Camino/1.0b1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8) Gecko/20051107 Camino/1.0b1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8b4) Gecko/20050914 Camino/1.0a1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.10) Gecko/20070228 Camino/1.0.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.10) Gecko/20070228 Camino/1.0.4',
-    'Mozilla/5.0 (Macintosh; U; PPC Max OS X Mach-O; it-IT; rv:1.8.0.7) Gecko/200609211 Camino/1.0.3',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.7) Gecko/20060911 Camino/1.0.3 (MultiLang)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.7) Gecko/20060911 Camino/1.0.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.7) Gecko/20060911 Camino/1.0.3',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.4) Gecko/20060613 Camino/1.0.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.4) Gecko/20060613 Camino/1.0.2',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.3) Gecko/20060503 Camino/1.0.1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.3) Gecko/20060427 Camino/1.0.1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1b1) Gecko/20060807 Camino/1.0+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1b1) Gecko/20060721 Camino/1.0+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1a3) Gecko/20060528 Camino/1.0+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061013 Camino/1.0+ (Firefox compatible)',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061013 Camino/1.0+',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1a3) Gecko/20060601 Camino/1.0+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.1) Gecko/20060307 Camino/1.0',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.1) Gecko/20060214 Camino/1.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8b5) Gecko/20051021 Camino/1.0+',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.1) Gecko/20060214 Camino/1.0',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8b2) Gecko Camino/0.9+',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7) Gecko/20040517 Camino/0.8b',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.8) Gecko/20050427 Camino/0.8.4',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030306 Camino/0.7',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.8 (KHTML, like Gecko, Safari) Cheshire/1.0.UNOFFICIAL',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko, Safari) Cheshire/1.0.UNOFFICIAL',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/419 (KHTML, like Gecko, Safari/419.3) Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Safari) Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko, Safari/111) Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko, Safari) Safari/419.3 Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko) Safari/419.3 Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko) AppleWebKit/418.9 Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/419 (KHTML, like Gecko, Safari/419.3) Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/419 (KHTML, like Gecko, Safari/125) Cheshire/1.0.ALPHA',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; pl-PL; rv:1.0.1) Gecko/20021111 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; pl-PL; rv:1.0.1)   Gecko/20021111 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-US; rv:1.0.1) Gecko/20021111 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-US; rv:1.0.1) Gecko/20021104 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030111 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030109 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20021220 Chimera/0.6',
-    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20021216 Chimera/0.6',
-    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
-    'Mozilla/5.0 (X11; Ubuntu; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2919.83 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2866.71 Safari/537.36',
-    'Mozilla/5.0 (X11; Ubuntu; Linux i686 on x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2820.59 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2762.73 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2656.18 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/44.0.2403.155 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2226.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2224.3 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.93 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 4.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36',
-    'Mozilla/5.0 (X11; OpenBSD i386) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2309.372 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2117.157 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1866.237 Safari/537.36',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/4E423F',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36 Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B334b Safari/531.21.10',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.517 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1664.3 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1664.3 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1623.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.17 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.62 Safari/537.36',
-    'Mozilla/5.0 (X11; CrOS i686 4319.74.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.2 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1467.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1464.0 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1500.55 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.90 Safari/537.36',
-    'Mozilla/5.0 (X11; NetBSD) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36',
-    'Mozilla/5.0 (X11; CrOS i686 3912.101.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.60 Safari/537.17',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1309.0 Safari/537.17',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.15 (KHTML, like Gecko) Chrome/24.0.1295.0 Safari/537.15',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.14 (KHTML, like Gecko) Chrome/24.0.1292.0 Safari/537.14',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1284.0 Safari/537.13',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.6 Safari/537.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.6 Safari/537.11',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.26 Safari/537.11',
-    'Mozilla/5.0 (Windows NT 6.0) yi; AppleWebKit/345667.12221 (KHTML, like Gecko) Chrome/23.0.1271.26 Safari/453667.1221',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.17 Safari/537.11',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_0) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.79 Safari/537.4',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1',
-    'Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5',
-    'Mozilla/5.0 (X11; FreeBSD amd64) AppleWebKit/536.5 (KHTML like Gecko) Chrome/19.0.1084.56 Safari/1EA69',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.22 (KHTML, like Gecko) Chrome/19.0.1047.0 Safari/535.22',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.21 (KHTML, like Gecko) Chrome/19.0.1042.0 Safari/535.21',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.21 (KHTML, like Gecko) Chrome/19.0.1041.0 Safari/535.21',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/18.6.872.0 Safari/535.2 UNTRUSTED/1.0 3gpp-gba UNTRUSTED/1.0',
-    'Mozilla/5.0 (Macintosh; AMD Mac OS X 10_8_2) AppleWebKit/535.22 (KHTML, like Gecko) Chrome/18.6.872',
-    'Mozilla/5.0 (X11; CrOS i686 1660.57.0) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.46 Safari/535.19',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.45 Safari/535.19',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.45 Safari/535.19',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.45 Safari/535.19',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.151 Safari/535.19',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.19 (KHTML, like Gecko) Ubuntu/11.10 Chromium/18.0.1025.142 Chrome/18.0.1025.142 Safari/535.19',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.11 Safari/535.19',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.04 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/10.10 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (X11; FreeBSD amd64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_4) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.04 Chromium/17.0.963.56 Chrome/17.0.963.56 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.12 Safari/535.11',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.8 (KHTML, like Gecko) Chrome/17.0.940.0 Safari/535.8',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.77 Safari/535.7ad-imcjapan-syosyaman-xkgi3lqg03!wgz',
-    'Mozilla/5.0 (X11; CrOS i686 1193.158.0) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.75 Safari/535.7',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.75 Safari/535.7',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.75 Safari/535.7',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7xs5D9rRDFpg2g',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.8 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.8',
-    'Mozilla/5.0 (Windows NT 5.2; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.36 Safari/535.7',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.36 Safari/535.7',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.36 Safari/535.7',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.6 (KHTML, like Gecko) Chrome/16.0.897.0 Safari/535.6',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.54 Safari/535.2',
-    'Mozilla/5.0 (X11; FreeBSD i386) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.121 Safari/535.2',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.2 (KHTML, like Gecko) Ubuntu/11.10 Chromium/15.0.874.120 Chrome/15.0.874.120 Safari/535.2',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.120 Safari/535.2',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.872.0 Safari/535.2',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.2 (KHTML, like Gecko) Ubuntu/11.04 Chromium/15.0.871.0 Chrome/15.0.871.0 Safari/535.2',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.864.0 Safari/535.2',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.861.0 Safari/535.2',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.861.0 Safari/535.2',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.861.0 Safari/535.2',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.860.0 Safari/535.2',
-    'Chrome/15.0.860.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/15.0.860.0',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.186 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.834.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/14.0.825.0 Chrome/14.0.825.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.824.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.815.10913 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.815.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/14.0.814.0 Chrome/14.0.814.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.814.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.04 Chromium/14.0.813.0 Chrome/14.0.813.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.812.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.811.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.810.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.810.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.809.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.10 Chromium/14.0.808.0 Chrome/14.0.808.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.04 Chromium/14.0.808.0 Chrome/14.0.808.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.04 Chromium/14.0.804.0 Chrome/14.0.804.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/14.0.803.0 Chrome/14.0.803.0 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.801.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.801.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.794.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.794.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.792.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.792.0 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.792.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; PPC Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.790.0 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.790.0 Safari/535.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1) AppleWebKit/526.3 (KHTML, like Gecko) Chrome/14.0.564.21 Safari/526.3',
-    'Mozilla/5.0 (X11; CrOS i686 13.587.48) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.43 Safari/535.1',
-    'Mozilla/5.0 Slackware/13.37 (X11; U; Linux x86_64; en-US) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41',
-    'Mozilla/5.0 ArchLinux (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/13.0.782.41 Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.2; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_3) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_3) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.32 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux amd64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.220 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.220 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.220 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
-    'Mozilla/5.0 (X11; CrOS i686 0.13.587) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.14 Safari/535.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.107 Safari/535.1',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.107 Safari/535.1',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.1 Safari/535.1',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.36 (KHTML, like Gecko) Chrome/13.0.766.0 Safari/534.36',
-    'Mozilla/5.0 (X11; Linux amd64) AppleWebKit/534.36 (KHTML, like Gecko) Chrome/13.0.766.0 Safari/534.36',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.35 (KHTML, like Gecko) Ubuntu/10.10 Chromium/13.0.764.0 Chrome/13.0.764.0 Safari/534.35',
-    'Mozilla/5.0 (X11; CrOS i686 0.13.507) AppleWebKit/534.35 (KHTML, like Gecko) Chrome/13.0.763.0 Safari/534.35',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.33 (KHTML, like Gecko) Ubuntu/9.10 Chromium/13.0.752.0 Chrome/13.0.752.0 Safari/534.33',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.31 (KHTML, like Gecko) Chrome/13.0.748.0 Safari/534.31',
-    'Mozilla/5.0 (Windows NT 6.1; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.750.0 Safari/534.30',
-    'Mozilla/5.0 (X11; CrOS i686 12.433.109) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.93 Safari/534.30',
-    'Mozilla/5.0 (X11; CrOS i686 12.0.742.91) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.93 Safari/534.30',
-    'Mozilla/5.0 Slackware/13.37 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/12.0.742.91',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.91 Chromium/12.0.742.91 Safari/534.30',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.68 Safari/534.30',
-    'Mozilla/5.0 ArchLinux (X11; U; Linux x86_64; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.60 Safari/534.30',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.53 Safari/534.30',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.113 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/11.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/11.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (Windows NT 7.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (Windows 8) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_6) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_4) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
-    'Mozilla/5.0 (X11; CrOS i686 12.433.216) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.105 Safari/534.30',
-    'Mozilla/5.0 ArchLinux (X11; U; Linux x86_64; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
-    'Mozilla/5.0 ArchLinux (X11; U; Linux x86_64; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Slackware/Chrome/12.0.742.100 Safari/534.30',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_4) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.724.100 Safari/534.30',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.25 (KHTML, like Gecko) Chrome/12.0.706.0 Safari/534.25',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.25 (KHTML, like Gecko) Chrome/12.0.704.0 Safari/534.25',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.703.0 Chrome/12.0.703.0 Safari/534.24',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.702.0 Chrome/12.0.702.0 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/12.0.702.0 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/12.0.702.0 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.700.3 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.699.0 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.699.0 Safari/534.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_6) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.698.0 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.697.0 Safari/534.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.71 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24',
-    'Mozilla/5.0 Slackware/13.37 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/11.0.696.50',
-    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.43 Safari/534.24',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.34 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.34 Safari/534.24',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.14 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.12 Safari/534.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_6) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.12 Safari/534.24',
-    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Ubuntu/10.04 Chromium/11.0.696.0 Chrome/11.0.696.0 Safari/534.24',
-    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.0 Safari/534.24',
-    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.694.0 Safari/534.24',
-    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.23 (KHTML, like Gecko) Chrome/11.0.686.3 Safari/534.23',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.21 (KHTML, like Gecko) Chrome/11.0.682.0 Safari/534.21',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.21 (KHTML, like Gecko) Chrome/11.0.678.0 Safari/534.21',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_7_0; en-US) AppleWebKit/534.21 (KHTML, like Gecko) Chrome/11.0.678.0 Safari/534.21',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20',
-    'Mozilla/5.0 (Windows NT) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.669.0 Safari/534.20',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.19 (KHTML, like Gecko) Chrome/11.0.661.0 Safari/534.19',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.18 (KHTML, like Gecko) Chrome/11.0.661.0 Safari/534.18',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.18 (KHTML, like Gecko) Chrome/11.0.660.0 Safari/534.18',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.655.0 Safari/534.17',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.655.0 Safari/534.17',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.654.0 Safari/534.17',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.652.0 Safari/534.17',
-    'Mozilla/4.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/11.0.1245.0 Safari/537.36',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.82 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux armv7l; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16',
-    'Mozilla/5.0 (X11; U; FreeBSD x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16',
-    'Mozilla/5.0 (X11; U; FreeBSD i386; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.133 Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.133 Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.127 Chrome/10.0.648.127 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.11 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; ru-RU; AppleWebKit/534.16; KHTML; like Gecko; Chrome/10.0.648.11;Safari/534.16)',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; ru-RU) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.11 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.11 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.0 Chrome/10.0.648.0 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.0 Chrome/10.0.648.0 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.0 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.642.0 Chrome/10.0.642.0 Safari/534.16',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.639.0 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.638.0 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.634.0 Safari/534.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.634.0 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 SUSE/10.0.626.0 (KHTML, like Gecko) Chrome/10.0.626.0 Safari/534.16',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Chrome/10.0.613.0 Safari/534.15',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.613.0 Chrome/10.0.613.0 Safari/534.15',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Ubuntu/10.04 Chromium/10.0.612.3 Chrome/10.0.612.3 Safari/534.15',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Chrome/10.0.612.1 Safari/534.15',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.611.0 Chrome/10.0.611.0 Safari/534.15',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.602.0 Safari/534.14',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.601.0 Safari/534.14',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.601.0 Safari/534.14',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/540.0 (KHTML,like Gecko) Chrome/9.1.0.0 Safari/540.0',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/540.0 (KHTML, like Gecko) Ubuntu/10.10 Chrome/9.1.0.0 Safari/540.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.601.0 Safari/534.14',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Ubuntu/10.10 Chromium/9.0.600.0 Chrome/9.0.600.0 Safari/534.14',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.600.0 Safari/534.14',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.599.0 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-CA) AppleWebKit/534.13 (KHTML like Gecko) Chrome/9.0.597.98 Safari/534.13',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.84 Safari/534.13',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.44 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.19 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.15 Safari/534.13',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.15 Safari/534.13',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416758524.9051',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416748405.3871',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416670950.695',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416664997.4379',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1333515017.9196',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US)  AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.596.0 Safari/534.13',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Ubuntu/10.04 Chromium/9.0.595.0 Chrome/9.0.595.0 Safari/534.13',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Ubuntu/9.10 Chromium/9.0.592.0 Chrome/9.0.592.0 Safari/534.13',
-    'Mozilla/5.0 (X11; U; Windows NT 6; en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.587.0 Safari/534.12',
-    'Mozilla/5.0 (Windows  U  Windows NT 5.1  en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.583.0 Safari/534.12',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.579.0 Safari/534.12',
-    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.576.0 Safari/534.12',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/540.0 (KHTML, like Gecko) Ubuntu/10.10 Chrome/8.1.0.0 Safari/540.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.558.0 Safari/534.10',
-    'Mozilla/5.0 (X11; U; CrOS i686 0.9.130; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.344 Safari/534.10',
-    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.343 Safari/534.10',
-    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.341 Safari/534.10',
-    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.339 Safari/534.10',
-    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.339',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Ubuntu/10.10 Chromium/8.0.552.237 Chrome/8.0.552.237 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/533.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.215 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.215 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.215 Safari/534.10',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.210 Safari/534.10',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.200 Safari/534.10',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.551.0 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.548.0 Safari/534.10',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.544.0 Safari/534.10',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.15) Gecko/20101027 Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.9 (KHTML, like Gecko) Chrome/7.0.531.0 Safari/534.9',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.8 (KHTML, like Gecko) Chrome/7.0.521.0 Safari/534.8',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.24 Safari/534.7',
-    'Mozilla/5.0 (X11; U; Linux x86_64; fr-FR) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.500.0 Safari/534.6',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.498.0 Safari/534.6',
-    'Mozilla/5.0 (ipad Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.498.0 Safari/534.6',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/7.0.0 Safari/700.13',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.4 (KHTML, like Gecko) Chrome/6.0.481.0 Safari/534.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.53 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.470.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.464.0 Safari/534.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.464.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.463.0 Safari/534.3',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.462.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.462.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.461.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.461.0 Safari/534.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.461.0 Safari/534.3',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.460.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.460.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.460.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.459.0 Safari/534.3',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.0 Safari/534.3',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.457.0 Safari/534.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.456.0 Safari/534.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.454.0 Safari/534.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.454.0 Safari/534.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.453.1 Safari/534.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.453.1 Safari/534.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.453.1 Safari/534.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.451.0 Safari/534.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.1 SUSE/6.0.428.0 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.427.0 Safari/534.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.422.0 Safari/534.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.417.0 Safari/534.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.416.0 Safari/534.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.414.0 Safari/534.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.9 (KHTML, like Gecko) Chrome/6.0.400.0 Safari/533.9',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.8 (KHTML, like Gecko) Chrome/6.0.397.0 Safari/533.8',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/6.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.999 Safari/533.4',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_6; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.86 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.86 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.86 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.70 Safari/533.4',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.127 Safari/533.4',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.126 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; fr-FR) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.126 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.125 Safari/533.4',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.370.0 Safari/533.4',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.368.0 Safari/533.4',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.366.2 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.366.0 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.366.0 Safari/533.4',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.363.0 Safari/533.3',
-    'Mozilla/5.0 (X11; U; OpenBSD i386; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.359.0 Safari/533.3',
-    'Mozilla/5.0 (X11; U; x86_64 Linux; en_GB, en_US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.358.0 Safari/533.3',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.358.0 Safari/533.3',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.358.0 Safari/533.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.357.0 Safari/533.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.356.0 Safari/533.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.355.0 Safari/533.3',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.354.0 Safari/533.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.354.0 Safari/533.3',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.353.0 Safari/533.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.353.0 Safari/533.3',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.343.0 Safari/533.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.343.0 Safari/533.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_7_0; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.7 Safari/533.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.7 Safari/533.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.5 Safari/533.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.3 Safari/533.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.3 Safari/533.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.2 Safari/533.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2',
-    'Mozilla/5.0 (X11; U; Linux i586; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.1 (KHTML, like Gecko) Chrome/5.0.335.0 Safari/533.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/533.16 (KHTML, like Gecko) Chrome/5.0.335.0 Safari/533.16',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.310.0 Safari/532.9',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.309.0 Safari/532.9',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.308.0 Safari/532.9',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.307.11 Safari/532.9',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.307.1 Safari/532.9',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.1.249.1025 Safari/532.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.8 (KHTML, like Gecko) Chrome/4.0.302.2 Safari/532.8',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.8 (KHTML, like Gecko) Chrome/4.0.288.1 Safari/532.8',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.8 (KHTML, like Gecko) Chrome/4.0.277.0 Safari/532.8',
-    'Mozilla/5.0 (X11; U; Slackware Linux x86_64; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.30 Safari/532.5',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; it-IT) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.25 Safari/532.5',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_8; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.246.0 Safari/532.5',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.4 (KHTML, like Gecko) Chrome/4.0.241.0 Safari/532.4',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.4 (KHTML, like Gecko) Chrome/4.0.237.0 Safari/532.4 Debian',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.3 (KHTML, like Gecko) Chrome/4.0.227.0 Safari/532.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.3 (KHTML, like Gecko) Chrome/4.0.224.2 Safari/532.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.3 (KHTML, like Gecko) Chrome/4.0.223.5 Safari/532.3',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.4 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.3 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.1 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.1 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.1 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.0 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.8 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.7 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.6 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.6 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.6 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.3 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.3 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.3 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.2 Safari/532.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.2 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.12 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.12 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.12 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.1 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.0 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.7 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.6 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.6 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.6 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.3 Safari/532.2',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.0 Safari/532.2',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.220.1 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.6 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.5 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.5 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.4 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.3 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.3 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.3 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.0 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.212.1 Safari/532.1',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_7; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.212.1 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.1',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.7 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.7 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.4 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.4 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.4 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.210.0 Safari/532.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.210.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
-    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
-    'Mozilla/5.0 (X11; U; FreeBSD i386; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
-    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
-]
-
-random_ua: str = random.choice(uas)
-
-
-def gen_uas(max_len: int = 1000) -> t.Generator:
-    """
-    生成User-Agent
-    使用示例：
-        uas = useragent.gen_uas()
-        # res: 返回uas生成器
-        +++++[更多详见参数或源码]+++++
-    :param max_len:
-    :return:
-    """
-    url = 'http://useragentstring.com/pages/useragentstring.php?typ=Browser'
-    headers = {
-        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
-        'User-Agent': 'Mozilla/5.0 (compatible; U; ABrowse 0.6; Syllable) AppleWebKit/420+ (KHTML, like Gecko)'
-    }
-    timeout = 60
-    try:
-        import requests
-        resp = requests.get(url, headers=headers, timeout=timeout)
-        html = resp.text
-    except ImportError:
-        from urllib import request
-        resp = request.urlopen(request.Request(url, headers=headers), timeout=timeout)
-        html = str(resp.read())
-    uas = re.findall(r'<li>.*?<a.*?>(.*?)</a>', html)
-    for index, ua in enumerate(uas):
-        if index == max_len:
-            return
-        yield ua
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/8 20:36
+@abstract 用户代理
+@description
+    有以下属性：
+        1）uas列表1000条：useragent.uas
+        2）从1000条uas中随机选1条：useragent.random_ua
+        3）生成uas: useragent.gen_uas()
+@history
+"""
+import random
+import re
+import typing as t
+
+__all__ = [
+    'uas',
+    'random_ua',
+    'gen_uas',
+]
+
+uas = [
+    'Mozilla/5.0 (compatible; U; ABrowse 0.6; Syllable) AppleWebKit/420+ (KHTML, like Gecko)',
+    'Mozilla/5.0 (compatible; U; ABrowse 0.6;  Syllable) AppleWebKit/420+ (KHTML, like Gecko)',
+    'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser 1.98.744; .NET CLR 3.5.30729)',
+    'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser 1.98.744; .NET CLR   3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0;   Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;   SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; Acoo Browser; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; Avant Browser)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1;   .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Maxthon; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser 1.98.744; .NET CLR 3.5.30729); Windows NT 5.1; Trident/4.0)',
+    'Mozilla/4.0 (compatible; Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6; Acoo Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727); Windows NT 5.1; Trident/4.0; Maxthon; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser; GTB6; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6; Acoo Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; GTB5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Acoo Browser; InfoPath.2; .NET CLR 2.0.50727; Alexa Toolbar)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Acoo Browser; .NET CLR 2.0.50727; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Acoo Browser; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727; FDM; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; Acoo Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; Windows NT 5.1; (R1 1.5); .NET CLR 2.0.50727; InfoPath.1)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; InfoPath.1; .NET CLR 2.0.50727; Media Center PC 3.0; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; America Online Browser 1.1; rev1.2; Windows NT 5.1; SV1; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; HbTools 4.7.0)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.1.4322; InfoPath.1; HbTools 4.8.0)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 3.1)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.1.4322; HbTools 4.7.1)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 3.1)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; SV1)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; FunWebProducts; (R1 1.5); HbTools 4.7.7)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.1; FunWebProducts)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; SV1; FunWebProducts; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; rev1.5; Windows NT 5.1; SV1; .NET CLR 1.1.4322; InfoPath.1)',
+    'Mozilla/5.0 (compatible; MSIE 9.0; AOL 9.7; AOLBuild 4343.19; Windows NT 6.1; WOW64; Trident/5.0; FunWebProducts)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.27; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.21; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.19; Windows NT 5.1; Trident/4.0; GTB7.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.7; AOLBuild 4343.19; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.7; AOLBuild 4343.19; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5004; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5001; Windows NT 5.1; Trident/4.0)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5000; Windows NT 5.1; Trident/4.0; FunWebProducts)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.5000; Windows NT 5.1; Trident/4.0; .NET4.0C; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.27; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.27; Windows NT 5.1; Trident/4.0; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.17; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.168; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; MS-RTC LM 8)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.168; Windows NT 5.1; Trident/4.0; GTB7.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.130; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.130; Windows NT 5.1; Trident/4.0; FunWebProducts; GTB6.6; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; yie8)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.12; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.12; Windows NT 5.1; Trident/4.0; GTB6.3)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.124; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.122; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; MS-RTC LM 8)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.122; Windows NT 5.1; Trident/4.0; FunWebProducts)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.111; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.110; Windows NT 5.1; Trident/4.0; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.6; AOLBuild 4340.104; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.6; AOLBuild 4340.128; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.5; AOLBuild 4337.43; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.21022; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.5; AOLBuild 4337.29; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.21022; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.93; Windows NT 5.1; Trident/4.0; DigExt; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.89; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.81; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.81; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618) (Compatible;  ;  ; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET ',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.81; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.80; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.53; Windows NT 6.0; FunWebProducts; GTB6; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.43; Windows NT 6.0; WOW64; GTB5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.43; Windows NT 5.1; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.43; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.42; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 6.0; FunWebProducts; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 5.1; Trident/4.0; GTB6; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.40; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.36; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30618; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.36; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.36; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/5.0 (compatible; MSIE 9.0; AOL 9.1; AOLBuild 4334.5012; Windows NT 6.0; WOW64; Trident/5.0)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.1; AOLBuild 4334.5011; Windows NT 6.1; WOW64; Trident/4.0; GTB7.2; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5010; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5009; Windows NT 5.1; GTB5; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; Trident/4.0; DigExt; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; GTB5; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5000; Windows NT 5.1; Trident/4.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.5000; Windows NT 5.1; Media Center PC 3.0; .NET CLR 1.0.3705; .NET CLR 1.1.4322; InfoPath.1)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.36; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 5.1; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.34; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.27; Windows NT 6.0; WOW64; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506; Media Center PC 5.0); UnAuth-State',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.27; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506); UnAuth-State',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4334.27; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; InfoPath.1); UnAuth-State',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.1; AOLBuild 4327.65535; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727); UnAuth-State',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 9.1; AOLBuild 4334.5006; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; AOL 9.0; AOLBuild 4327.5201; Windows NT 6.0; WOW64; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.30729; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.2; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Trident/4.0; FunWebProducts; GTB6.4; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 1.1.4322; .NET CLR 3.5.30729; OfficeLiveConnector.1.3; OfficeLivePatch.0.0; .NET CLR 3.0.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; Seekmo 10.0.406.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; FunWebProducts; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.2; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; FunWebProducts; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; Seekmo 10.0.341.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 6.0; FunWebProducts; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; Trident/4.0; GTB6; FunWebProducts; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 1.1.4322; .NET CLR 2.0.50727; OfficeLiveConnector.1.3; OfficeLivePatch.0.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; GTB5; .NET CLR 1.0.3705; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.0; Windows NT 5.1; FunWebProducts; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) )',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; GTB5; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.1; .NET CLR 3.0.04506.30)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 8.0; Windows NT 5.1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; YComp 5.0.0.0; .NET CLR 1.0.3705)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; SV1; (R1 1.3); .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 8.0; Windows NT 5.1; FunWebProducts; SV1; .NET CLR 1.0.3705)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; AOL 7.0; Windows NT 5.1) (Compatible;  ;  ; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; YComp 5.0.2.6; Hotbar 4.2.8.0)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; SV1; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows NT 5.1; Q312461; YComp 5.0.0.0)',
+    'Mozilla/4.0 (compatible; MSIE 6.0; AOL 7.0; Windows 98; Win 9x 4.90; .NET CLR 1.1.4322)',
+    'Mozilla/5.0 (X11; U; UNICOS lcLinux; en-US) Gecko/20140730 (KHTML, like Gecko, Safari/419.3) Arora/0.8.0',
+    'Mozilla/5.0 (X11; U; Linux; de-DE) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.8.0',
+    'Mozilla/5.0 (Windows; U; ; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.8.0',
+    'Mozilla/5.0 (Windows; U; ; en-NZ) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.8.0',
+    'Mozilla/5.0 (Windows; U; ; en-EN) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.8.0',
+    'Mozilla/5.0 (X11; U; Linux; ru-RU) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change: 802 025a17d)',
+    'Mozilla/5.0 (X11; U; Linux; fi-FI) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change: 754 46b659a)',
+    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6',
+    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change:  )',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.6 (Change:  )',
+    'Mozilla/5.0 (X11; U; Linux; pt-PT) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; nb-NO) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; it-IT) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 413 12f13f8)',
+    'Mozilla/5.0 (X11; U; Linux; it-IT) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; hu-HU) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 388 835b3b6)',
+    'Mozilla/5.0 (X11; U; Linux; hu-HU) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; fr-FR) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; es-ES) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 388 835b3b6)',
+    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; en-GB) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 388 835b3b6)',
+    'Mozilla/5.0 (X11; U; Linux; en-GB) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; de-DE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4',
+    'Mozilla/5.0 (X11; U; Linux; cs-CZ) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change: 333 41e3bc6)',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; de-DE) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; pt-BR) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; de-DE) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.4 (Change:  )',
+    'Mozilla/5.0 (X11; U; Linux; en-GB) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 239 52c6958)',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 287 c9dfb30)',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; fr-BE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 287 c9dfb30)',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.3 (Change: 287 c9dfb30)',
+    'Mozilla/5.0 (X11; U; Linux; sk-SK) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
+    'Mozilla/5.0 (X11; U; Linux; nb-NO) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
+    'Mozilla/5.0 (X11; U; Linux; es-CR) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
+    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 189 35c14e0)',
+    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
+    'Mozilla/5.0 (X11; U; Linux; de-DE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2 (Change: 0 )',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; de-DE) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; nl-NL) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; de-CH) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3)  Arora/0.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Arora/0.11.0 Safari/533.3',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.34 (KHTML, like Gecko) Arora/0.11.0 Safari/534.34',
+    'Mozilla/5.0 (X11; U; Linux; pl-PL) AppleWebKit/532.4 (KHTML, like Gecko) Arora/0.10.2 Safari/532.4',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.34 (KHTML, like Gecko) Arora/0.10.2 Safari/534.34',
+    'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527  (KHTML, like Gecko, Safari/419.3) Arora/0.10.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-MY) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.10.0',
+    'Mozilla/5.0 (Windows; U; ; hu-HU) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.10.0',
+    'Mozilla/5.0 (Windows; U; ; hu-HU) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3)  Arora/0.10.0',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; Avant Browser; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; InfoPath.1)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6.4; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; chromeframe; Avant Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; InfoPath.1; .NET CLR 3.0.4506.',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB5; Avant Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; Avant Browser; Avant Browser; .NET CLR 2.0.50727)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT; Avant Browser; Avant Browser; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E; Avant Browser)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0; Avant Browser; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; WOW64; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.1; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; GTB6.3; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 1.1.4322; .NET CLR 3.5.30729; .NET CLR 3.0.30729',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Trident/4.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; InfoPath.1)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; .NET CLR 1.1.4322; InfoPath.2)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30618; InfoPath.2; OfficeLiveConnector.1.3; OfficeLivePatch.0.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; Avant Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; Tablet PC 2.0)',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Avant Browser; .NET CLR 1.0.3705; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
+    'Mozilla/5.0 (X11; U; Linux i686; nl; rv:1.8.1b2) Gecko/20060821 BonEcho/2.0b2 (Debian-1.99+2.0b2+dfsg-1)',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1b2) Gecko/20060826 BonEcho/2.0b2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.8.1b2) Gecko/20060831 BonEcho/2.0b2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-GB; rv:1.8.1b1) Gecko/20060601 BonEcho/2.0b1 (Ubuntu-edgy)',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1a3) Gecko/20060526 BonEcho/2.0a3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-GB; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X Mach-O; en-US; rv:1.8.1a2) Gecko/20060512 BonEcho/2.0a2',
+    'Mozilla/5.0 (X11; U; OpenBSD ppc; en-US; rv:1.8.1.9) Gecko/20070223 BonEcho/2.0.0.9',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.9) Gecko/20071103 BonEcho/2.0.0.9',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.9) Gecko/20071113 BonEcho/2.0.0.9',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.8pre) Gecko/20071012 BonEcho/2.0.0.8pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.7pre) Gecko/20070901 BonEcho/2.0.0.7pre',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.7) Gecko/20070918 BonEcho/2.0.0.7',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.7) Gecko/20071018 BonEcho/2.0.0.7',
+    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.7) Gecko/20070917 BonEcho/2.0.0.7',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.6) Gecko/20070812 BonEcho/2.0.0.6',
+    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.6) Gecko/20070731 BonEcho/2.0.0.6',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; de; rv:1.8.1.5pre) Gecko/20070604 BonEcho/2.0.0.5pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.5pre) Gecko/20070622 BonEcho/2.0.0.5pre',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.4pre) Gecko/20070414 BonEcho/2.0.0.4pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1.4pre) Gecko/20070510 BonEcho/2.0.0.4pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4pre) Gecko/20070416 BonEcho/2.0.0.4pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4pre) Gecko/20070410 BonEcho/2.0.0.4pre',
+    'Mozilla/5.0 (X11; U; OpenBSD ppc; en-US; rv:1.8.1.4) Gecko/20070223 BonEcho/2.0.0.4',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.4) Gecko/20070531 BonEcho/2.0.0.4',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4) Gecko/20070416 BonEcho/2.0.0.4',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1.3pre) Gecko/20070302 BonEcho/2.0.0.3pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.3pre) Gecko/20070302 BonEcho/2.0.0.3pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.8.1.3pre) Gecko/20070301 BonEcho/2.0.0.3pre',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.3) Gecko/20070517 BonEcho/2.0.0.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.9a3) Gecko/20070409 BonEcho/2.0.0.3',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1.3) Gecko/20070329 BonEcho/2.0.0.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.3) Gecko/20070322 BonEcho/2.0.0.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1.2pre) Gecko/20070226 BonEcho/2.0.0.2pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070213 BonEcho/2.0.0.2pre',
+    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.21pre) Gecko/20090218 BonEcho/2.0.0.21pre',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.2) Gecko/20070302 BonEcho/2.0.0.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.2) Gecko/20070224 BonEcho/2.0.0.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2) Gecko/20070227 BonEcho/2.0.0.2',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1.2) Gecko/20070223 BonEcho/2.0.0.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1pre) Gecko/20061203 BonEcho/2.0.0.1pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1pre) Gecko/20061202 BonEcho/2.0.0.1pre',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1pre) Gecko/20061122 BonEcho/2.0.0.1pre',
+    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.18) Gecko/20081114 BonEcho/2.0.0.18',
+    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.17) Gecko/20080831 BonEcho/2.0.0.17',
+    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.17) Gecko/20080831 BonEcho/2.0.0.17',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.14) Gecko/20080417 BonEcho/2.0.0.14',
+    'Mozilla/5.0 (BeOS; U; Haiku BePC; en-US; rv:1.8.1.14) Gecko/20080429 BonEcho/2.0.0.14',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.13) Gecko/20080401 BonEcho/2.0.0.13',
+    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US; rv:1.8.1.12pre) Gecko/20080103 BonEcho/2.0.0.12pre',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.12) Gecko/20080208 BonEcho/2.0.0.12',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.12) Gecko/20080321 BonEcho/2.0.0.12 (SliTaz GNU/Linux)',
+    'Mozilla/5.0 (X11; U; SunOS sun4u; en-US; rv:1.8.1.11) Gecko/20080208 BonEcho/2.0.0.11',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.11) Gecko/20071204 BonEcho/2.0.0.11',
+    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.10) Gecko/20071128 BonEcho/2.0.0.10',
+    'Mozilla/5.0 (X11; U; Linux ppc; en-US; rv:1.8.1.1) Gecko/20061219 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux mips; en-US; rv:1.8.1.1) Gecko/20070628 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en; rv:1.8.1.1) Gecko/20070117 Epiphany/2.16 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070222 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070220 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070217 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070215 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.1) Gecko/20070115 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-GB; rv:1.8.1.1) Gecko/20070110 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US; rv:1.8.1.1) Gecko/20070131 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061222 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.8.1.1) Gecko/20061230 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (BeOS; U; BeOS BePC; en-US; rv:1.8.1.1) Gecko/20061220 BonEcho/2.0.0.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061210 BonEcho/2.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061209 BonEcho/2.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061121 BonEcho/2.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061113 BonEcho/2.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20061112 BonEcho/2.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1) Gecko/20060930 BonEcho/2.0',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061026 BonEcho/2.0',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061025 BonEcho/2.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1) Gecko/20061024 BonEcho/2.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en; rv:1.9a1) Gecko/20061128 BonEcho/0.7b1',
+    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; Browzar)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; XH; rv:8.578.498) fr, Gecko/20121021 Camino/8.723+ (Firefox compatible)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; XH; rv:8.578.498) fr, Gecko/20121021 Camino/8.443+ (Firefox compatible)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.8; it; rv:1.9.2.28) Gecko/20130628 Camino/3.245.226 (MultiLang) (like Firefox/3.621.218)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.8; it; rv:1.93.26.2658) Gecko/20141026 Camino/2.176.223 (MultiLang) (like Firefox/3.64.2268)0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.2.14pre) Gecko/20101212 Camino/2.1a1pre (like Firefox/3.6.14pre)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.2.14pre)   Gecko/20101212 Camino/2.1a1pre (like Firefox/3.6.14pre)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.2.29pre) Gecko/20130101 Camino/2.1.3pre (like Firefox/3.6.29pre)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; de; rv:1.9.2.28) Gecko/20120308 Camino/2.1.2 (MultiLang) (like Firefox/3.6.28)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.8; it; rv:1.9.2.28) Gecko/20120308 Camino/2.1.2 (MultiLang) (like Firefox/3.6.28)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; fr; rv:1.9.2.28) Gecko/20120308 Camino/2.1.2 (MultiLang) (like Firefox/3.6.28)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.4; en; rv:1.9.2.24) Gecko/20111114 Camino/2.1 (like Firefox/3.6.24)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en; rv:1.9.0.8pre) Gecko/2009022800 Camino/2.0b3pre',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en; rv:1.9.0.10pre) Gecko/2009041800 Camino/2.0b3pre (like Firefox/3.0.10pre)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.5; it; rv:1.9.0.19) Gecko/2010111021 Camino/2.0.6 (MultiLang) (like Firefox/3.0.19)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.0.19) Gecko/2010111021 Camino/2.0.6 (MultiLang) (like Firefox/3.0.19)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10.4; en; rv:1.9.0.19) Gecko/2010051911 Camino/2.0.3 (like Firefox/3.0.19)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; nl; rv:1.9.0.19) Gecko/2010051911 Camino/2.0.3 (MultiLang) (like Firefox/3.0.19)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.0.18) Gecko/2010021619 Camino/2.0.2 (like Firefox/3.0.18)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.4pre) Gecko/20070511 Camino/1.6pre',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; de; rv:1.8.1.5pre) Gecko/20070605 Camino/1.6a1pre',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4pre) Gecko/20070526 Camino/1.6a1pre',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4pre) Gecko/20070521 Camino/1.6a1pre',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; it; rv:1.8.1.21) Gecko/20090327 Camino/1.6.7 (MultiLang) (like Firefox/2.0.0.21pre)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; fr; rv:1.8.1.21) Gecko/20090327 Camino/1.6.7 (MultiLang) (like Firefox/2.0.0.21pre)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.21) Gecko/20090327 Camino/1.6.7 (like Firefox/2.0.0.21pre)',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.24) Gecko/20100305 Camino/1.6.11 (like Firefox/2.0.0.24)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.12) Gecko/20080206 Camino/1.5.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X Mach-O; en; rv:1.8.1.12) Gecko/20080206 Camino/1.5.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.11) Gecko/20071128 Camino/1.5.4',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Firefox/2.0.0.6 Camino/1.5.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6 Camino/1.5.1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.4) Gecko/20070509 Camino/1.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4) Gecko/20070609 Camino/1.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4) Gecko/20070607 Camino/1.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4) Gecko/20070509 Camino/1.5',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.9a4pre) Gecko/20070404 Camino/1.2+',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.4pre) Gecko/20070417 Camino/1.1b+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en; rv:1.8.1.2pre) Gecko/20070227 Camino/1.1b',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.2pre) Gecko/20070223 Camino/1.1b',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.2pre) Gecko/20070108 Camino/1.1a2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.1pre) Gecko/20061126 Camino/1.1a1+',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1) Gecko/20061018 Camino/1.1a1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.1) Gecko/20060203 Camino/1.0rc1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.1) Gecko/20060119 Camino/1.0b2+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8) Gecko/20051229 Camino/1.0b2',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8) Gecko/20051228 Camino/1.0b1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8) Gecko/20051107 Camino/1.0b1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8b4) Gecko/20050914 Camino/1.0a1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.10) Gecko/20070228 Camino/1.0.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.10) Gecko/20070228 Camino/1.0.4',
+    'Mozilla/5.0 (Macintosh; U; PPC Max OS X Mach-O; it-IT; rv:1.8.0.7) Gecko/200609211 Camino/1.0.3',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.7) Gecko/20060911 Camino/1.0.3 (MultiLang)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.7) Gecko/20060911 Camino/1.0.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.7) Gecko/20060911 Camino/1.0.3',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.4) Gecko/20060613 Camino/1.0.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.4) Gecko/20060613 Camino/1.0.2',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.3) Gecko/20060503 Camino/1.0.1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.3) Gecko/20060427 Camino/1.0.1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1b1) Gecko/20060807 Camino/1.0+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1b1) Gecko/20060721 Camino/1.0+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1a3) Gecko/20060528 Camino/1.0+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061013 Camino/1.0+ (Firefox compatible)',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.1) Gecko/20061013 Camino/1.0+',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1a3) Gecko/20060601 Camino/1.0+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.1) Gecko/20060307 Camino/1.0',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8.0.1) Gecko/20060214 Camino/1.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8b5) Gecko/20051021 Camino/1.0+',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.0.1) Gecko/20060214 Camino/1.0',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.8b2) Gecko Camino/0.9+',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7) Gecko/20040517 Camino/0.8b',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.8) Gecko/20050427 Camino/0.8.4',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030306 Camino/0.7',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.8 (KHTML, like Gecko, Safari) Cheshire/1.0.UNOFFICIAL',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko, Safari) Cheshire/1.0.UNOFFICIAL',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/419 (KHTML, like Gecko, Safari/419.3) Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Safari) Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko, Safari/111) Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko, Safari) Safari/419.3 Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko) Safari/419.3 Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/418.9 (KHTML, like Gecko) AppleWebKit/418.9 Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/419 (KHTML, like Gecko, Safari/419.3) Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/419 (KHTML, like Gecko, Safari/125) Cheshire/1.0.ALPHA',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; pl-PL; rv:1.0.1) Gecko/20021111 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; pl-PL; rv:1.0.1)   Gecko/20021111 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-US; rv:1.0.1) Gecko/20021111 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-US; rv:1.0.1) Gecko/20021104 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030111 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030109 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20021220 Chimera/0.6',
+    'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20021216 Chimera/0.6',
+    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
+    'Mozilla/5.0 (X11; Ubuntu; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2919.83 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2866.71 Safari/537.36',
+    'Mozilla/5.0 (X11; Ubuntu; Linux i686 on x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2820.59 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2762.73 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2656.18 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/44.0.2403.155 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2226.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2224.3 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.93 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.124 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 4.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36',
+    'Mozilla/5.0 (X11; OpenBSD i386) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2309.372 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2117.157 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1866.237 Safari/537.36',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/4E423F',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36 Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B334b Safari/531.21.10',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.517 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1664.3 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1664.3 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1623.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.17 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.62 Safari/537.36',
+    'Mozilla/5.0 (X11; CrOS i686 4319.74.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.2 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1467.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1464.0 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1500.55 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.90 Safari/537.36',
+    'Mozilla/5.0 (X11; NetBSD) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36',
+    'Mozilla/5.0 (X11; CrOS i686 3912.101.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.60 Safari/537.17',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1309.0 Safari/537.17',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.15 (KHTML, like Gecko) Chrome/24.0.1295.0 Safari/537.15',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.14 (KHTML, like Gecko) Chrome/24.0.1292.0 Safari/537.14',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1284.0 Safari/537.13',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.6 Safari/537.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.6 Safari/537.11',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.26 Safari/537.11',
+    'Mozilla/5.0 (Windows NT 6.0) yi; AppleWebKit/345667.12221 (KHTML, like Gecko) Chrome/23.0.1271.26 Safari/453667.1221',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.17 Safari/537.11',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_0) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.79 Safari/537.4',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1',
+    'Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5',
+    'Mozilla/5.0 (X11; FreeBSD amd64) AppleWebKit/536.5 (KHTML like Gecko) Chrome/19.0.1084.56 Safari/1EA69',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.22 (KHTML, like Gecko) Chrome/19.0.1047.0 Safari/535.22',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.21 (KHTML, like Gecko) Chrome/19.0.1042.0 Safari/535.21',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.21 (KHTML, like Gecko) Chrome/19.0.1041.0 Safari/535.21',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/18.6.872.0 Safari/535.2 UNTRUSTED/1.0 3gpp-gba UNTRUSTED/1.0',
+    'Mozilla/5.0 (Macintosh; AMD Mac OS X 10_8_2) AppleWebKit/535.22 (KHTML, like Gecko) Chrome/18.6.872',
+    'Mozilla/5.0 (X11; CrOS i686 1660.57.0) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.46 Safari/535.19',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.45 Safari/535.19',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.45 Safari/535.19',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.45 Safari/535.19',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.151 Safari/535.19',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.19 (KHTML, like Gecko) Ubuntu/11.10 Chromium/18.0.1025.142 Chrome/18.0.1025.142 Safari/535.19',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.11 Safari/535.19',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.04 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/10.10 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/17.0.963.65 Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (X11; FreeBSD amd64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_4) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.65 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.04 Chromium/17.0.963.56 Chrome/17.0.963.56 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.12 Safari/535.11',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.8 (KHTML, like Gecko) Chrome/17.0.940.0 Safari/535.8',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.77 Safari/535.7ad-imcjapan-syosyaman-xkgi3lqg03!wgz',
+    'Mozilla/5.0 (X11; CrOS i686 1193.158.0) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.75 Safari/535.7',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.75 Safari/535.7',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.75 Safari/535.7',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7xs5D9rRDFpg2g',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.8 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.8',
+    'Mozilla/5.0 (Windows NT 5.2; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.36 Safari/535.7',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.36 Safari/535.7',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.36 Safari/535.7',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.6 (KHTML, like Gecko) Chrome/16.0.897.0 Safari/535.6',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.54 Safari/535.2',
+    'Mozilla/5.0 (X11; FreeBSD i386) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.121 Safari/535.2',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.2 (KHTML, like Gecko) Ubuntu/11.10 Chromium/15.0.874.120 Chrome/15.0.874.120 Safari/535.2',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.120 Safari/535.2',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.872.0 Safari/535.2',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.2 (KHTML, like Gecko) Ubuntu/11.04 Chromium/15.0.871.0 Chrome/15.0.871.0 Safari/535.2',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.864.0 Safari/535.2',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.861.0 Safari/535.2',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.861.0 Safari/535.2',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.861.0 Safari/535.2',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.860.0 Safari/535.2',
+    'Chrome/15.0.860.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/15.0.860.0',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.186 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.834.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/14.0.825.0 Chrome/14.0.825.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.824.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.815.10913 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.815.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/14.0.814.0 Chrome/14.0.814.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.814.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.04 Chromium/14.0.813.0 Chrome/14.0.813.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.813.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.812.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.811.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.810.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.810.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.809.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.10 Chromium/14.0.808.0 Chrome/14.0.808.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.04 Chromium/14.0.808.0 Chrome/14.0.808.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/10.04 Chromium/14.0.804.0 Chrome/14.0.804.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/14.0.803.0 Chrome/14.0.803.0 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.803.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.801.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.801.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.794.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.794.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.792.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.792.0 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.792.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; PPC Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.790.0 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.790.0 Safari/535.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1) AppleWebKit/526.3 (KHTML, like Gecko) Chrome/14.0.564.21 Safari/526.3',
+    'Mozilla/5.0 (X11; CrOS i686 13.587.48) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.43 Safari/535.1',
+    'Mozilla/5.0 Slackware/13.37 (X11; U; Linux x86_64; en-US) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41',
+    'Mozilla/5.0 ArchLinux (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Ubuntu/11.04 Chromium/13.0.782.41 Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.2; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_3) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_3) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.32 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux amd64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.220 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.220 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.220 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.215 Safari/535.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.20 Safari/535.1',
+    'Mozilla/5.0 (X11; CrOS i686 0.13.587) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.14 Safari/535.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.107 Safari/535.1',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_2) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.107 Safari/535.1',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.1 Safari/535.1',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.36 (KHTML, like Gecko) Chrome/13.0.766.0 Safari/534.36',
+    'Mozilla/5.0 (X11; Linux amd64) AppleWebKit/534.36 (KHTML, like Gecko) Chrome/13.0.766.0 Safari/534.36',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.35 (KHTML, like Gecko) Ubuntu/10.10 Chromium/13.0.764.0 Chrome/13.0.764.0 Safari/534.35',
+    'Mozilla/5.0 (X11; CrOS i686 0.13.507) AppleWebKit/534.35 (KHTML, like Gecko) Chrome/13.0.763.0 Safari/534.35',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.33 (KHTML, like Gecko) Ubuntu/9.10 Chromium/13.0.752.0 Chrome/13.0.752.0 Safari/534.33',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.31 (KHTML, like Gecko) Chrome/13.0.748.0 Safari/534.31',
+    'Mozilla/5.0 (Windows NT 6.1; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.750.0 Safari/534.30',
+    'Mozilla/5.0 (X11; CrOS i686 12.433.109) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.93 Safari/534.30',
+    'Mozilla/5.0 (X11; CrOS i686 12.0.742.91) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.93 Safari/534.30',
+    'Mozilla/5.0 Slackware/13.37 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/12.0.742.91',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.91 Chromium/12.0.742.91 Safari/534.30',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.68 Safari/534.30',
+    'Mozilla/5.0 ArchLinux (X11; U; Linux x86_64; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.60 Safari/534.30',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.53 Safari/534.30',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.113 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/11.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/11.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Ubuntu/10.04 Chromium/12.0.742.112 Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (Windows NT 7.1) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (Windows NT 5.2) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (Windows 8) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_6) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_4) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.112 Safari/534.30',
+    'Mozilla/5.0 (X11; CrOS i686 12.433.216) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.105 Safari/534.30',
+    'Mozilla/5.0 ArchLinux (X11; U; Linux x86_64; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
+    'Mozilla/5.0 ArchLinux (X11; U; Linux x86_64; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Slackware/Chrome/12.0.742.100 Safari/534.30',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_4) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.724.100 Safari/534.30',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.25 (KHTML, like Gecko) Chrome/12.0.706.0 Safari/534.25',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.25 (KHTML, like Gecko) Chrome/12.0.704.0 Safari/534.25',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.703.0 Chrome/12.0.703.0 Safari/534.24',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Ubuntu/10.10 Chromium/12.0.702.0 Chrome/12.0.702.0 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/12.0.702.0 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/12.0.702.0 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.700.3 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.699.0 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.699.0 Safari/534.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_6) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.698.0 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.697.0 Safari/534.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.71 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_8) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24',
+    'Mozilla/5.0 Slackware/13.37 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/11.0.696.50',
+    'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.43 Safari/534.24',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.34 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.34 Safari/534.24',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.14 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.12 Safari/534.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_6) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.12 Safari/534.24',
+    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Ubuntu/10.04 Chromium/11.0.696.0 Chrome/11.0.696.0 Safari/534.24',
+    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.0 Safari/534.24',
+    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.694.0 Safari/534.24',
+    'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.23 (KHTML, like Gecko) Chrome/11.0.686.3 Safari/534.23',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.21 (KHTML, like Gecko) Chrome/11.0.682.0 Safari/534.21',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.21 (KHTML, like Gecko) Chrome/11.0.678.0 Safari/534.21',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_7_0; en-US) AppleWebKit/534.21 (KHTML, like Gecko) Chrome/11.0.678.0 Safari/534.21',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20',
+    'Mozilla/5.0 (Windows NT) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.669.0 Safari/534.20',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.19 (KHTML, like Gecko) Chrome/11.0.661.0 Safari/534.19',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.18 (KHTML, like Gecko) Chrome/11.0.661.0 Safari/534.18',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.18 (KHTML, like Gecko) Chrome/11.0.660.0 Safari/534.18',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.655.0 Safari/534.17',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.655.0 Safari/534.17',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.654.0 Safari/534.17',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/11.0.652.0 Safari/534.17',
+    'Mozilla/4.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/11.0.1245.0 Safari/537.36',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.82 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux armv7l; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16',
+    'Mozilla/5.0 (X11; U; FreeBSD x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16',
+    'Mozilla/5.0 (X11; U; FreeBSD i386; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.134 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.133 Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.133 Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.127 Chrome/10.0.648.127 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.11 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; ru-RU; AppleWebKit/534.16; KHTML; like Gecko; Chrome/10.0.648.11;Safari/534.16)',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; ru-RU) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.11 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.11 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.0 Chrome/10.0.648.0 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.648.0 Chrome/10.0.648.0 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.0 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.642.0 Chrome/10.0.642.0 Safari/534.16',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.639.0 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.638.0 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.634.0 Safari/534.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.634.0 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.16 SUSE/10.0.626.0 (KHTML, like Gecko) Chrome/10.0.626.0 Safari/534.16',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Chrome/10.0.613.0 Safari/534.15',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.613.0 Chrome/10.0.613.0 Safari/534.15',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Ubuntu/10.04 Chromium/10.0.612.3 Chrome/10.0.612.3 Safari/534.15',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Chrome/10.0.612.1 Safari/534.15',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.15 (KHTML, like Gecko) Ubuntu/10.10 Chromium/10.0.611.0 Chrome/10.0.611.0 Safari/534.15',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.602.0 Safari/534.14',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.601.0 Safari/534.14',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.601.0 Safari/534.14',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/540.0 (KHTML,like Gecko) Chrome/9.1.0.0 Safari/540.0',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/540.0 (KHTML, like Gecko) Ubuntu/10.10 Chrome/9.1.0.0 Safari/540.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.601.0 Safari/534.14',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Ubuntu/10.10 Chromium/9.0.600.0 Chrome/9.0.600.0 Safari/534.14',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.600.0 Safari/534.14',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.599.0 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-CA) AppleWebKit/534.13 (KHTML like Gecko) Chrome/9.0.597.98 Safari/534.13',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.84 Safari/534.13',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.44 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.19 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.15 Safari/534.13',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.15 Safari/534.13',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416758524.9051',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416748405.3871',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416670950.695',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1416664997.4379',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.107 Safari/534.13 v1333515017.9196',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US)  AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.597.0 Safari/534.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Chrome/9.0.596.0 Safari/534.13',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Ubuntu/10.04 Chromium/9.0.595.0 Chrome/9.0.595.0 Safari/534.13',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.13 (KHTML, like Gecko) Ubuntu/9.10 Chromium/9.0.592.0 Chrome/9.0.592.0 Safari/534.13',
+    'Mozilla/5.0 (X11; U; Windows NT 6; en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.587.0 Safari/534.12',
+    'Mozilla/5.0 (Windows  U  Windows NT 5.1  en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.583.0 Safari/534.12',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.579.0 Safari/534.12',
+    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US) AppleWebKit/534.12 (KHTML, like Gecko) Chrome/9.0.576.0 Safari/534.12',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/540.0 (KHTML, like Gecko) Ubuntu/10.10 Chrome/8.1.0.0 Safari/540.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.558.0 Safari/534.10',
+    'Mozilla/5.0 (X11; U; CrOS i686 0.9.130; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.344 Safari/534.10',
+    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.343 Safari/534.10',
+    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.341 Safari/534.10',
+    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.339 Safari/534.10',
+    'Mozilla/5.0 (X11; U; CrOS i686 0.9.128; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.339',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Ubuntu/10.10 Chromium/8.0.552.237 Chrome/8.0.552.237 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/533.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.215 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.215 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.215 Safari/534.10',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.210 Safari/534.10',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.200 Safari/534.10',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.551.0 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.548.0 Safari/534.10',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.544.0 Safari/534.10',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.15) Gecko/20101027 Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/7.0.540.0 Safari/534.10',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.9 (KHTML, like Gecko) Chrome/7.0.531.0 Safari/534.9',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.8 (KHTML, like Gecko) Chrome/7.0.521.0 Safari/534.8',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.24 Safari/534.7',
+    'Mozilla/5.0 (X11; U; Linux x86_64; fr-FR) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.500.0 Safari/534.6',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.498.0 Safari/534.6',
+    'Mozilla/5.0 (ipad Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.498.0 Safari/534.6',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/7.0.0 Safari/700.13',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.4 (KHTML, like Gecko) Chrome/6.0.481.0 Safari/534.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.53 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.470.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.464.0 Safari/534.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.464.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.463.0 Safari/534.3',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.462.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.462.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.461.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.461.0 Safari/534.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.461.0 Safari/534.3',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.460.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.460.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.460.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.459.0 Safari/534.3',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.1 Safari/534.3',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.458.0 Safari/534.3',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.457.0 Safari/534.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.456.0 Safari/534.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.454.0 Safari/534.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.454.0 Safari/534.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.453.1 Safari/534.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.453.1 Safari/534.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.453.1 Safari/534.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.451.0 Safari/534.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.1 SUSE/6.0.428.0 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.428.0 Safari/534.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.427.0 Safari/534.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.422.0 Safari/534.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.417.0 Safari/534.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.416.0 Safari/534.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/534.1 (KHTML, like Gecko) Chrome/6.0.414.0 Safari/534.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.9 (KHTML, like Gecko) Chrome/6.0.400.0 Safari/533.9',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.8 (KHTML, like Gecko) Chrome/6.0.397.0 Safari/533.8',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/6.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.999 Safari/533.4',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_6; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.86 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.86 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.86 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.70 Safari/533.4',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.127 Safari/533.4',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.126 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; fr-FR) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.126 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.125 Safari/533.4',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.370.0 Safari/533.4',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.368.0 Safari/533.4',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.366.2 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.366.0 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.366.0 Safari/533.4',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.363.0 Safari/533.3',
+    'Mozilla/5.0 (X11; U; OpenBSD i386; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.359.0 Safari/533.3',
+    'Mozilla/5.0 (X11; U; x86_64 Linux; en_GB, en_US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.358.0 Safari/533.3',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.358.0 Safari/533.3',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.358.0 Safari/533.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.357.0 Safari/533.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.356.0 Safari/533.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.355.0 Safari/533.3',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.354.0 Safari/533.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.354.0 Safari/533.3',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.353.0 Safari/533.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.3 (KHTML, like Gecko) Chrome/5.0.353.0 Safari/533.3',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.343.0 Safari/533.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.343.0 Safari/533.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_7_0; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.7 Safari/533.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.7 Safari/533.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.5 Safari/533.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.3 Safari/533.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.3 Safari/533.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.2 Safari/533.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2',
+    'Mozilla/5.0 (X11; U; Linux i586; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.1 (KHTML, like Gecko) Chrome/5.0.335.0 Safari/533.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/533.16 (KHTML, like Gecko) Chrome/5.0.335.0 Safari/533.16',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.310.0 Safari/532.9',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.309.0 Safari/532.9',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.308.0 Safari/532.9',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.307.11 Safari/532.9',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.307.1 Safari/532.9',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.1.249.1025 Safari/532.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.8 (KHTML, like Gecko) Chrome/4.0.302.2 Safari/532.8',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.8 (KHTML, like Gecko) Chrome/4.0.288.1 Safari/532.8',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.8 (KHTML, like Gecko) Chrome/4.0.277.0 Safari/532.8',
+    'Mozilla/5.0 (X11; U; Slackware Linux x86_64; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.30 Safari/532.5',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; it-IT) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.25 Safari/532.5',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_8; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.246.0 Safari/532.5',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.4 (KHTML, like Gecko) Chrome/4.0.241.0 Safari/532.4',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.4 (KHTML, like Gecko) Chrome/4.0.237.0 Safari/532.4 Debian',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.3 (KHTML, like Gecko) Chrome/4.0.227.0 Safari/532.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.3 (KHTML, like Gecko) Chrome/4.0.224.2 Safari/532.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.3 (KHTML, like Gecko) Chrome/4.0.223.5 Safari/532.3',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.4 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.3 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.2 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.1 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.1 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.1 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.223.0 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.8 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.7 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.6 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.6 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.6 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.5 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.4 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.3 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.3 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.3 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.2 Safari/532.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.2 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.12 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.12 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.12 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.1 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.222.0 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.8 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.7 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.6 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.6 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.6 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.3 Safari/532.2',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.0 Safari/532.2',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.220.1 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.6 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.5 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.5 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.4 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.3 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.3 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.3 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.0 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.1 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.213.0 Safari/532.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_0; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.212.1 Safari/532.1',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_7; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.212.1 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.1',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.212.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.7 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.7 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.4 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.4 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.4 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.2 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.211.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.210.0 Safari/532.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.210.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.209.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
+    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_8; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.208.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
+    'Mozilla/5.0 (X11; U; FreeBSD i386; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
+    'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/4.0.207.0 Safari/532.0',
+]
+
+random_ua: str = random.choice(uas)
+
+
+def gen_uas(max_len: int = 1000) -> t.Generator:
+    """
+    生成User-Agent
+    使用示例：
+        uas = useragent.gen_uas()
+        # res: 返回uas生成器
+        +++++[更多详见参数或源码]+++++
+    :param max_len:
+    :return:
+    """
+    url = 'http://useragentstring.com/pages/useragentstring.php?typ=Browser'
+    headers = {
+        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
+        'User-Agent': 'Mozilla/5.0 (compatible; U; ABrowse 0.6; Syllable) AppleWebKit/420+ (KHTML, like Gecko)'
+    }
+    timeout = 60
+    try:
+        import requests
+        resp = requests.get(url, headers=headers, timeout=timeout)
+        html = resp.text
+    except ImportError:
+        from urllib import request
+        resp = request.urlopen(request.Request(url, headers=headers), timeout=timeout)
+        html = str(resp.read())
+    uas = re.findall(r'<li>.*?<a.*?>(.*?)</a>', html)
+    for index, ua in enumerate(uas):
+        if index == max_len:
+            return
+        yield ua
```

## toollib/utils.py

 * *Ordering differences only*

```diff
@@ -1,364 +1,364 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2021/12/18 22:20
-@abstract 实用工具
-@description
-@history
-"""
-import os
-import platform
-import re
-import stat
-import subprocess
-import tarfile
-import traceback
-from datetime import datetime
-import typing as t
-from json import dumps, loads
-from pathlib import Path
-from threading import Lock
-
-from toollib.common import rarfile, zipfile
-from toollib.validator import choicer
-
-__all__ = [
-    'Singleton',
-    'Chars',
-    'now2str',
-    'str2datetime',
-    'json',
-    'listfile',
-    'decompress',
-    'home',
-    'sysname',
-    'read_by_block',
-    'RedirectStd12ToNull',
-]
-
-
-class Singleton(type):
-    """
-    单例模式
-    使用示例：
-        # 比如使类A为单例模式
-        class A(metaclass=utils.Singleton):
-            pass
-        # res: 得到一个单例类A
-    """
-
-    __instance_lock = Lock()
-
-    def __init__(cls, *args, **kwargs):
-        cls.__instance = None
-        super(Singleton, cls).__init__(*args, **kwargs)
-
-    def __call__(cls, *args, **kwargs):
-        if cls.__instance is None:
-            with cls.__instance_lock:
-                if cls.__instance is None:
-                    cls.__instance = super(Singleton, cls).__call__(*args, **kwargs)
-        return cls.__instance
-
-
-class Chars:
-    """
-    字符
-    使用示例：
-        # 比如获取小写字母
-        low_cases = utils.Chars.lowercases
-        # res: 返回指定的字符
-        +++++[更多详见参数或源码]+++++
-    """
-    lowercases = 'abcdefghijklmnopqrstuvwxyz'
-    uppercases = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-    digits = '0123456789'
-    punctuation = r"""~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/"""
-    whitespace = ' \t\n\r\v\f'
-
-
-def now2str(fmt: str = 'S') -> str:
-    """
-    now datetime to str (获取当前时间的字符串)
-    使用示例：
-        # 比如获取当前时间
-        now = utils.now2str()
-        # 比如获取当前日期
-        now_year = utils.now2str(fmt='d')  # 或者 fmt='%Y-%m-%d'
-        # res: 返回指定格式时间的字符串
-        +++++[更多详见参数或源码]+++++
-    :param fmt:
-    :return:
-    """
-    _ = {
-        'S': '%Y-%m-%d %H:%M:%S',
-        'M': '%Y-%m-%d %H:%M',
-        'H': '%Y-%m-%d %H',
-        'd': '%Y-%m-%d',
-        'm': '%Y-%m',
-        'Y': '%Y'
-    }
-    fmt = _.get(fmt, fmt)
-    str_now = datetime.now().strftime(fmt)
-    return str_now
-
-
-def str2datetime(time_str: str, fmt: str = None) -> datetime:
-    """
-    时间字符串转换成日期（默认自动识别 fmt）
-    使用示例：
-        time_str = '2021-12-12'
-        date = utils.str2datetime(time_str)
-        # res: datetime.datetime(2021, 12, 12, 0, 0)
-        +++++[更多详见参数或源码]+++++
-    :param time_str: 时间字符串
-    :param fmt: 格式化
-    :return:
-    """
-    _ = {
-        19: '%Y-%m-%d %H:%M:%S',
-        16: '%Y-%m-%d %H:%M',
-        13: '%Y-%m-%d %H',
-        10: '%Y-%m-%d',
-        7: '%Y-%m',
-        4: '%Y'
-    }
-    fmt = fmt if fmt else _.get(len(time_str))
-    dt = datetime.strptime(time_str, fmt)
-    return dt
-
-
-def json(data, mode='loads', default=None, *args, **kwargs):
-    """
-    json loads or dumps
-    使用示例：
-        data = {'name': 'x', age: 20}
-        data_json = utils.json(data, mode='dumps')
-        # res: (一个json)
-        +++++[更多详见参数或源码]+++++
-    :param data:
-    :param mode: loads or dumps
-    :param default: 默认值（如果入参data为空，优先返回给定的默认值）
-    :param args:
-    :param kwargs:
-    :return:
-    """
-    mode = choicer(mode, choices=['loads', 'dumps'], lable='mode')
-    if not data:
-        data = default or data
-    else:
-        if mode == 'loads':
-            data = loads(data, *args, **kwargs)
-        else:
-            data = dumps(data, *args, **kwargs)
-    return data
-
-
-def listfile(
-        src: t.Union[str, Path],
-        pattern: str = '*',
-        is_str: bool = False,
-        is_name: bool = False,
-        is_r: bool = False) -> t.Generator:
-    """
-    文件列表
-    使用示例：
-        # 比如获取某目录下的.py文件
-        src_dir = 'D:/tmp'
-        flist = utils.listfile(src_dir, pattern='*.py')
-        # res: 输出匹配的文件路径生成器
-        +++++[更多详见参数或源码]+++++
-    :param src: 源目录
-    :param pattern: 匹配模式
-    :param is_str: 是否返回字符串（True: 若为路径返回字符串，False: 若为路径返回Path类型）
-    :param is_name: 是否获取文件名（True: 返回文件路径，False: 返回文件名）
-    :param is_r: 是否递规查找
-    :return:
-    """
-    src_dir = Path(src).absolute()
-    if not src_dir.is_dir():
-        raise FileNotFoundError(f'{src} directory does not exist')
-    src_files = src_dir.rglob(pattern) if is_r is True else src_dir.glob(pattern)
-    for f in src_files:
-        if f.is_file():
-            if is_name is True:
-                yield f.name
-            else:
-                if is_str is True:
-                    yield f.as_posix()
-                else:
-                    yield f
-
-
-def decompress(
-        src: t.Union[str, Path],
-        dest: t.Union[str, Path] = None,
-        pattern: str = '*[.pzr2]',
-        is_r: bool = False,
-        is_raise: bool = True) -> int:
-    """
-    解压文件
-    使用示例：
-        # 比如解压某目录下的.zip文件
-        src = 'D:/tmp'
-        count = utils.decompress(src, pattern='*.zip')
-        # res: 解压数量
-        +++++[更多详见参数或源码]+++++
-    :param src: 源目录或文件
-    :param dest: 目标目录
-    :param pattern: 匹配模式（当src为目录时生效，默认匹配所有支持的压缩包）
-    :param is_r: 是否递规查找（当src为目录时生效）
-    :param is_raise: 是否抛异常
-    :return: count（解压数量）
-    """
-    __support_types = [
-        '.zip',
-        '.rar',
-        '.tar',
-        '.gz', '.tgz',
-        '.xz', '.txz',
-        '.bz2', '.tbz', '.tbz2', '.tb2',
-    ]
-    src = Path(src).absolute()
-    src_is_dir = False
-    if src.is_dir():
-        src_is_dir = True
-        src_files = listfile(src, pattern=pattern, is_r=is_r)
-    else:
-        if src.suffix not in __support_types:
-            raise ValueError('only supported: %s' % __support_types)
-        src_files = [src]
-    if not dest:
-        dest_dir = src.absolute() if src_is_dir else src.absolute().parent
-    else:
-        dest_dir = Path(dest).absolute()
-        dest_dir.mkdir(parents=True, exist_ok=True)
-    dest_dir.chmod(stat.S_IRWXU)
-    count = 0
-    for src_file in src_files:
-        file_name, file_type = src_file.name, src_file.suffix
-        if file_type:
-            file_type = file_type.lower()
-            if file_type not in __support_types:
-                continue
-        else:
-            continue
-        try:
-            if file_type == '.zip':
-                zip_file = zipfile.ZipFile(src_file)
-                for f in zip_file.namelist():
-                    zip_file.extract(f, dest_dir)
-                zip_file.close()
-            elif file_type == '.rar':
-                rar_file = rarfile.RarFile(src_file)
-                rar_file.extractall(dest_dir)
-                rar_file.close()
-            else:
-                tar_file = tarfile.open(src_file)
-                for name in tar_file.getnames():
-                    tar_file.extract(name, dest_dir)
-                tar_file.close()
-        except:
-            if is_raise is True:
-                raise
-            else:
-                traceback.print_exc()
-        else:
-            count += 1
-    return count
-
-
-def home() -> str:
-    """
-    家目录
-    使用示例：
-        h = utils.home()
-        # res: 返回家目录
-        +++++[更多详见参数或源码]+++++
-    :return:
-    """
-    return os.environ.get("HOME") or os.path.join(os.environ.get("HOMEDRIVE"), os.environ.get("HOMEPATH"))
-
-
-def sysname() -> str:
-    """
-    系统名称
-    使用示例：
-        s = utils.sysname()
-        # res: 返回系统名称
-        +++++[更多详见参数或源码]+++++
-    :return:
-    """
-    name = platform.uname().system
-    if name == 'Linux':
-        try:
-            result = subprocess.run(
-                'cat /etc/*-release',
-                stdout=subprocess.PIPE,
-                stderr=subprocess.DEVNULL,
-                encoding='utf8',
-                shell=True,
-            )
-            r = re.search(r'[\n\s]+ID=(.*?)[\n\s]+', result.stdout)
-            name = r.group(1) if r else name
-        except Exception: pass
-    elif name == 'Darwin': name = 'macOS'
-    return name.lower().replace(' ', '')
-
-
-def read_by_block(file_path: str, block_size: int = 10240, mode: str = 'rb', **kwargs) -> t.Generator:
-    """
-    分块读取
-    使用示例：
-        data = utils.read_by_block('foo.txt')
-        +++++[更多详见参数或源码]+++++
-    :param file_path: 文件路径
-    :param block_size: 块大小
-    :param mode: 模式
-    :param kwargs: open其他参数
-    :return:
-    """
-    with open(file_path, mode=mode, **kwargs) as fp:
-        while True:
-            block = fp.read(block_size)
-            if block:
-                yield block
-            else:
-                break
-
-
-class RedirectStd12ToNull:
-    """
-    重定向标准输出错误到null
-    使用示例：
-        with RedirectStd12ToNull():
-            # 你要重定向的代码块
-        另：取消stderr的重定向
-        with RedirectStd12ToNull(is_stderr=False):
-            # 你要重定向的代码块
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(self, is_stderr: bool = True):
-        """
-        初始化
-        :param is_stderr: 是否重定向stderr
-        """
-        self.is_stderr = is_stderr
-        self.null_1fd = os.open(os.devnull, os.O_RDWR)
-        self.save_1fd = os.dup(1)
-        if self.is_stderr is True:
-            self.null_2fd = os.open(os.devnull, os.O_RDWR)
-            self.save_2fd = os.dup(2)
-
-    def __enter__(self):
-        os.dup2(self.null_1fd, 1)
-        if self.is_stderr is True:
-            os.dup2(self.null_2fd, 2)
-
-    def __exit__(self, *_):
-        os.dup2(self.save_1fd, 1)
-        os.close(self.null_1fd)
-        if self.is_stderr is True:
-            os.dup2(self.save_2fd, 2)
-            os.close(self.null_2fd)
+"""
+@author axiner
+@version v1.0.0
+@created 2021/12/18 22:20
+@abstract 实用工具
+@description
+@history
+"""
+import os
+import platform
+import re
+import stat
+import subprocess
+import tarfile
+import traceback
+from datetime import datetime
+import typing as t
+from json import dumps, loads
+from pathlib import Path
+from threading import Lock
+
+from toollib.common import rarfile, zipfile
+from toollib.validator import choicer
+
+__all__ = [
+    'Singleton',
+    'Chars',
+    'now2str',
+    'str2datetime',
+    'json',
+    'listfile',
+    'decompress',
+    'home',
+    'sysname',
+    'read_by_block',
+    'RedirectStd12ToNull',
+]
+
+
+class Singleton(type):
+    """
+    单例模式
+    使用示例：
+        # 比如使类A为单例模式
+        class A(metaclass=utils.Singleton):
+            pass
+        # res: 得到一个单例类A
+    """
+
+    __instance_lock = Lock()
+
+    def __init__(cls, *args, **kwargs):
+        cls.__instance = None
+        super(Singleton, cls).__init__(*args, **kwargs)
+
+    def __call__(cls, *args, **kwargs):
+        if cls.__instance is None:
+            with cls.__instance_lock:
+                if cls.__instance is None:
+                    cls.__instance = super(Singleton, cls).__call__(*args, **kwargs)
+        return cls.__instance
+
+
+class Chars:
+    """
+    字符
+    使用示例：
+        # 比如获取小写字母
+        low_cases = utils.Chars.lowercases
+        # res: 返回指定的字符
+        +++++[更多详见参数或源码]+++++
+    """
+    lowercases = 'abcdefghijklmnopqrstuvwxyz'
+    uppercases = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+    digits = '0123456789'
+    punctuation = r"""~`!@#$%^&*()_-+={[}]|\:;"'<,>.?/"""
+    whitespace = ' \t\n\r\v\f'
+
+
+def now2str(fmt: str = 'S') -> str:
+    """
+    now datetime to str (获取当前时间的字符串)
+    使用示例：
+        # 比如获取当前时间
+        now = utils.now2str()
+        # 比如获取当前日期
+        now_year = utils.now2str(fmt='d')  # 或者 fmt='%Y-%m-%d'
+        # res: 返回指定格式时间的字符串
+        +++++[更多详见参数或源码]+++++
+    :param fmt:
+    :return:
+    """
+    _ = {
+        'S': '%Y-%m-%d %H:%M:%S',
+        'M': '%Y-%m-%d %H:%M',
+        'H': '%Y-%m-%d %H',
+        'd': '%Y-%m-%d',
+        'm': '%Y-%m',
+        'Y': '%Y'
+    }
+    fmt = _.get(fmt, fmt)
+    str_now = datetime.now().strftime(fmt)
+    return str_now
+
+
+def str2datetime(time_str: str, fmt: str = None) -> datetime:
+    """
+    时间字符串转换成日期（默认自动识别 fmt）
+    使用示例：
+        time_str = '2021-12-12'
+        date = utils.str2datetime(time_str)
+        # res: datetime.datetime(2021, 12, 12, 0, 0)
+        +++++[更多详见参数或源码]+++++
+    :param time_str: 时间字符串
+    :param fmt: 格式化
+    :return:
+    """
+    _ = {
+        19: '%Y-%m-%d %H:%M:%S',
+        16: '%Y-%m-%d %H:%M',
+        13: '%Y-%m-%d %H',
+        10: '%Y-%m-%d',
+        7: '%Y-%m',
+        4: '%Y'
+    }
+    fmt = fmt if fmt else _.get(len(time_str))
+    dt = datetime.strptime(time_str, fmt)
+    return dt
+
+
+def json(data, mode='loads', default=None, *args, **kwargs):
+    """
+    json loads or dumps
+    使用示例：
+        data = {'name': 'x', age: 20}
+        data_json = utils.json(data, mode='dumps')
+        # res: (一个json)
+        +++++[更多详见参数或源码]+++++
+    :param data:
+    :param mode: loads or dumps
+    :param default: 默认值（如果入参data为空，优先返回给定的默认值）
+    :param args:
+    :param kwargs:
+    :return:
+    """
+    mode = choicer(mode, choices=['loads', 'dumps'], lable='mode')
+    if not data:
+        data = default or data
+    else:
+        if mode == 'loads':
+            data = loads(data, *args, **kwargs)
+        else:
+            data = dumps(data, *args, **kwargs)
+    return data
+
+
+def listfile(
+        src: t.Union[str, Path],
+        pattern: str = '*',
+        is_str: bool = False,
+        is_name: bool = False,
+        is_r: bool = False) -> t.Generator:
+    """
+    文件列表
+    使用示例：
+        # 比如获取某目录下的.py文件
+        src_dir = 'D:/tmp'
+        flist = utils.listfile(src_dir, pattern='*.py')
+        # res: 输出匹配的文件路径生成器
+        +++++[更多详见参数或源码]+++++
+    :param src: 源目录
+    :param pattern: 匹配模式
+    :param is_str: 是否返回字符串（True: 若为路径返回字符串，False: 若为路径返回Path类型）
+    :param is_name: 是否获取文件名（True: 返回文件路径，False: 返回文件名）
+    :param is_r: 是否递规查找
+    :return:
+    """
+    src_dir = Path(src).absolute()
+    if not src_dir.is_dir():
+        raise FileNotFoundError(f'{src} directory does not exist')
+    src_files = src_dir.rglob(pattern) if is_r is True else src_dir.glob(pattern)
+    for f in src_files:
+        if f.is_file():
+            if is_name is True:
+                yield f.name
+            else:
+                if is_str is True:
+                    yield f.as_posix()
+                else:
+                    yield f
+
+
+def decompress(
+        src: t.Union[str, Path],
+        dest: t.Union[str, Path] = None,
+        pattern: str = '*[.pzr2]',
+        is_r: bool = False,
+        is_raise: bool = True) -> int:
+    """
+    解压文件
+    使用示例：
+        # 比如解压某目录下的.zip文件
+        src = 'D:/tmp'
+        count = utils.decompress(src, pattern='*.zip')
+        # res: 解压数量
+        +++++[更多详见参数或源码]+++++
+    :param src: 源目录或文件
+    :param dest: 目标目录
+    :param pattern: 匹配模式（当src为目录时生效，默认匹配所有支持的压缩包）
+    :param is_r: 是否递规查找（当src为目录时生效）
+    :param is_raise: 是否抛异常
+    :return: count（解压数量）
+    """
+    __support_types = [
+        '.zip',
+        '.rar',
+        '.tar',
+        '.gz', '.tgz',
+        '.xz', '.txz',
+        '.bz2', '.tbz', '.tbz2', '.tb2',
+    ]
+    src = Path(src).absolute()
+    src_is_dir = False
+    if src.is_dir():
+        src_is_dir = True
+        src_files = listfile(src, pattern=pattern, is_r=is_r)
+    else:
+        if src.suffix not in __support_types:
+            raise ValueError('only supported: %s' % __support_types)
+        src_files = [src]
+    if not dest:
+        dest_dir = src.absolute() if src_is_dir else src.absolute().parent
+    else:
+        dest_dir = Path(dest).absolute()
+        dest_dir.mkdir(parents=True, exist_ok=True)
+    dest_dir.chmod(stat.S_IRWXU)
+    count = 0
+    for src_file in src_files:
+        file_name, file_type = src_file.name, src_file.suffix
+        if file_type:
+            file_type = file_type.lower()
+            if file_type not in __support_types:
+                continue
+        else:
+            continue
+        try:
+            if file_type == '.zip':
+                zip_file = zipfile.ZipFile(src_file)
+                for f in zip_file.namelist():
+                    zip_file.extract(f, dest_dir)
+                zip_file.close()
+            elif file_type == '.rar':
+                rar_file = rarfile.RarFile(src_file)
+                rar_file.extractall(dest_dir)
+                rar_file.close()
+            else:
+                tar_file = tarfile.open(src_file)
+                for name in tar_file.getnames():
+                    tar_file.extract(name, dest_dir)
+                tar_file.close()
+        except:
+            if is_raise is True:
+                raise
+            else:
+                traceback.print_exc()
+        else:
+            count += 1
+    return count
+
+
+def home() -> str:
+    """
+    家目录
+    使用示例：
+        h = utils.home()
+        # res: 返回家目录
+        +++++[更多详见参数或源码]+++++
+    :return:
+    """
+    return os.environ.get("HOME") or os.path.join(os.environ.get("HOMEDRIVE"), os.environ.get("HOMEPATH"))
+
+
+def sysname() -> str:
+    """
+    系统名称
+    使用示例：
+        s = utils.sysname()
+        # res: 返回系统名称
+        +++++[更多详见参数或源码]+++++
+    :return:
+    """
+    name = platform.uname().system
+    if name == 'Linux':
+        try:
+            result = subprocess.run(
+                'cat /etc/*-release',
+                stdout=subprocess.PIPE,
+                stderr=subprocess.DEVNULL,
+                encoding='utf8',
+                shell=True,
+            )
+            r = re.search(r'[\n\s]+ID=(.*?)[\n\s]+', result.stdout)
+            name = r.group(1) if r else name
+        except Exception: pass
+    elif name == 'Darwin': name = 'macOS'
+    return name.lower().replace(' ', '')
+
+
+def read_by_block(file_path: str, block_size: int = 10240, mode: str = 'rb', **kwargs) -> t.Generator:
+    """
+    分块读取
+    使用示例：
+        data = utils.read_by_block('foo.txt')
+        +++++[更多详见参数或源码]+++++
+    :param file_path: 文件路径
+    :param block_size: 块大小
+    :param mode: 模式
+    :param kwargs: open其他参数
+    :return:
+    """
+    with open(file_path, mode=mode, **kwargs) as fp:
+        while True:
+            block = fp.read(block_size)
+            if block:
+                yield block
+            else:
+                break
+
+
+class RedirectStd12ToNull:
+    """
+    重定向标准输出错误到null
+    使用示例：
+        with RedirectStd12ToNull():
+            # 你要重定向的代码块
+        另：取消stderr的重定向
+        with RedirectStd12ToNull(is_stderr=False):
+            # 你要重定向的代码块
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(self, is_stderr: bool = True):
+        """
+        初始化
+        :param is_stderr: 是否重定向stderr
+        """
+        self.is_stderr = is_stderr
+        self.null_1fd = os.open(os.devnull, os.O_RDWR)
+        self.save_1fd = os.dup(1)
+        if self.is_stderr is True:
+            self.null_2fd = os.open(os.devnull, os.O_RDWR)
+            self.save_2fd = os.dup(2)
+
+    def __enter__(self):
+        os.dup2(self.null_1fd, 1)
+        if self.is_stderr is True:
+            os.dup2(self.null_2fd, 2)
+
+    def __exit__(self, *_):
+        os.dup2(self.save_1fd, 1)
+        os.close(self.null_1fd)
+        if self.is_stderr is True:
+            os.dup2(self.save_2fd, 2)
+            os.close(self.null_2fd)
```

## toollib/validator.py

 * *Ordering differences only*

```diff
@@ -1,113 +1,113 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/3/5 0:03
-@abstract 校验器
-@description
-@history
-"""
-import platform
-import re
-
-__all__ = [
-    'Attr',
-    'choicer',
-    'pyv',
-]
-
-
-class Attr:
-    """
-    属性校验（数据描述符）
-    使用示例：
-        请查看数据描述符中数据校验.....
-        +++++[更多详见参数或源码]+++++
-    """
-
-    def __init__(self, key, ktype=None, required=False, enum=None, regex=None, callback=None,
-                 error_msg=None, empty_msg=None):
-        self.key = key
-        self.ktype = ktype
-        self.required = required
-        self.enum = enum
-        self.regex = regex
-        self.callback = callback
-        self.error_msg = error_msg
-        self.empty_msg = empty_msg or '"%s" cannot be empty' % self.key
-
-    def __get__(self, instance, owner):
-        return instance.__dict__[self.key]
-
-    def __set__(self, instance, value):
-        if value is None:
-            if self.required is True:
-                raise TypeError(self.empty_msg)
-        else:
-            if self.ktype:
-                if not isinstance(value, self.ktype):
-                    error_msg = self.error_msg
-                    if not error_msg:
-                        error_msg = f'"%s" only supported: %s' % (self.key, self.ktype)
-                    raise TypeError(error_msg)
-            elif self.enum is not None:
-                if isinstance(self.enum, (list, tuple)):
-                    if value not in self.enum:
-                        error_msg = self.error_msg
-                        if not error_msg:
-                            error_msg = '"%s" only select from: %s' % (self.key, self.ktype)
-                        raise TypeError(error_msg)
-                else:
-                    raise TypeError('"enum" only supported: list or tuple')
-            elif self.regex is not None:
-                if re.match(self.regex, value) is None:
-                    raise TypeError('"%s" only supported: %s' % (self.key, self.regex))
-
-            if self.callback is not None:
-                self.callback(value)
-        instance.__dict__[self.key] = value
-
-    def __delete__(self, instance):
-        instance.__dict__.pop(self.key)
-
-
-def choicer(obj, choices: list, lable: str = None, errmsg: str = None):
-    """
-    选择校验（校验通过时返回obj）
-    使用示例：
-        flag = 1
-        flag = validator.choicer(flag, choices=[1,2,3], lable='标识')
-        # res: 若校验不通过则报异常
-        +++++[更多详见参数或源码]+++++
-    :param obj: 对象
-    :param choices: 可选范围
-    :param lable: 标签
-    :param errmsg: 不在可选范围时报错信息
-    :return:
-    """
-    if obj not in choices:
-        if not errmsg:
-            errmsg = 'only supported: %s' % choices
-            if lable:
-                errmsg = '"%s" %s' % (lable, errmsg)
-        raise TypeError(errmsg)
-    return obj
-
-
-def pyv(min_v: str = '3.7', max_v: str = None) -> str:
-    """
-    python版本校验
-    使用示例：
-        pyv = validator.pyv(min_v='3.7')
-        # res: 若校验不通过则报异常
-        +++++[更多详见参数或源码]+++++
-    :param min_v: 最小版本号（包含）
-    :param max_v: 最大版本号（不包含）
-    :return:
-    """
-    _pyv = platform.python_version()
-    if _pyv < min_v:
-        raise Warning('python version required >= %s' % min_v)
-    if max_v:
-        if _pyv >= max_v:
-            raise Warning('python version required < %s' % max_v)
-    return _pyv
+"""
+@author axiner
+@version v1.0.0
+@created 2022/3/5 0:03
+@abstract 校验器
+@description
+@history
+"""
+import platform
+import re
+
+__all__ = [
+    'Attr',
+    'choicer',
+    'pyv',
+]
+
+
+class Attr:
+    """
+    属性校验（数据描述符）
+    使用示例：
+        请查看数据描述符中数据校验.....
+        +++++[更多详见参数或源码]+++++
+    """
+
+    def __init__(self, key, ktype=None, required=False, enum=None, regex=None, callback=None,
+                 error_msg=None, empty_msg=None):
+        self.key = key
+        self.ktype = ktype
+        self.required = required
+        self.enum = enum
+        self.regex = regex
+        self.callback = callback
+        self.error_msg = error_msg
+        self.empty_msg = empty_msg or '"%s" cannot be empty' % self.key
+
+    def __get__(self, instance, owner):
+        return instance.__dict__[self.key]
+
+    def __set__(self, instance, value):
+        if value is None:
+            if self.required is True:
+                raise TypeError(self.empty_msg)
+        else:
+            if self.ktype:
+                if not isinstance(value, self.ktype):
+                    error_msg = self.error_msg
+                    if not error_msg:
+                        error_msg = f'"%s" only supported: %s' % (self.key, self.ktype)
+                    raise TypeError(error_msg)
+            elif self.enum is not None:
+                if isinstance(self.enum, (list, tuple)):
+                    if value not in self.enum:
+                        error_msg = self.error_msg
+                        if not error_msg:
+                            error_msg = '"%s" only select from: %s' % (self.key, self.ktype)
+                        raise TypeError(error_msg)
+                else:
+                    raise TypeError('"enum" only supported: list or tuple')
+            elif self.regex is not None:
+                if re.match(self.regex, value) is None:
+                    raise TypeError('"%s" only supported: %s' % (self.key, self.regex))
+
+            if self.callback is not None:
+                self.callback(value)
+        instance.__dict__[self.key] = value
+
+    def __delete__(self, instance):
+        instance.__dict__.pop(self.key)
+
+
+def choicer(obj, choices: list, lable: str = None, errmsg: str = None):
+    """
+    选择校验（校验通过时返回obj）
+    使用示例：
+        flag = 1
+        flag = validator.choicer(flag, choices=[1,2,3], lable='标识')
+        # res: 若校验不通过则报异常
+        +++++[更多详见参数或源码]+++++
+    :param obj: 对象
+    :param choices: 可选范围
+    :param lable: 标签
+    :param errmsg: 不在可选范围时报错信息
+    :return:
+    """
+    if obj not in choices:
+        if not errmsg:
+            errmsg = 'only supported: %s' % choices
+            if lable:
+                errmsg = '"%s" %s' % (lable, errmsg)
+        raise TypeError(errmsg)
+    return obj
+
+
+def pyv(min_v: str = '3.7', max_v: str = None) -> str:
+    """
+    python版本校验
+    使用示例：
+        pyv = validator.pyv(min_v='3.7')
+        # res: 若校验不通过则报异常
+        +++++[更多详见参数或源码]+++++
+    :param min_v: 最小版本号（包含）
+    :param max_v: 最大版本号（不包含）
+    :return:
+    """
+    _pyv = platform.python_version()
+    if _pyv < min_v:
+        raise Warning('python version required >= %s' % min_v)
+    if max_v:
+        if _pyv >= max_v:
+            raise Warning('python version required < %s' % max_v)
+    return _pyv
```

## toollib/xlsx.py

 * *Ordering differences only*

```diff
@@ -1,214 +1,214 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/1/23 20:36
-@abstract xlsx（基于openpyxl库）
-@description
-@history
-"""
-import typing as t
-
-from toollib.validator import choicer
-
-try:
-    from openpyxl.worksheet.worksheet import Worksheet
-except ImportError:
-    raise
-
-__all__ = [
-    'ws_inserts',
-    'ws_rows_value',
-    'ws_cols_value',
-    'ws_styles',
-]
-
-
-def ws_inserts(ws: Worksheet, values: t.List[list], index: int = None,
-               mode: str = 'r', is_new: bool = True):
-    """
-    插入数据
-    使用示例：
-        from openpyxl import load_workbook
-        wb = load_workbook('D:/tmp/t.xlsx')
-        ws = wb.active
-        values = [[1, 2, 3, 4, 5]]
-        xlsx.ws_inserts(ws, values, index=1)
-        .....
-        +++++[更多详见参数或源码]+++++
-    :param ws: Worksheet实例（openpyxl库）
-    :param values: 值（eg: [[1, 2, 3], [4, 5, 6]]）
-    :param index: 从哪开始插入值，若为None则追加（正整数）
-    :param mode: 插入模式（r: 插入行值，c: 插入列值）
-    :param is_new: 是否插入新的行|列（True: 是，False: 否，若有值则会覆盖）
-    :return:
-    """
-    _len = len(values)
-    mode = choicer(mode, choices=['r', 'c'], lable='mode')
-    if index is None and mode == 'c':
-        index = ws.max_column + 1
-    if index is not None:
-        if isinstance(index, int):
-            if index < 1:
-                raise ValueError('"index" greater than 0')
-        else:
-            raise ValueError('"index" only supported: int')
-        if is_new is True:
-            if mode == 'r':
-                ws.insert_rows(index, _len)
-            else:
-                ws.insert_cols(index, _len)
-        for r, item in enumerate(values):
-            _i = r + index
-            for c, v in enumerate(item, 1):
-                if mode == 'r':
-                    _r, _c = _i, c
-                else:
-                    _r, _c = c, _i
-                ws.cell(_r, _c, v)
-    else:
-        for item in values:
-            ws.append(item)
-
-
-def ws_rows_value(ws: Worksheet):
-    """
-    所有行的值
-    使用示例：
-        from openpyxl import load_workbook
-        wb = load_workbook('D:/tmp/t.xlsx')
-        ws = wb.active
-        rows = xlsx.ws_rows_value()
-        # res: 返回所有行的值（生成器对象）
-        +++++[更多详见参数或源码]+++++
-    :param ws: Worksheet实例（openpyxl库）
-    :return:
-    """
-    for item in ws.rows:
-        yield [r.value for r in item]
-
-
-def ws_cols_value(ws: Worksheet):
-    """
-    所有列的值
-    使用示例：
-        from openpyxl import load_workbook
-        wb = load_workbook('D:/tmp/t.xlsx')
-        ws = wb.active
-        cols = xlsx.ws_cols_value()
-        # res: 返回所有列的值（生成器对象）
-        +++++[更多详见参数或源码]+++++
-    :param ws: Worksheet实例（openpyxl库）
-    :return:
-    """
-    for item in ws.columns:
-        yield [c.value for c in item]
-
-
-def ws_styles(
-        ws,
-        styles: dict,
-        by_icells: str = None,
-        by_cells: t.Union[str, t.List[str]] = None,
-        by_rows: t.Union[int, t.List[int]] = None,
-        by_cols: t.Union[str, t.List[str]] = None,
-        exclude_icell: t.Union[t.List[t.Tuple[int, int]], t.Tuple[int, int]] = None,
-):
-    """
-    修改样式
-    使用示例：
-        from openpyxl import load_workbook
-        from openpyxl.styles import PatternFill
-        wb = load_workbook('D:/tmp/t.xlsx')
-        ws = wb.active
-        fill = PatternFill(fill_type=None, start_color=’FFFFFF‘, end_color=‘000000’)
-        styles = {'fill': fill}
-        xlsx.ws_styles(styles, by_icells='0,0')
-        .....
-        +++++[更多详见参数或源码]+++++
-    注：by_icells |by_cells |by_rows |by_cols，只支持其中一种方式（若传入多则只取第一种方式）
-    :param ws: Worksheet实例（openpyxl库）
-    :param styles: 样式。以字典形式传入（key可为：font, fill, border等）
-    :param by_icells: 按单元格索引（若索引为0，则表示从1至最大行或列）。eg: '1:2,1:2' >>> 左行：1至2行，右列：1至2列
-    :param by_cells: 按单元格。eg: 'A1' or ['A1', 'B1', 'C1']
-    :param by_rows: 按行。eg: 1 or [1, 2, 3]
-    :param by_cols: 按列。eg: 'A' or ['A', 'B', 'C']
-    :param exclude_icell: 排除的单元格（by_icells方式下生效）
-    :return:
-    """
-    if by_icells:
-        by_icells = by_icells.strip()
-        if by_icells in ['0', '0:0']:
-            rows, cols = (1, ws.max_row), (1, ws.max_column)
-        else:
-            if by_icells.find(',') == -1:
-                by_icells += ','
-            rows, cols = by_icells.split(',')
-            if not rows:
-                rows = (1, ws.max_row)
-            else:
-                if rows.find(':') == -1:
-                    _row = int(rows)
-                    rows = (_row, _row)
-                else:
-                    _lrow, _rrow = rows.split(':')
-                    rows = (int(_lrow), int(_rrow))
-            if not cols:
-                cols = (1, ws.max_column)
-            else:
-                if cols.find(':') == -1:
-                    _col = int(cols)
-                    cols = (_col, _col)
-                else:
-                    _lcol, _rcol = cols.split(':')
-                    cols = (int(_lcol), int(_rcol))
-        for r in range(rows[0], rows[1]+1):
-            for c in range(cols[0], cols[1]+1):
-                _curr_icell = (r, c)
-                if isinstance(exclude_icell, tuple):
-                    if _curr_icell == exclude_icell:
-                        continue
-                elif isinstance(exclude_icell, list):
-                    if exclude_icell.count(_curr_icell) > 0:
-                        continue
-                ws_scope = ws.cell(r, c)
-                for stl, stl_value in styles.items():
-                    try:
-                        getattr(ws_scope, stl)
-                    except AttributeError:
-                        raise
-                    setattr(ws_scope, stl, stl_value)
-    elif by_cells:
-        if isinstance(by_cells, str):
-            by_cells = [by_cells]
-        for cell in by_cells:
-            ws_scope = ws[cell]
-            for stl, stl_value in styles.items():
-                try:
-                    getattr(ws_scope, stl)
-                except AttributeError:
-                    raise
-                setattr(ws_scope, stl, stl_value)
-    elif by_rows:
-        if isinstance(by_rows, int):
-            by_rows = [by_rows]
-        for row in by_rows:
-            ws_scope = ws.row_dimensions[row]
-            for stl, stl_value in styles.items():
-                try:
-                    getattr(ws_scope, stl)
-                except AttributeError:
-                    raise
-                setattr(ws_scope, stl, stl_value)
-    elif by_cols:
-        if isinstance(by_cols, str):
-            by_cols = [by_cols]
-        for col in by_cols:
-            ws_scope = ws.column_dimensions[col]
-            for stl, stl_value in styles.items():
-                try:
-                    getattr(ws_scope, stl)
-                except AttributeError:
-                    raise
-                setattr(ws_scope, stl, stl_value)
-    else:
-        raise ValueError('"by_icells" |"by_cells" |"by_rows" |"by_cols" is required')
+"""
+@author axiner
+@version v1.0.0
+@created 2022/1/23 20:36
+@abstract xlsx（基于openpyxl库）
+@description
+@history
+"""
+import typing as t
+
+from toollib.validator import choicer
+
+try:
+    from openpyxl.worksheet.worksheet import Worksheet
+except ImportError:
+    raise
+
+__all__ = [
+    'ws_inserts',
+    'ws_rows_value',
+    'ws_cols_value',
+    'ws_styles',
+]
+
+
+def ws_inserts(ws: Worksheet, values: t.List[list], index: int = None,
+               mode: str = 'r', is_new: bool = True):
+    """
+    插入数据
+    使用示例：
+        from openpyxl import load_workbook
+        wb = load_workbook('D:/tmp/t.xlsx')
+        ws = wb.active
+        values = [[1, 2, 3, 4, 5]]
+        xlsx.ws_inserts(ws, values, index=1)
+        .....
+        +++++[更多详见参数或源码]+++++
+    :param ws: Worksheet实例（openpyxl库）
+    :param values: 值（eg: [[1, 2, 3], [4, 5, 6]]）
+    :param index: 从哪开始插入值，若为None则追加（正整数）
+    :param mode: 插入模式（r: 插入行值，c: 插入列值）
+    :param is_new: 是否插入新的行|列（True: 是，False: 否，若有值则会覆盖）
+    :return:
+    """
+    _len = len(values)
+    mode = choicer(mode, choices=['r', 'c'], lable='mode')
+    if index is None and mode == 'c':
+        index = ws.max_column + 1
+    if index is not None:
+        if isinstance(index, int):
+            if index < 1:
+                raise ValueError('"index" greater than 0')
+        else:
+            raise ValueError('"index" only supported: int')
+        if is_new is True:
+            if mode == 'r':
+                ws.insert_rows(index, _len)
+            else:
+                ws.insert_cols(index, _len)
+        for r, item in enumerate(values):
+            _i = r + index
+            for c, v in enumerate(item, 1):
+                if mode == 'r':
+                    _r, _c = _i, c
+                else:
+                    _r, _c = c, _i
+                ws.cell(_r, _c, v)
+    else:
+        for item in values:
+            ws.append(item)
+
+
+def ws_rows_value(ws: Worksheet):
+    """
+    所有行的值
+    使用示例：
+        from openpyxl import load_workbook
+        wb = load_workbook('D:/tmp/t.xlsx')
+        ws = wb.active
+        rows = xlsx.ws_rows_value()
+        # res: 返回所有行的值（生成器对象）
+        +++++[更多详见参数或源码]+++++
+    :param ws: Worksheet实例（openpyxl库）
+    :return:
+    """
+    for item in ws.rows:
+        yield [r.value for r in item]
+
+
+def ws_cols_value(ws: Worksheet):
+    """
+    所有列的值
+    使用示例：
+        from openpyxl import load_workbook
+        wb = load_workbook('D:/tmp/t.xlsx')
+        ws = wb.active
+        cols = xlsx.ws_cols_value()
+        # res: 返回所有列的值（生成器对象）
+        +++++[更多详见参数或源码]+++++
+    :param ws: Worksheet实例（openpyxl库）
+    :return:
+    """
+    for item in ws.columns:
+        yield [c.value for c in item]
+
+
+def ws_styles(
+        ws,
+        styles: dict,
+        by_icells: str = None,
+        by_cells: t.Union[str, t.List[str]] = None,
+        by_rows: t.Union[int, t.List[int]] = None,
+        by_cols: t.Union[str, t.List[str]] = None,
+        exclude_icell: t.Union[t.List[t.Tuple[int, int]], t.Tuple[int, int]] = None,
+):
+    """
+    修改样式
+    使用示例：
+        from openpyxl import load_workbook
+        from openpyxl.styles import PatternFill
+        wb = load_workbook('D:/tmp/t.xlsx')
+        ws = wb.active
+        fill = PatternFill(fill_type=None, start_color=’FFFFFF‘, end_color=‘000000’)
+        styles = {'fill': fill}
+        xlsx.ws_styles(styles, by_icells='0,0')
+        .....
+        +++++[更多详见参数或源码]+++++
+    注：by_icells |by_cells |by_rows |by_cols，只支持其中一种方式（若传入多则只取第一种方式）
+    :param ws: Worksheet实例（openpyxl库）
+    :param styles: 样式。以字典形式传入（key可为：font, fill, border等）
+    :param by_icells: 按单元格索引（若索引为0，则表示从1至最大行或列）。eg: '1:2,1:2' >>> 左行：1至2行，右列：1至2列
+    :param by_cells: 按单元格。eg: 'A1' or ['A1', 'B1', 'C1']
+    :param by_rows: 按行。eg: 1 or [1, 2, 3]
+    :param by_cols: 按列。eg: 'A' or ['A', 'B', 'C']
+    :param exclude_icell: 排除的单元格（by_icells方式下生效）
+    :return:
+    """
+    if by_icells:
+        by_icells = by_icells.strip()
+        if by_icells in ['0', '0:0']:
+            rows, cols = (1, ws.max_row), (1, ws.max_column)
+        else:
+            if by_icells.find(',') == -1:
+                by_icells += ','
+            rows, cols = by_icells.split(',')
+            if not rows:
+                rows = (1, ws.max_row)
+            else:
+                if rows.find(':') == -1:
+                    _row = int(rows)
+                    rows = (_row, _row)
+                else:
+                    _lrow, _rrow = rows.split(':')
+                    rows = (int(_lrow), int(_rrow))
+            if not cols:
+                cols = (1, ws.max_column)
+            else:
+                if cols.find(':') == -1:
+                    _col = int(cols)
+                    cols = (_col, _col)
+                else:
+                    _lcol, _rcol = cols.split(':')
+                    cols = (int(_lcol), int(_rcol))
+        for r in range(rows[0], rows[1]+1):
+            for c in range(cols[0], cols[1]+1):
+                _curr_icell = (r, c)
+                if isinstance(exclude_icell, tuple):
+                    if _curr_icell == exclude_icell:
+                        continue
+                elif isinstance(exclude_icell, list):
+                    if exclude_icell.count(_curr_icell) > 0:
+                        continue
+                ws_scope = ws.cell(r, c)
+                for stl, stl_value in styles.items():
+                    try:
+                        getattr(ws_scope, stl)
+                    except AttributeError:
+                        raise
+                    setattr(ws_scope, stl, stl_value)
+    elif by_cells:
+        if isinstance(by_cells, str):
+            by_cells = [by_cells]
+        for cell in by_cells:
+            ws_scope = ws[cell]
+            for stl, stl_value in styles.items():
+                try:
+                    getattr(ws_scope, stl)
+                except AttributeError:
+                    raise
+                setattr(ws_scope, stl, stl_value)
+    elif by_rows:
+        if isinstance(by_rows, int):
+            by_rows = [by_rows]
+        for row in by_rows:
+            ws_scope = ws.row_dimensions[row]
+            for stl, stl_value in styles.items():
+                try:
+                    getattr(ws_scope, stl)
+                except AttributeError:
+                    raise
+                setattr(ws_scope, stl, stl_value)
+    elif by_cols:
+        if isinstance(by_cols, str):
+            by_cols = [by_cols]
+        for col in by_cols:
+            ws_scope = ws.column_dimensions[col]
+            for stl, stl_value in styles.items():
+                try:
+                    getattr(ws_scope, stl)
+                except AttributeError:
+                    raise
+                setattr(ws_scope, stl, stl_value)
+    else:
+        raise ValueError('"by_icells" |"by_cells" |"by_rows" |"by_cols" is required')
```

## toollib/__pycache__/__init__.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Mon Apr 24 07:23:13 2023 UTC, .py size: 223 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,21 +1,21 @@
-00000000: 550d 0d0a 0000 0000 612e 4664 df00 0000  U.......a.Fd....
+00000000: 550d 0d0a 0000 0000 6142 4664 df00 0000  U.......aBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0002 0000 0040 0000 0073 2600 0000 6400  .....@...s&...d.
 00000030: 5a00 6401 6402 6c01 6d02 5a02 0100 6502  Z.d.d.l.m.Z...e.
 00000040: 6503 8301 a004 a100 6a05 5a06 6403 5a07  e.......j.Z.d.Z.
 00000050: 6404 5300 2905 7a72 0a40 6175 7468 6f72  d.S.).zr.@author
 00000060: 2061 7869 6e65 720a 4076 6572 7369 6f6e   axiner.@version
 00000070: 2076 312e 302e 300a 4063 7265 6174 6564   v1.0.0.@created
 00000080: 2032 3032 312f 3132 2f31 3220 3133 3a31   2021/12/12 13:1
 00000090: 340a 4061 6273 7472 6163 7420 5468 6973  4.@abstract This
 000000a0: 2069 7320 6120 746f 6f6c 206c 6962 7261   is a tool libra
 000000b0: 7279 2e0a 4064 6573 6372 6970 7469 6f6e  ry..@description
 000000c0: 0a40 6869 7374 6f72 790a e900 0000 0029  .@history......)
-000000d0: 01da 0450 6174 687a 0531 2e33 2e35 4e29  ...Pathz.1.3.5N)
+000000d0: 01da 0450 6174 687a 0531 2e33 2e36 4e29  ...Pathz.1.3.6N)
 000000e0: 08da 075f 5f64 6f63 5f5f da07 7061 7468  ...__doc__..path
 000000f0: 6c69 6272 0200 0000 da08 5f5f 6669 6c65  libr......__file
 00000100: 5f5f da08 6162 736f 6c75 7465 da06 7061  __..absolute..pa
 00000110: 7265 6e74 da04 6865 7265 da0b 5f5f 7665  rent..here..__ve
 00000120: 7273 696f 6e5f 5fa9 0072 0a00 0000 720a  rsion__..r....r.
 00000130: 0000 00fa 3144 3a5c 7662 6f78 5c76 7368  ....1D:\vbox\vsh
 00000140: 6172 6564 5c6d 7967 6974 5c74 6f6f 6c6c  ared\mygit\tooll
```

## toollib/__pycache__/autodriver.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 5333 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 d514 0000  U.........ec....
+00000000: 550d 0d0a 0000 0000 4442 4664 4a14 0000  U.......DBFdJ...
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0006 0000 0040 0000 0073 8000 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a03 6401 6402 6c04  Z.d.d.l.Z.d.d.l.
 00000050: 5a05 6401 6402 6c06 6d07 5a08 0100 6401  Z.d.d.l.m.Z...d.
 00000060: 6403 6c09 6d0a 5a0a 0100 6401 6404 6c0b  d.l.m.Z...d.d.l.
 00000070: 6d0c 5a0c 0100 6405 6701 5a0d 640d 6505  m.Z...d.g.Z.d.e.
```

## toollib/__pycache__/crypto.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 5568 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 c015 0000  U.........ec....
+00000000: 550d 0d0a 0000 0000 4442 4664 1115 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0006 0000 0040 0000 0073 8e00 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a02 6401 6403 6c03  Z.d.d.l.Z.d.d.l.
 00000040: 6d04 5a04 0100 6401 6404 6c05 6d06 5a06  m.Z...d.d.l.m.Z.
 00000050: 0100 6405 6406 6407 6408 6704 5a07 6416  ..d.d.d.d.g.Z.d.
 00000060: 6508 6509 640a 9c02 640b 6405 8405 5a0a  e.e.d...d.d...Z.
 00000070: 6417 650b 640d 9c01 640e 6406 8405 5a0c  d.e.d...d.d...Z.
```

## toollib/__pycache__/decorator.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Sun Apr 23 06:21:37 2023 UTC, .py size: 3140 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 71ce 4464 440c 0000  U.......q.DdD...
+00000000: 550d 0d0a 0000 0000 4442 4664 c90b 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0005 0000 0040 0000 0073 a000 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a03 6401 6402 6c04  Z.d.d.l.Z.d.d.l.
 00000050: 5a04 6401 6402 6c05 5a06 6401 6403 6c07  Z.d.d.l.Z.d.d.l.
 00000060: 6d08 5a08 0100 6401 6404 6c09 6d0a 5a0a  m.Z...d.d.l.m.Z.
 00000070: 0100 6405 6406 6407 6408 6704 5a0b 6409  ..d.d.d.d.g.Z.d.
```

## toollib/__pycache__/guid.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Sun Dec  4 15:23:11 2022 UTC, .py size: 7768 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 5fbb 8c63 581e 0000  U......._..cX...
+00000000: 550d 0d0a 0000 0000 4442 4664 881d 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0005 0000 0040 0000 0073 7400 0000 6400  .....@...st...d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6403 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 6d02 5a02 6d03 5a03 0100 6401 6402 6c04  m.Z.m.Z...d.d.l.
 00000050: 5a05 6401 6404 6c06 6d07 5a07 0100 6401  Z.d.d.l.m.Z...d.
 00000060: 6405 6c08 6d09 5a09 6d0a 5a0a 0100 6406  d.l.m.Z.m.Z...d.
 00000070: 6407 6702 5a0b 650c 6402 8301 5a0d 4700  d.g.Z.e.d...Z.G.
@@ -404,15 +404,15 @@
 00001930: 7b00 0000 732a 0000 0008 0104 0c00 0100  {...s*..........
 00001940: 0100 0100 0100 0100 0100 f702 0302 0102  ................
 00001950: 0102 0102 0102 010c 0102 f70c 2008 0e10  ............ ...
 00001960: 1402 0129 1072 2e00 0000 722a 0000 0072  ...).r....r*...r
 00001970: 0200 0000 7203 0000 00da 0674 7970 696e  ....r......typin
 00001980: 6772 4e00 0000 5a14 746f 6f6c 6c69 622e  grN...Z.toollib.
 00001990: 636f 6d6d 6f6e 2e65 7272 6f72 7204 0000  common.errorr...
-000019a0: 005a 0d74 6f6f 6c6c 6962 2e75 7469 6c73  .Z.toollib.utils
+000019a0: 00da 0d74 6f6f 6c6c 6962 2e75 7469 6c73  ...toollib.utils
 000019b0: 7205 0000 0072 0600 0000 da07 5f5f 616c  r....r......__al
 000019c0: 6c5f 5f72 1600 0000 723e 0000 0072 0700  l__r....r>...r..
 000019d0: 0000 7208 0000 0072 2000 0000 7220 0000  ..r....r ...r ..
 000019e0: 0072 2000 0000 7221 0000 00da 083c 6d6f  .r ...r!.....<mo
 000019f0: 6475 6c65 3e01 0000 0073 1600 0000 0408  dule>....s......
 00001a00: 0801 1002 0802 0c01 1003 0201 02fe 0406  ................
 00001a10: 0803 1261                                ...a
```

## toollib/__pycache__/kvalue.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 6762 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 6a1a 0000  U.........ecj...
+00000000: 550d 0d0a 0000 0000 4442 4664 9e19 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0005 0000 0040 0000 0073 6800 0000 6400  .....@...sh...d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a03 6401 6402 6c04  Z.d.d.l.Z.d.d.l.
 00000050: 5a05 6401 6403 6c06 6d07 5a07 0100 6401  Z.d.d.l.m.Z...d.
 00000060: 6404 6c08 6d09 5a09 0100 6401 6405 6c0a  d.l.m.Z...d.d.l.
 00000070: 6d0b 5a0b 6d0c 5a0c 0100 6406 6701 5a0d  m.Z.m.Z...d.g.Z.
```

## toollib/__pycache__/locker.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Sat Nov 26 14:21:58 2022 UTC, .py size: 3471 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 0621 8263 8f0d 0000  U........!.c....
+00000000: 550d 0d0a 0000 0000 4442 4664 1b0d 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0008 0000 0040 0000 0073 5400 0000 6400  .....@...sT...d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a03 7a10 6401 6403 6c04 6d05 5a05 0100  Z.z.d.d.l.m.Z...
 00000050: 5700 6e16 0400 6506 6b0a 723a 0100 0100  W.n...e.k.r:....
 00000060: 0100 8200 5900 6e02 5800 6404 6701 5a07  ....Y.n.X.d.g.Z.
 00000070: 4700 6405 6404 8400 6404 8302 5a08 6402  G.d.d...d...Z.d.
```

## toollib/__pycache__/py2pyder.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Sun Apr 23 06:21:37 2023 UTC, .py size: 5112 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 71ce 4464 f813 0000  U.......q.Dd....
+00000000: 550d 0d0a 0000 0000 4442 4664 7013 0000  U.......DBFdp...
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0008 0000 0040 0000 0073 9800 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a03 6401 6402 6c04  Z.d.d.l.Z.d.d.l.
 00000050: 5a04 6401 6402 6c05 5a05 6401 6403 6c06  Z.d.d.l.Z.d.d.l.
 00000060: 6d07 5a07 0100 6401 6404 6c08 6d09 5a09  m.Z...d.d.l.m.Z.
 00000070: 0100 7a10 6401 6405 6c0a 6d0b 5a0b 0100  ..z.d.d.l.m.Z...
```

## toollib/__pycache__/redis_cli.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Mon Apr 10 03:19:40 2023 UTC, .py size: 2040 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 4c80 3364 f807 0000  U.......L.3d....
+00000000: 550d 0d0a 0000 0000 4442 4664 a807 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0008 0000 0040 0000 0073 4000 0000 6400  .....@...s@...d.
 00000030: 5a00 7a0c 6401 6402 6c01 5a01 5700 6e16  Z.z.d.d.l.Z.W.n.
 00000040: 0400 6502 6b0a 7226 0100 0100 0100 8200  ..e.k.r&........
 00000050: 5900 6e02 5800 6403 6701 5a03 4700 6404  Y.n.X.d.g.Z.G.d.
 00000060: 6403 8400 6403 8302 5a04 6402 5300 2905  d...d...Z.d.S.).
 00000070: 7a60 0a40 6175 7468 6f72 2061 7869 6e65  z`.@author axine
```

## toollib/__pycache__/regexp.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 1592 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 3806 0000  U.........ec8...
+00000000: 550d 0d0a 0000 0000 4442 4664 0906 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0001 0000 0040 0000 0073 3800 0000 6400  .....@...s8...d.
 00000030: 5a00 6401 5a01 6402 5a02 6403 5a03 6404  Z.d.Z.d.Z.d.Z.d.
 00000040: 5a04 6405 5a05 6505 5a06 6406 5a07 6407  Z.d.Z.e.Z.d.Z.d.
 00000050: 5a08 6408 5a09 6409 5a0a 640a 5a0b 640b  Z.d.Z.d.Z.d.Z.d.
 00000060: 5a0c 640c 5300 290d 75b6 0200 000a 4061  Z.d.S.).u.....@a
 00000070: 7574 686f 7220 6178 696e 6572 0a40 7665  uthor axiner.@ve
```

## toollib/__pycache__/useragent.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:31 2022 UTC, .py size: 127411 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 eb1f 6563 b3f1 0100  U.........ec....
+00000000: 550d 0d0a 0000 0000 4442 4664 92ed 0100  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 00e8 0300 0040 0000 0073 0a0e 0000 5500  .....@...s....U.
 00000030: 6400 5a00 6401 6402 6c01 5a01 6401 6402  d.Z.d.d.l.Z.d.d.
 00000040: 6c02 5a02 6401 6402 6c03 5a04 6403 6404  l.Z.d.d.l.Z.d.d.
 00000050: 6405 6703 5a05 6406 6407 6408 6409 640a  d.g.Z.d.d.d.d.d.
 00000060: 640b 640c 640d 640e 640f 6410 6411 6412  d.d.d.d.d.d.d.d.
 00000070: 6413 6414 6415 6416 6417 6418 6419 641a  d.d.d.d.d.d.d.d.
```

## toollib/__pycache__/utils.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Sun Apr 23 09:10:50 2023 UTC, .py size: 10691 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 1af6 4464 c329 0000  U.........Dd.)..
+00000000: 550d 0d0a 0000 0000 4442 4664 5728 0000  U.......DBFdW(..
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 000b 0000 0040 0000 0073 9601 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a03 6401 6402 6c04  Z.d.d.l.Z.d.d.l.
 00000050: 5a04 6401 6402 6c05 5a05 6401 6402 6c06  Z.d.d.l.Z.d.d.l.
 00000060: 5a06 6401 6402 6c07 5a07 6401 6403 6c08  Z.d.d.l.Z.d.d.l.
 00000070: 6d08 5a08 0100 6401 6402 6c09 5a0a 6401  m.Z...d.d.l.Z.d.
```

## toollib/__pycache__/validator.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Sun Apr 23 02:49:46 2023 UTC, .py size: 3635 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ca9c 4464 330e 0000  U.........Dd3...
+00000000: 550d 0d0a 0000 0000 4442 4664 c20d 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0005 0000 0040 0000 0073 5800 0000 6400  .....@...sX...d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6403 6404 6405 6703 5a03 4700 6406  Z.d.d.d.g.Z.G.d.
 00000050: 6403 8400 6403 8302 5a04 640c 6505 6506  d...d...Z.d.e.e.
 00000060: 6506 6407 9c03 6408 6404 8405 5a07 640d  e.d...d.d...Z.d.
 00000070: 6506 6506 6506 640a 9c03 640b 6405 8405  e.e.e.d...d.d...
```

## toollib/__pycache__/xlsx.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:31 2022 UTC, .py size: 7534 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 eb1f 6563 6e1d 0000  U.........ecn...
+00000000: 550d 0d0a 0000 0000 4442 4664 981c 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 000b 0000 0040 0000 0073 f800 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a02 6401 6403 6c03  Z.d.d.l.Z.d.d.l.
 00000040: 6d04 5a04 0100 7a10 6401 6404 6c05 6d06  m.Z...z.d.d.l.m.
 00000050: 5a06 0100 5700 6e16 0400 6507 6b0a 723e  Z...W.n...e.k.r>
 00000060: 0100 0100 0100 8200 5900 6e02 5800 6405  ........Y.n.X.d.
 00000070: 6406 6407 6408 6704 5a08 6412 6506 6502  d.d.d.g.Z.d.e.e.
```

## toollib/common/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/1/11 22:11
-@abstract
-@description
-@history
-"""
+"""
+@author axiner
+@version v1.0.0
+@created 2022/1/11 22:11
+@abstract
+@description
+@history
+"""
```

## toollib/common/constor.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:32
-@abstract
-@description
-@history
-"""
-
-pip_conf = b'[global]\ntimeout=6000\nindex-url=https://pypi.tuna.tsinghua.edu.cn/simple/\nextra-index-url=\n\thttps://mirrors.aliyun.com/pypi/simple/\n\thttps://mirrors.bfsu.edu.cn/pypi/web/simple/\n\thttps://pypi.doubanio.com/simple/\n\thttps://pypi.python.org/simple/\n[install]\ntrusted-host=\n\tpypi.tuna.tsinghua.edu.cn\n\tmirrors.aliyun.com\n\tmirrors.bfsu.edu.cn\n\tpypi.doubanio.com'
-conda_conf = b'channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n  - defaults\nshow_channel_urls: true'
-pyd_setup = b'import sys\nfrom distutils.core import setup, Extension\nfrom Cython.Build import cythonize\nsetup(ext_modules=cythonize(Extension(sys.argv.pop(), sources=[sys.argv.pop()]), language_level="3"))'
-docker_mirrors = {
-    "registry-mirrors": [
-        "https://hub-mirror.c.163.com",
-        "https://docker.mirrors.ustc.edu.cn",
-        "https://registry.docker-cn.com",
-    ]
-}
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:32
+@abstract
+@description
+@history
+"""
+
+pip_conf = b'[global]\ntimeout=6000\nindex-url=https://pypi.tuna.tsinghua.edu.cn/simple/\nextra-index-url=\n\thttps://mirrors.aliyun.com/pypi/simple/\n\thttps://mirrors.bfsu.edu.cn/pypi/web/simple/\n\thttps://pypi.doubanio.com/simple/\n\thttps://pypi.python.org/simple/\n[install]\ntrusted-host=\n\tpypi.tuna.tsinghua.edu.cn\n\tmirrors.aliyun.com\n\tmirrors.bfsu.edu.cn\n\tpypi.doubanio.com'
+conda_conf = b'channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n  - defaults\nshow_channel_urls: true'
+pyd_setup = b'import sys\nfrom distutils.core import setup, Extension\nfrom Cython.Build import cythonize\nsetup(ext_modules=cythonize(Extension(sys.argv.pop(), sources=[sys.argv.pop()]), language_level="3"))'
+docker_mirrors = {
+    "registry-mirrors": [
+        "https://hub-mirror.c.163.com",
+        "https://docker.mirrors.ustc.edu.cn",
+        "https://registry.docker-cn.com",
+    ]
+}
```

## toollib/common/error.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/1/2 14:49
-@abstract
-@description
-@history
-"""
-
-
-class Error(Exception):
-    """Error基类"""
-
-    def __init__(self, msg='Raise error', code=1):
-        self.msg = msg
-        self.code = code
-        self.error = {'code': self.code, 'msg': self.msg}
-
-    def __str__(self):
-        return self.msg
-
-
-class ExpireError(Error):
-    """expire error"""
-
-
-class InvalidSystemClock(Error):
-    """时钟回拨异常"""
+"""
+@author axiner
+@version v1.0.0
+@created 2022/1/2 14:49
+@abstract
+@description
+@history
+"""
+
+
+class Error(Exception):
+    """Error基类"""
+
+    def __init__(self, msg='Raise error', code=1):
+        self.msg = msg
+        self.code = code
+        self.error = {'code': self.code, 'msg': self.msg}
+
+    def __str__(self):
+        return self.msg
+
+
+class ExpireError(Error):
+    """expire error"""
+
+
+class InvalidSystemClock(Error):
+    """时钟回拨异常"""
```

## toollib/common/rarfile.py

 * *Ordering differences only*

```diff
@@ -1,3365 +1,3365 @@
-# rarfile.py
-#
-# Copyright (c) 2005-2020  Marko Kreen <markokr@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any
-# purpose with or without fee is hereby granted, provided that the above
-# copyright notice and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
-"""RAR archive reader.
-
-This is Python module for Rar archive reading.  The interface
-is made as :mod:`zipfile`-like as possible.
-
-Basic logic:
- - Parse archive structure with Python.
- - Extract non-compressed files with Python
- - Extract compressed files with unrar.
- - Optionally write compressed data to temp file to speed up unrar,
-   otherwise it needs to scan whole archive on each execution.
-
-Example::
-
-    import rarfile
-
-    rf = rarfile.RarFile("myarchive.rar")
-    for f in rf.infolist():
-        print(f.filename, f.file_size)
-        if f.filename == "README":
-            print(rf.read(f))
-
-Archive files can also be accessed via file-like object returned
-by :meth:`RarFile.open`::
-
-    import rarfile
-
-    with rarfile.RarFile("archive.rar") as rf:
-        with rf.open("README") as f:
-            for ln in f:
-                print(ln.strip())
-
-For decompression to work, either ``unrar`` or ``unar`` tool must be in PATH.
-"""
-
-import errno
-import io
-import os
-import re
-import shutil
-import struct
-import sys
-import warnings
-from binascii import crc32, hexlify
-from datetime import datetime, timezone
-from hashlib import blake2s, pbkdf2_hmac, sha1
-from pathlib import Path
-from struct import Struct, pack, unpack
-from subprocess import DEVNULL, PIPE, STDOUT, Popen
-from tempfile import mkstemp
-
-# only needed for encrypted headers
-try:
-    try:
-        from cryptography.hazmat.backends import default_backend
-        from cryptography.hazmat.primitives.ciphers import (
-            Cipher, algorithms, modes,
-        )
-        _have_crypto = 1
-    except ImportError:
-        from Crypto.Cipher import AES
-        _have_crypto = 2
-except ImportError:
-    _have_crypto = 0
-
-
-class AES_CBC_Decrypt:
-    """Decrypt API"""
-    def __init__(self, key, iv):
-        if _have_crypto == 2:
-            self.decrypt = AES.new(key, AES.MODE_CBC, iv).decrypt
-        else:
-            ciph = Cipher(algorithms.AES(key), modes.CBC(iv), default_backend())
-            self.decrypt = ciph.decryptor().update
-
-
-__version__ = "4.0"
-
-# export only interesting items
-__all__ = ["is_rarfile", "is_rarfile_sfx", "RarInfo", "RarFile", "RarExtFile"]
-
-##
-## Module configuration.  Can be tuned after importing.
-##
-
-#: executable for unrar tool
-# by axiner
-# UNRAR_TOOL = "unrar"
-UNRAR_TOOL = Path(__file__).absolute().parent.joinpath("UnRAR.exe").as_posix()
-
-#: executable for unar tool
-UNAR_TOOL = "unar"
-
-#: executable for bsdtar tool
-BSDTAR_TOOL = "bsdtar"
-
-#: default fallback charset
-DEFAULT_CHARSET = "windows-1252"
-
-#: list of encodings to try, with fallback to DEFAULT_CHARSET if none succeed
-TRY_ENCODINGS = ("utf8", "utf-16le")
-
-#: whether to speed up decompression by using tmp archive
-USE_EXTRACT_HACK = 1
-
-#: limit the filesize for tmp archive usage
-HACK_SIZE_LIMIT = 20 * 1024 * 1024
-
-#: set specific directory for mkstemp() used by hack dir usage
-HACK_TMP_DIR = None
-
-#: Separator for path name components.  Always "/".
-PATH_SEP = "/"
-
-##
-## rar constants
-##
-
-# block types
-RAR_BLOCK_MARK = 0x72           # r
-RAR_BLOCK_MAIN = 0x73           # s
-RAR_BLOCK_FILE = 0x74           # t
-RAR_BLOCK_OLD_COMMENT = 0x75    # u
-RAR_BLOCK_OLD_EXTRA = 0x76      # v
-RAR_BLOCK_OLD_SUB = 0x77        # w
-RAR_BLOCK_OLD_RECOVERY = 0x78   # x
-RAR_BLOCK_OLD_AUTH = 0x79       # y
-RAR_BLOCK_SUB = 0x7a            # z
-RAR_BLOCK_ENDARC = 0x7b         # {
-
-# flags for RAR_BLOCK_MAIN
-RAR_MAIN_VOLUME = 0x0001
-RAR_MAIN_COMMENT = 0x0002
-RAR_MAIN_LOCK = 0x0004
-RAR_MAIN_SOLID = 0x0008
-RAR_MAIN_NEWNUMBERING = 0x0010
-RAR_MAIN_AUTH = 0x0020
-RAR_MAIN_RECOVERY = 0x0040
-RAR_MAIN_PASSWORD = 0x0080
-RAR_MAIN_FIRSTVOLUME = 0x0100
-RAR_MAIN_ENCRYPTVER = 0x0200
-
-# flags for RAR_BLOCK_FILE
-RAR_FILE_SPLIT_BEFORE = 0x0001
-RAR_FILE_SPLIT_AFTER = 0x0002
-RAR_FILE_PASSWORD = 0x0004
-RAR_FILE_COMMENT = 0x0008
-RAR_FILE_SOLID = 0x0010
-RAR_FILE_DICTMASK = 0x00e0
-RAR_FILE_DICT64 = 0x0000
-RAR_FILE_DICT128 = 0x0020
-RAR_FILE_DICT256 = 0x0040
-RAR_FILE_DICT512 = 0x0060
-RAR_FILE_DICT1024 = 0x0080
-RAR_FILE_DICT2048 = 0x00a0
-RAR_FILE_DICT4096 = 0x00c0
-RAR_FILE_DIRECTORY = 0x00e0
-RAR_FILE_LARGE = 0x0100
-RAR_FILE_UNICODE = 0x0200
-RAR_FILE_SALT = 0x0400
-RAR_FILE_VERSION = 0x0800
-RAR_FILE_EXTTIME = 0x1000
-RAR_FILE_EXTFLAGS = 0x2000
-
-# flags for RAR_BLOCK_ENDARC
-RAR_ENDARC_NEXT_VOLUME = 0x0001
-RAR_ENDARC_DATACRC = 0x0002
-RAR_ENDARC_REVSPACE = 0x0004
-RAR_ENDARC_VOLNR = 0x0008
-
-# flags common to all blocks
-RAR_SKIP_IF_UNKNOWN = 0x4000
-RAR_LONG_BLOCK = 0x8000
-
-# Host OS types
-RAR_OS_MSDOS = 0    #: MSDOS (only in RAR3)
-RAR_OS_OS2 = 1      #: OS2 (only in RAR3)
-RAR_OS_WIN32 = 2    #: Windows
-RAR_OS_UNIX = 3     #: UNIX
-RAR_OS_MACOS = 4    #: MacOS (only in RAR3)
-RAR_OS_BEOS = 5     #: BeOS (only in RAR3)
-
-# Compression methods - "0".."5"
-RAR_M0 = 0x30   #: No compression.
-RAR_M1 = 0x31   #: Compression level `-m1` - Fastest compression.
-RAR_M2 = 0x32   #: Compression level `-m2`.
-RAR_M3 = 0x33   #: Compression level `-m3`.
-RAR_M4 = 0x34   #: Compression level `-m4`.
-RAR_M5 = 0x35   #: Compression level `-m5` - Maximum compression.
-
-#
-# RAR5 constants
-#
-
-RAR5_BLOCK_MAIN = 1
-RAR5_BLOCK_FILE = 2
-RAR5_BLOCK_SERVICE = 3
-RAR5_BLOCK_ENCRYPTION = 4
-RAR5_BLOCK_ENDARC = 5
-
-RAR5_BLOCK_FLAG_EXTRA_DATA = 0x01
-RAR5_BLOCK_FLAG_DATA_AREA = 0x02
-RAR5_BLOCK_FLAG_SKIP_IF_UNKNOWN = 0x04
-RAR5_BLOCK_FLAG_SPLIT_BEFORE = 0x08
-RAR5_BLOCK_FLAG_SPLIT_AFTER = 0x10
-RAR5_BLOCK_FLAG_DEPENDS_PREV = 0x20
-RAR5_BLOCK_FLAG_KEEP_WITH_PARENT = 0x40
-
-RAR5_MAIN_FLAG_ISVOL = 0x01
-RAR5_MAIN_FLAG_HAS_VOLNR = 0x02
-RAR5_MAIN_FLAG_SOLID = 0x04
-RAR5_MAIN_FLAG_RECOVERY = 0x08
-RAR5_MAIN_FLAG_LOCKED = 0x10
-
-RAR5_FILE_FLAG_ISDIR = 0x01
-RAR5_FILE_FLAG_HAS_MTIME = 0x02
-RAR5_FILE_FLAG_HAS_CRC32 = 0x04
-RAR5_FILE_FLAG_UNKNOWN_SIZE = 0x08
-
-RAR5_COMPR_SOLID = 0x40
-
-RAR5_ENC_FLAG_HAS_CHECKVAL = 0x01
-
-RAR5_ENDARC_FLAG_NEXT_VOL = 0x01
-
-RAR5_XFILE_ENCRYPTION = 1
-RAR5_XFILE_HASH = 2
-RAR5_XFILE_TIME = 3
-RAR5_XFILE_VERSION = 4
-RAR5_XFILE_REDIR = 5
-RAR5_XFILE_OWNER = 6
-RAR5_XFILE_SERVICE = 7
-
-RAR5_XTIME_UNIXTIME = 0x01
-RAR5_XTIME_HAS_MTIME = 0x02
-RAR5_XTIME_HAS_CTIME = 0x04
-RAR5_XTIME_HAS_ATIME = 0x08
-RAR5_XTIME_UNIXTIME_NS = 0x10
-
-RAR5_XENC_CIPHER_AES256 = 0
-
-RAR5_XENC_CHECKVAL = 0x01
-RAR5_XENC_TWEAKED = 0x02
-
-RAR5_XHASH_BLAKE2SP = 0
-
-RAR5_XREDIR_UNIX_SYMLINK = 1
-RAR5_XREDIR_WINDOWS_SYMLINK = 2
-RAR5_XREDIR_WINDOWS_JUNCTION = 3
-RAR5_XREDIR_HARD_LINK = 4
-RAR5_XREDIR_FILE_COPY = 5
-
-RAR5_XREDIR_ISDIR = 0x01
-
-RAR5_XOWNER_UNAME = 0x01
-RAR5_XOWNER_GNAME = 0x02
-RAR5_XOWNER_UID = 0x04
-RAR5_XOWNER_GID = 0x08
-
-RAR5_OS_WINDOWS = 0
-RAR5_OS_UNIX = 1
-
-DOS_MODE_ARCHIVE = 0x20
-DOS_MODE_DIR = 0x10
-DOS_MODE_SYSTEM = 0x04
-DOS_MODE_HIDDEN = 0x02
-DOS_MODE_READONLY = 0x01
-
-##
-## internal constants
-##
-
-RAR_ID = b"Rar!\x1a\x07\x00"
-RAR5_ID = b"Rar!\x1a\x07\x01\x00"
-
-WIN32 = sys.platform == "win32"
-BSIZE = 512 * 1024 if WIN32 else 64 * 1024
-
-SFX_MAX_SIZE = 2 * 1024 * 1024
-RAR_V3 = 3
-RAR_V5 = 5
-
-_BAD_CHARS = r"""\x00-\x1F<>|"?*"""
-RC_BAD_CHARS_UNIX = re.compile(r"[%s]" % _BAD_CHARS)
-RC_BAD_CHARS_WIN32 = re.compile(r"[%s:^\\]" % _BAD_CHARS)
-
-
-def _get_rar_version(xfile):
-    """Check quickly whether file is rar archive.
-    """
-    with XFile(xfile) as fd:
-        buf = fd.read(len(RAR5_ID))
-    if buf.startswith(RAR_ID):
-        return RAR_V3
-    elif buf.startswith(RAR5_ID):
-        return RAR_V5
-    return 0
-
-
-def _find_sfx_header(xfile):
-    sig = RAR_ID[:-1]
-    buf = io.BytesIO()
-    steps = (64, SFX_MAX_SIZE)
-
-    with XFile(xfile) as fd:
-        for step in steps:
-            data = fd.read(step)
-            if not data:
-                break
-            buf.write(data)
-            curdata = buf.getvalue()
-            findpos = 0
-            while True:
-                pos = curdata.find(sig, findpos)
-                if pos < 0:
-                    break
-                if curdata[pos:pos + len(RAR_ID)] == RAR_ID:
-                    return RAR_V3, pos
-                if curdata[pos:pos + len(RAR5_ID)] == RAR5_ID:
-                    return RAR_V5, pos
-                findpos = pos + len(sig)
-    return 0, 0
-
-
-##
-## Public interface
-##
-
-def is_rarfile(xfile):
-    """Check quickly whether file is rar archive.
-    """
-    return _get_rar_version(xfile) > 0
-
-
-def is_rarfile_sfx(xfile):
-    """Check whether file is rar archive with support for SFX.
-
-    It will read 2M from file.
-    """
-    return _find_sfx_header(xfile)[0] > 0
-
-
-class Error(Exception):
-    """Base class for rarfile errors."""
-
-
-class BadRarFile(Error):
-    """Incorrect data in archive."""
-
-
-class NotRarFile(Error):
-    """The file is not RAR archive."""
-
-
-class BadRarName(Error):
-    """Cannot guess multipart name components."""
-
-
-class NoRarEntry(Error):
-    """File not found in RAR"""
-
-
-class PasswordRequired(Error):
-    """File requires password"""
-
-
-class NeedFirstVolume(Error):
-    """Need to start from first volume.
-
-    Attributes:
-
-        current_volume
-            Volume number of current file or None if not known
-    """
-    def __init__(self, msg, volume):
-        super().__init__(msg)
-        self.current_volume = volume
-
-
-class NoCrypto(Error):
-    """Cannot parse encrypted headers - no crypto available."""
-
-
-class RarExecError(Error):
-    """Problem reported by unrar/rar."""
-
-
-class RarWarning(RarExecError):
-    """Non-fatal error"""
-
-
-class RarFatalError(RarExecError):
-    """Fatal error"""
-
-
-class RarCRCError(RarExecError):
-    """CRC error during unpacking"""
-
-
-class RarLockedArchiveError(RarExecError):
-    """Must not modify locked archive"""
-
-
-class RarWriteError(RarExecError):
-    """Write error"""
-
-
-class RarOpenError(RarExecError):
-    """Open error"""
-
-
-class RarUserError(RarExecError):
-    """User error"""
-
-
-class RarMemoryError(RarExecError):
-    """Memory error"""
-
-
-class RarCreateError(RarExecError):
-    """Create error"""
-
-
-class RarNoFilesError(RarExecError):
-    """No files that match pattern were found"""
-
-
-class RarUserBreak(RarExecError):
-    """User stop"""
-
-
-class RarWrongPassword(RarExecError):
-    """Incorrect password"""
-
-
-class RarUnknownError(RarExecError):
-    """Unknown exit code"""
-
-
-class RarSignalExit(RarExecError):
-    """Unrar exited with signal"""
-
-
-class RarCannotExec(RarExecError):
-    """Executable not found."""
-
-
-class UnsupportedWarning(UserWarning):
-    """Archive uses feature that are unsupported by rarfile.
-
-    .. versionadded:: 4.0
-    """
-
-
-class RarInfo:
-    r"""An entry in rar archive.
-
-    Timestamps as :class:`~datetime.datetime` are without timezone in RAR3,
-    with UTC timezone in RAR5 archives.
-
-    Attributes:
-
-        filename
-            File name with relative path.
-            Path separator is "/".  Always unicode string.
-
-        date_time
-            File modification timestamp.   As tuple of (year, month, day, hour, minute, second).
-            RAR5 allows archives where it is missing, it's None then.
-
-        comment
-            Optional file comment field.  Unicode string.  (RAR3-only)
-
-        file_size
-            Uncompressed size.
-
-        compress_size
-            Compressed size.
-
-        compress_type
-            Compression method: one of :data:`RAR_M0` .. :data:`RAR_M5` constants.
-
-        extract_version
-            Minimal Rar version needed for decompressing.  As (major*10 + minor),
-            so 2.9 is 29.
-
-            RAR3: 10, 20, 29
-
-            RAR5 does not have such field in archive, it's simply set to 50.
-
-        host_os
-            Host OS type, one of RAR_OS_* constants.
-
-            RAR3: :data:`RAR_OS_WIN32`, :data:`RAR_OS_UNIX`, :data:`RAR_OS_MSDOS`,
-            :data:`RAR_OS_OS2`, :data:`RAR_OS_BEOS`.
-
-            RAR5: :data:`RAR_OS_WIN32`, :data:`RAR_OS_UNIX`.
-
-        mode
-            File attributes. May be either dos-style or unix-style, depending on host_os.
-
-        mtime
-            File modification time.  Same value as :attr:`date_time`
-            but as :class:`~datetime.datetime` object with extended precision.
-
-        ctime
-            Optional time field: creation time.  As :class:`~datetime.datetime` object.
-
-        atime
-            Optional time field: last access time.  As :class:`~datetime.datetime` object.
-
-        arctime
-            Optional time field: archival time.  As :class:`~datetime.datetime` object.
-            (RAR3-only)
-
-        CRC
-            CRC-32 of uncompressed file, unsigned int.
-
-            RAR5: may be None.
-
-        blake2sp_hash
-            Blake2SP hash over decompressed data.  (RAR5-only)
-
-        volume
-            Volume nr, starting from 0.
-
-        volume_file
-            Volume file name, where file starts.
-
-        file_redir
-            If not None, file is link of some sort.  Contains tuple of (type, flags, target).
-            (RAR5-only)
-
-            Type is one of constants:
-
-                :data:`RAR5_XREDIR_UNIX_SYMLINK`
-                    Unix symlink.
-                :data:`RAR5_XREDIR_WINDOWS_SYMLINK`
-                    Windows symlink.
-                :data:`RAR5_XREDIR_WINDOWS_JUNCTION`
-                    Windows junction.
-                :data:`RAR5_XREDIR_HARD_LINK`
-                    Hard link to target.
-                :data:`RAR5_XREDIR_FILE_COPY`
-                    Current file is copy of another archive entry.
-
-            Flags may contain bits:
-
-                :data:`RAR5_XREDIR_ISDIR`
-                    Symlink points to directory.
-    """
-
-    # zipfile-compatible fields
-    filename = None
-    file_size = None
-    compress_size = None
-    date_time = None
-    CRC = None
-    volume = None
-    orig_filename = None
-
-    # optional extended time fields, datetime() objects.
-    mtime = None
-    ctime = None
-    atime = None
-
-    extract_version = None
-    mode = None
-    host_os = None
-    compress_type = None
-
-    # rar3-only fields
-    comment = None
-    arctime = None
-
-    # rar5-only fields
-    blake2sp_hash = None
-    file_redir = None
-
-    # internal fields
-    flags = 0
-    type = None
-
-    # zipfile compat
-    def is_dir(self):
-        """Returns True if entry is a directory.
-
-        .. versionadded:: 4.0
-        """
-        return False
-
-    def is_symlink(self):
-        """Returns True if entry is a symlink.
-
-        .. versionadded:: 4.0
-        """
-        return False
-
-    def is_file(self):
-        """Returns True if entry is a normal file.
-
-        .. versionadded:: 4.0
-        """
-        return False
-
-    def needs_password(self):
-        """Returns True if data is stored password-protected.
-        """
-        if self.type == RAR_BLOCK_FILE:
-            return (self.flags & RAR_FILE_PASSWORD) > 0
-        return False
-
-    def isdir(self):
-        """Returns True if entry is a directory.
-
-        .. deprecated:: 4.0
-        """
-        return self.is_dir()
-
-
-class RarFile:
-    """Parse RAR structure, provide access to files in archive.
-    """
-
-    #: File name, if available.  Unicode string or None.
-    filename = None
-
-    #: Archive comment.  Unicode string or None.
-    comment = None
-
-    def __init__(self, file, mode="r", charset=None, info_callback=None,
-                 crc_check=True, errors="stop"):
-        """Open and parse a RAR archive.
-
-        Parameters:
-
-            file
-                archive file name or file-like object.
-            mode
-                only "r" is supported.
-            charset
-                fallback charset to use, if filenames are not already Unicode-enabled.
-            info_callback
-                debug callback, gets to see all archive entries.
-            crc_check
-                set to False to disable CRC checks
-            errors
-                Either "stop" to quietly stop parsing on errors,
-                or "strict" to raise errors.  Default is "stop".
-        """
-        if is_filelike(file):
-            self.filename = getattr(file, "name", None)
-        else:
-            if isinstance(file, Path):
-                file = str(file)
-            self.filename = file
-        self._rarfile = file
-
-        self._charset = charset or DEFAULT_CHARSET
-        self._info_callback = info_callback
-        self._crc_check = crc_check
-        self._password = None
-        self._file_parser = None
-
-        if errors == "stop":
-            self._strict = False
-        elif errors == "strict":
-            self._strict = True
-        else:
-            raise ValueError("Invalid value for errors= parameter.")
-
-        if mode != "r":
-            raise NotImplementedError("RarFile supports only mode=r")
-
-        self._parse()
-
-    def __enter__(self):
-        """Open context."""
-        return self
-
-    def __exit__(self, typ, value, traceback):
-        """Exit context."""
-        self.close()
-
-    def __iter__(self):
-        """Iterate over members."""
-        return iter(self.infolist())
-
-    def setpassword(self, pwd):
-        """Sets the password to use when extracting.
-        """
-        self._password = pwd
-        if self._file_parser:
-            if self._file_parser.has_header_encryption():
-                self._file_parser = None
-        if not self._file_parser:
-            self._parse()
-        else:
-            self._file_parser.setpassword(self._password)
-
-    def needs_password(self):
-        """Returns True if any archive entries require password for extraction.
-        """
-        return self._file_parser.needs_password()
-
-    def namelist(self):
-        """Return list of filenames in archive.
-        """
-        return [f.filename for f in self.infolist()]
-
-    def infolist(self):
-        """Return RarInfo objects for all files/directories in archive.
-        """
-        return self._file_parser.infolist()
-
-    def volumelist(self):
-        """Returns filenames of archive volumes.
-
-        In case of single-volume archive, the list contains
-        just the name of main archive file.
-        """
-        return self._file_parser.volumelist()
-
-    def getinfo(self, name):
-        """Return RarInfo for file.
-        """
-        return self._file_parser.getinfo(name)
-
-    def open(self, name, mode="r", pwd=None):
-        """Returns file-like object (:class:`RarExtFile`) from where the data can be read.
-
-        The object implements :class:`io.RawIOBase` interface, so it can
-        be further wrapped with :class:`io.BufferedReader`
-        and :class:`io.TextIOWrapper`.
-
-        On older Python where io module is not available, it implements
-        only .read(), .seek(), .tell() and .close() methods.
-
-        The object is seekable, although the seeking is fast only on
-        uncompressed files, on compressed files the seeking is implemented
-        by reading ahead and/or restarting the decompression.
-
-        Parameters:
-
-            name
-                file name or RarInfo instance.
-            mode
-                must be "r"
-            pwd
-                password to use for extracting.
-        """
-
-        if mode != "r":
-            raise NotImplementedError("RarFile.open() supports only mode=r")
-
-        # entry lookup
-        inf = self.getinfo(name)
-        if inf.is_dir():
-            raise io.UnsupportedOperation("Directory does not have any data: " + inf.filename)
-
-        # check password
-        if inf.needs_password():
-            pwd = pwd or self._password
-            if pwd is None:
-                raise PasswordRequired("File %s requires password" % inf.filename)
-        else:
-            pwd = None
-
-        return self._file_parser.open(inf, pwd)
-
-    def read(self, name, pwd=None):
-        """Return uncompressed data for archive entry.
-
-        For longer files using :meth:`~RarFile.open` may be better idea.
-
-        Parameters:
-
-            name
-                filename or RarInfo instance
-            pwd
-                password to use for extracting.
-        """
-
-        with self.open(name, "r", pwd) as f:
-            return f.read()
-
-    def close(self):
-        """Release open resources."""
-        pass
-
-    def printdir(self, file=None):
-        """Print archive file list to stdout or given file.
-        """
-        if file is None:
-            file = sys.stdout
-        for f in self.infolist():
-            print(f.filename, file=file)
-
-    def extract(self, member, path=None, pwd=None):
-        """Extract single file into current directory.
-
-        Parameters:
-
-            member
-                filename or :class:`RarInfo` instance
-            path
-                optional destination path
-            pwd
-                optional password to use
-        """
-        inf = self.getinfo(member)
-        return self._extract_one(inf, path, pwd, True)
-
-    def extractall(self, path=None, members=None, pwd=None):
-        """Extract all files into current directory.
-
-        Parameters:
-
-            path
-                optional destination path
-            members
-                optional filename or :class:`RarInfo` instance list to extract
-            pwd
-                optional password to use
-        """
-        if members is None:
-            members = self.namelist()
-
-        done = set()
-        dirs = []
-        for m in members:
-            inf = self.getinfo(m)
-            dst = self._extract_one(inf, path, pwd, not inf.is_dir())
-            if inf.is_dir():
-                if dst not in done:
-                    dirs.append((dst, inf))
-                    done.add(dst)
-        if dirs:
-            dirs.sort(reverse=True)
-            for dst, inf in dirs:
-                self._set_attrs(inf, dst)
-
-    def testrar(self, pwd=None):
-        """Read all files and test CRC.
-        """
-        for member in self.infolist():
-            if member.is_file():
-                with self.open(member, 'r', pwd) as f:
-                    empty_read(f, member.file_size, BSIZE)
-
-    def strerror(self):
-        """Return error string if parsing failed or None if no problems.
-        """
-        if not self._file_parser:
-            return "Not a RAR file"
-        return self._file_parser.strerror()
-
-    ##
-    ## private methods
-    ##
-
-    def _parse(self):
-        """Run parser for file type
-        """
-        ver, sfx_ofs = _find_sfx_header(self._rarfile)
-        if ver == RAR_V3:
-            p3 = RAR3Parser(self._rarfile, self._password, self._crc_check,
-                            self._charset, self._strict, self._info_callback,
-                            sfx_ofs)
-            self._file_parser = p3  # noqa
-        elif ver == RAR_V5:
-            p5 = RAR5Parser(self._rarfile, self._password, self._crc_check,
-                            self._charset, self._strict, self._info_callback,
-                            sfx_ofs)
-            self._file_parser = p5  # noqa
-        else:
-            raise NotRarFile("Not a RAR file")
-
-        self._file_parser.parse()
-        self.comment = self._file_parser.comment
-
-    def _extract_one(self, info, path, pwd, set_attrs):
-        fname = sanitize_filename(
-            info.filename, os.path.sep, WIN32
-        )
-
-        if path is None:
-            path = os.getcwd()
-        else:
-            path = os.fspath(path)
-        dstfn = os.path.join(path, fname)
-
-        dirname = os.path.dirname(dstfn)
-        if dirname and dirname != ".":
-            os.makedirs(dirname, exist_ok=True)
-
-        if info.is_file():
-            return self._make_file(info, dstfn, pwd, set_attrs)
-        if info.is_dir():
-            return self._make_dir(info, dstfn, pwd, set_attrs)
-        if info.is_symlink():
-            return self._make_symlink(info, dstfn, pwd, set_attrs)
-        return None
-
-    def _create_helper(self, name, flags, info):
-        return os.open(name, flags)
-
-    def _make_file(self, info, dstfn, pwd, set_attrs):
-        def helper(name, flags):
-            return self._create_helper(name, flags, info)
-        with self.open(info, "r", pwd) as src:
-            with open(dstfn, "wb", opener=helper) as dst:
-                shutil.copyfileobj(src, dst)
-        if set_attrs:
-            self._set_attrs(info, dstfn)
-        return dstfn
-
-    def _make_dir(self, info, dstfn, pwd, set_attrs):
-        os.makedirs(dstfn, exist_ok=True)
-        if set_attrs:
-            self._set_attrs(info, dstfn)
-        return dstfn
-
-    def _make_symlink(self, info, dstfn, pwd, set_attrs):
-        target_is_directory = False
-        if info.host_os == RAR_OS_UNIX:
-            link_name = self.read(info, pwd)
-            target_is_directory = (info.flags & RAR_FILE_DIRECTORY) == RAR_FILE_DIRECTORY
-        elif info.file_redir:
-            redir_type, redir_flags, link_name = info.file_redir
-            if redir_type == RAR5_XREDIR_WINDOWS_JUNCTION:
-                warnings.warn(f"Windows junction not supported - {info.filename}", UnsupportedWarning)
-                return None
-            target_is_directory = (redir_type & RAR5_XREDIR_ISDIR) > 0
-        else:
-            warnings.warn(f"Unsupported link type - {info.filename}", UnsupportedWarning)
-            return None
-
-        os.symlink(link_name, dstfn, target_is_directory=target_is_directory)
-        return dstfn
-
-    def _set_attrs(self, info, dstfn):
-        if info.host_os == RAR_OS_UNIX:
-            os.chmod(dstfn, info.mode & 0o777)
-        elif info.host_os in (RAR_OS_WIN32, RAR_OS_MSDOS):
-            # only keep R/O attr, except for dirs on win32
-            if info.mode & DOS_MODE_READONLY and (info.is_file() or not WIN32):
-                st = os.stat(dstfn)
-                new_mode = st.st_mode & ~0o222
-                os.chmod(dstfn, new_mode)
-
-        if info.mtime:
-            mtime_ns = to_nsecs(info.mtime)
-            atime_ns = to_nsecs(info.atime) if info.atime else mtime_ns
-            os.utime(dstfn, ns=(atime_ns, mtime_ns))
-
-
-#
-# File format parsing
-#
-
-class CommonParser:
-    """Shared parser parts."""
-    _main = None
-    _hdrenc_main = None
-    _needs_password = False
-    _fd = None
-    _expect_sig = None
-    _parse_error = None
-    _password = None
-    comment = None
-
-    def __init__(self, rarfile, password, crc_check, charset, strict, info_cb, sfx_offset):
-        self._rarfile = rarfile
-        self._password = password
-        self._crc_check = crc_check
-        self._charset = charset
-        self._strict = strict
-        self._info_callback = info_cb
-        self._info_list = []
-        self._info_map = {}
-        self._vol_list = []
-        self._sfx_offset = sfx_offset
-
-    def has_header_encryption(self):
-        """Returns True if headers are encrypted
-        """
-        if self._hdrenc_main:
-            return True
-        if self._main:
-            if self._main.flags & RAR_MAIN_PASSWORD:
-                return True
-        return False
-
-    def setpassword(self, pwd):
-        """Set cached password."""
-        self._password = pwd
-
-    def volumelist(self):
-        """Volume files"""
-        return self._vol_list
-
-    def needs_password(self):
-        """Is password required"""
-        return self._needs_password
-
-    def strerror(self):
-        """Last error"""
-        return self._parse_error
-
-    def infolist(self):
-        """List of RarInfo records.
-        """
-        return self._info_list
-
-    def getinfo(self, member):
-        """Return RarInfo for filename
-        """
-        if isinstance(member, RarInfo):
-            fname = member.filename
-        elif isinstance(member, Path):
-            fname = str(member)
-        else:
-            fname = member
-
-        if fname.endswith("/"):
-            fname = fname.rstrip("/")
-
-        try:
-            return self._info_map[fname]
-        except KeyError:
-            raise NoRarEntry("No such file: %s" % fname)
-
-    def parse(self):
-        """Process file."""
-        self._fd = None
-        try:
-            self._parse_real()
-        finally:
-            if self._fd:
-                self._fd.close()
-                self._fd = None
-
-    def _parse_real(self):
-        """Actually read file.
-        """
-        fd = XFile(self._rarfile)
-        self._fd = fd
-        fd.seek(self._sfx_offset, 0)
-        sig = fd.read(len(self._expect_sig))
-        if sig != self._expect_sig:
-            raise NotRarFile("Not a Rar archive")
-
-        volume = 0  # first vol (.rar) is 0
-        more_vols = False
-        endarc = False
-        volfile = self._rarfile
-        self._vol_list = [self._rarfile]
-        raise_need_first_vol = False
-        while True:
-            if endarc:
-                h = None    # don"t read past ENDARC
-            else:
-                h = self._parse_header(fd)
-            if not h:
-                if raise_need_first_vol:
-                    # did not find ENDARC with VOLNR
-                    raise NeedFirstVolume("Need to start from first volume", None)
-                if more_vols:
-                    volume += 1
-                    fd.close()
-                    try:
-                        volfile = self._next_volname(volfile)
-                        fd = XFile(volfile)
-                    except IOError:
-                        self._set_error("Cannot open next volume: %s", volfile)
-                        break
-                    self._fd = fd
-                    sig = fd.read(len(self._expect_sig))
-                    if sig != self._expect_sig:
-                        self._set_error("Invalid volume sig: %s", volfile)
-                        break
-                    more_vols = False
-                    endarc = False
-                    self._vol_list.append(volfile)
-                    self._main = None
-                    continue
-                break
-            h.volume = volume
-            h.volume_file = volfile
-
-            if h.type == RAR_BLOCK_MAIN and not self._main:
-                self._main = h
-                if volume == 0 and (h.flags & RAR_MAIN_NEWNUMBERING):
-                    # RAR 2.x does not set FIRSTVOLUME,
-                    # so check it only if NEWNUMBERING is used
-                    if (h.flags & RAR_MAIN_FIRSTVOLUME) == 0:
-                        if getattr(h, "main_volume_number", None) is not None:
-                            # rar5 may have more info
-                            raise NeedFirstVolume(
-                                "Need to start from first volume (current: %r)"
-                                % (h.main_volume_number,),
-                                h.main_volume_number
-                            )
-                        # delay raise until we have volnr from ENDARC
-                        raise_need_first_vol = True
-                if h.flags & RAR_MAIN_PASSWORD:
-                    self._needs_password = True
-                    if not self._password:
-                        break
-            elif h.type == RAR_BLOCK_ENDARC:
-                more_vols = (h.flags & RAR_ENDARC_NEXT_VOLUME) > 0
-                endarc = True
-                if raise_need_first_vol and (h.flags & RAR_ENDARC_VOLNR) > 0:
-                    raise NeedFirstVolume(
-                        "Need to start from first volume (current: %r)"
-                        % (h.endarc_volnr,),
-                        h.endarc_volnr
-                    )
-            elif h.type == RAR_BLOCK_FILE:
-                # RAR 2.x does not write RAR_BLOCK_ENDARC
-                if h.flags & RAR_FILE_SPLIT_AFTER:
-                    more_vols = True
-                # RAR 2.x does not set RAR_MAIN_FIRSTVOLUME
-                if volume == 0 and h.flags & RAR_FILE_SPLIT_BEFORE:
-                    raise_need_first_vol = True
-
-            if h.needs_password():
-                self._needs_password = True
-
-            # store it
-            self.process_entry(fd, h)
-
-            if self._info_callback:
-                self._info_callback(h)
-
-            # go to next header
-            if h.add_size > 0:
-                fd.seek(h.data_offset + h.add_size, 0)
-
-    def process_entry(self, fd, item):
-        """Examine item, add into lookup cache."""
-        raise NotImplementedError()
-
-    def _decrypt_header(self, fd):
-        raise NotImplementedError("_decrypt_header")
-
-    def _parse_block_header(self, fd):
-        raise NotImplementedError("_parse_block_header")
-
-    def _open_hack(self, inf, pwd):
-        raise NotImplementedError("_open_hack")
-
-    def _parse_header(self, fd):
-        """Read single header
-        """
-        try:
-            # handle encrypted headers
-            if (self._main and self._main.flags & RAR_MAIN_PASSWORD) or self._hdrenc_main:
-                if not self._password:
-                    return None
-                fd = self._decrypt_header(fd)
-
-            # now read actual header
-            return self._parse_block_header(fd)
-        except struct.error:
-            self._set_error("Broken header in RAR file")
-            return None
-
-    def _next_volname(self, volfile):
-        """Given current vol name, construct next one
-        """
-        if is_filelike(volfile):
-            raise IOError("Working on single FD")
-        if self._main.flags & RAR_MAIN_NEWNUMBERING:
-            return _next_newvol(volfile)
-        return _next_oldvol(volfile)
-
-    def _set_error(self, msg, *args):
-        if args:
-            msg = msg % args
-        self._parse_error = msg
-        if self._strict:
-            raise BadRarFile(msg)
-
-    def open(self, inf, pwd):
-        """Return stream object for file data."""
-
-        if inf.file_redir:
-            redir_type, redir_flags, redir_name = inf.file_redir
-            # cannot leave to unrar as it expects copied file to exist
-            if redir_type in (RAR5_XREDIR_FILE_COPY, RAR5_XREDIR_HARD_LINK):
-                inf = self.getinfo(redir_name)
-                if not inf:
-                    raise BadRarFile("cannot find copied file")
-            elif redir_type in (
-                RAR5_XREDIR_UNIX_SYMLINK, RAR5_XREDIR_WINDOWS_SYMLINK,
-                RAR5_XREDIR_WINDOWS_JUNCTION,
-            ):
-                return io.BytesIO(redir_name.encode("utf8"))
-        if inf.flags & RAR_FILE_SPLIT_BEFORE:
-            raise NeedFirstVolume("Partial file, please start from first volume: " + inf.filename, None)
-
-        # is temp write usable?
-        use_hack = 1
-        if not self._main:
-            use_hack = 0
-        elif self._main._must_disable_hack():
-            use_hack = 0
-        elif inf._must_disable_hack():
-            use_hack = 0
-        elif is_filelike(self._rarfile):
-            pass
-        elif inf.file_size > HACK_SIZE_LIMIT:
-            use_hack = 0
-        elif not USE_EXTRACT_HACK:
-            use_hack = 0
-
-        # now extract
-        if inf.compress_type == RAR_M0 and (inf.flags & RAR_FILE_PASSWORD) == 0 and inf.file_redir is None:
-            return self._open_clear(inf)
-        elif use_hack:
-            return self._open_hack(inf, pwd)
-        elif is_filelike(self._rarfile):
-            return self._open_unrar_membuf(self._rarfile, inf, pwd)
-        else:
-            return self._open_unrar(self._rarfile, inf, pwd)
-
-    def _open_clear(self, inf):
-        return DirectReader(self, inf)
-
-    def _open_hack_core(self, inf, pwd, prefix, suffix):
-
-        size = inf.compress_size + inf.header_size
-        rf = XFile(inf.volume_file, 0)
-        rf.seek(inf.header_offset)
-
-        tmpfd, tmpname = mkstemp(suffix=".rar", dir=HACK_TMP_DIR)
-        tmpf = os.fdopen(tmpfd, "wb")
-
-        try:
-            tmpf.write(prefix)
-            while size > 0:
-                if size > BSIZE:
-                    buf = rf.read(BSIZE)
-                else:
-                    buf = rf.read(size)
-                if not buf:
-                    raise BadRarFile("read failed: " + inf.filename)
-                tmpf.write(buf)
-                size -= len(buf)
-            tmpf.write(suffix)
-            tmpf.close()
-            rf.close()
-        except BaseException:
-            rf.close()
-            tmpf.close()
-            os.unlink(tmpname)
-            raise
-
-        return self._open_unrar(tmpname, inf, pwd, tmpname)
-
-    def _open_unrar_membuf(self, memfile, inf, pwd):
-        """Write in-memory archive to temp file, needed for solid archives.
-        """
-        tmpname = membuf_tempfile(memfile)
-        return self._open_unrar(tmpname, inf, pwd, tmpname, force_file=True)
-
-    def _open_unrar(self, rarfile, inf, pwd=None, tmpfile=None, force_file=False):
-        """Extract using unrar
-        """
-        setup = tool_setup()
-
-        # not giving filename avoids encoding related problems
-        fn = None
-        if not tmpfile or force_file:
-            fn = inf.filename
-
-        # read from unrar pipe
-        cmd = setup.open_cmdline(pwd, rarfile, fn)
-        return PipeReader(self, inf, cmd, tmpfile)
-
-
-#
-# RAR3 format
-#
-
-class Rar3Info(RarInfo):
-    """RAR3 specific fields."""
-    extract_version = 15
-    salt = None
-    add_size = 0
-    header_crc = None
-    header_size = None
-    header_offset = None
-    data_offset = None
-    _md_class = None
-    _md_expect = None
-    _name_size = None
-
-    # make sure some rar5 fields are always present
-    file_redir = None
-    blake2sp_hash = None
-
-    endarc_datacrc = None
-    endarc_volnr = None
-
-    def _must_disable_hack(self):
-        if self.type == RAR_BLOCK_FILE:
-            if self.flags & RAR_FILE_PASSWORD:
-                return True
-            elif self.flags & (RAR_FILE_SPLIT_BEFORE | RAR_FILE_SPLIT_AFTER):
-                return True
-        elif self.type == RAR_BLOCK_MAIN:
-            if self.flags & (RAR_MAIN_SOLID | RAR_MAIN_PASSWORD):
-                return True
-        return False
-
-    def is_dir(self):
-        """Returns True if entry is a directory."""
-        if self.type == RAR_BLOCK_FILE and not self.is_symlink():
-            return (self.flags & RAR_FILE_DIRECTORY) == RAR_FILE_DIRECTORY
-        return False
-
-    def is_symlink(self):
-        """Returns True if entry is a symlink."""
-        return (
-            self.type == RAR_BLOCK_FILE and
-            self.host_os == RAR_OS_UNIX and
-            self.mode & 0xF000 == 0xA000
-        )
-
-    def is_file(self):
-        """Returns True if entry is a normal file."""
-        return (
-            self.type == RAR_BLOCK_FILE and
-            not (self.is_dir() or self.is_symlink())
-        )
-
-
-class RAR3Parser(CommonParser):
-    """Parse RAR3 file format.
-    """
-    _expect_sig = RAR_ID
-    _last_aes_key = (None, None, None)   # (salt, key, iv)
-
-    def _decrypt_header(self, fd):
-        if not _have_crypto:
-            raise NoCrypto("Cannot parse encrypted headers - no crypto")
-        salt = fd.read(8)
-        if self._last_aes_key[0] == salt:
-            key, iv = self._last_aes_key[1:]
-        else:
-            key, iv = rar3_s2k(self._password, salt)
-            self._last_aes_key = (salt, key, iv)
-        return HeaderDecrypt(fd, key, iv)
-
-    def _parse_block_header(self, fd):
-        """Parse common block header
-        """
-        h = Rar3Info()
-        h.header_offset = fd.tell()
-
-        # read and parse base header
-        buf = fd.read(S_BLK_HDR.size)
-        if not buf:
-            return None
-        t = S_BLK_HDR.unpack_from(buf)
-        h.header_crc, h.type, h.flags, h.header_size = t
-
-        # read full header
-        if h.header_size > S_BLK_HDR.size:
-            hdata = buf + fd.read(h.header_size - S_BLK_HDR.size)
-        else:
-            hdata = buf
-        h.data_offset = fd.tell()
-
-        # unexpected EOF?
-        if len(hdata) != h.header_size:
-            self._set_error("Unexpected EOF when reading header")
-            return None
-
-        pos = S_BLK_HDR.size
-
-        # block has data assiciated with it?
-        if h.flags & RAR_LONG_BLOCK:
-            h.add_size, pos = load_le32(hdata, pos)
-        else:
-            h.add_size = 0
-
-        # parse interesting ones, decide header boundaries for crc
-        if h.type == RAR_BLOCK_MARK:
-            return h
-        elif h.type == RAR_BLOCK_MAIN:
-            pos += 6
-            if h.flags & RAR_MAIN_ENCRYPTVER:
-                pos += 1
-            crc_pos = pos
-            if h.flags & RAR_MAIN_COMMENT:
-                self._parse_subblocks(h, hdata, pos)
-        elif h.type == RAR_BLOCK_FILE:
-            pos = self._parse_file_header(h, hdata, pos - 4)
-            crc_pos = pos
-            if h.flags & RAR_FILE_COMMENT:
-                pos = self._parse_subblocks(h, hdata, pos)
-        elif h.type == RAR_BLOCK_SUB:
-            pos = self._parse_file_header(h, hdata, pos - 4)
-            crc_pos = h.header_size
-        elif h.type == RAR_BLOCK_OLD_AUTH:
-            pos += 8
-            crc_pos = pos
-        elif h.type == RAR_BLOCK_OLD_EXTRA:
-            pos += 7
-            crc_pos = pos
-        elif h.type == RAR_BLOCK_ENDARC:
-            if h.flags & RAR_ENDARC_DATACRC:
-                h.endarc_datacrc, pos = load_le32(hdata, pos)
-            if h.flags & RAR_ENDARC_VOLNR:
-                h.endarc_volnr = S_SHORT.unpack_from(hdata, pos)[0]
-                pos += 2
-            crc_pos = h.header_size
-        else:
-            crc_pos = h.header_size
-
-        # check crc
-        if h.type == RAR_BLOCK_OLD_SUB:
-            crcdat = hdata[2:] + fd.read(h.add_size)
-        else:
-            crcdat = hdata[2:crc_pos]
-
-        calc_crc = crc32(crcdat) & 0xFFFF
-
-        # return good header
-        if h.header_crc == calc_crc:
-            return h
-
-        # header parsing failed.
-        self._set_error("Header CRC error (%02x): exp=%x got=%x (xlen = %d)",
-                        h.type, h.header_crc, calc_crc, len(crcdat))
-
-        # instead panicing, send eof
-        return None
-
-    def _parse_file_header(self, h, hdata, pos):
-        """Read file-specific header
-        """
-        fld = S_FILE_HDR.unpack_from(hdata, pos)
-        pos += S_FILE_HDR.size
-
-        h.compress_size = fld[0]
-        h.file_size = fld[1]
-        h.host_os = fld[2]
-        h.CRC = fld[3]
-        h.date_time = parse_dos_time(fld[4])
-        h.mtime = to_datetime(h.date_time)
-        h.extract_version = fld[5]
-        h.compress_type = fld[6]
-        h._name_size = name_size = fld[7]
-        h.mode = fld[8]
-
-        h._md_class = CRC32Context
-        h._md_expect = h.CRC
-
-        if h.flags & RAR_FILE_LARGE:
-            h1, pos = load_le32(hdata, pos)
-            h2, pos = load_le32(hdata, pos)
-            h.compress_size |= h1 << 32
-            h.file_size |= h2 << 32
-            h.add_size = h.compress_size
-
-        name, pos = load_bytes(hdata, name_size, pos)
-        if h.flags & RAR_FILE_UNICODE and b"\0" in name:
-            # stored in custom encoding
-            nul = name.find(b"\0")
-            h.orig_filename = name[:nul]
-            u = UnicodeFilename(h.orig_filename, name[nul + 1:])
-            h.filename = u.decode()
-
-            # if parsing failed fall back to simple name
-            if u.failed:
-                h.filename = self._decode(h.orig_filename)
-        elif h.flags & RAR_FILE_UNICODE:
-            # stored in UTF8
-            h.orig_filename = name
-            h.filename = name.decode("utf8", "replace")
-        else:
-            # stored in random encoding
-            h.orig_filename = name
-            h.filename = self._decode(name)
-
-        # change separator, set dir suffix
-        h.filename = h.filename.replace("\\", "/").rstrip("/")
-        if h.is_dir():
-            h.filename = h.filename + "/"
-
-        if h.flags & RAR_FILE_SALT:
-            h.salt, pos = load_bytes(hdata, 8, pos)
-        else:
-            h.salt = None
-
-        # optional extended time stamps
-        if h.flags & RAR_FILE_EXTTIME:
-            pos = _parse_ext_time(h, hdata, pos)
-        else:
-            h.mtime = h.atime = h.ctime = h.arctime = None
-
-        return pos
-
-    def _parse_subblocks(self, h, hdata, pos):
-        """Find old-style comment subblock
-        """
-        while pos < len(hdata):
-            # ordinary block header
-            t = S_BLK_HDR.unpack_from(hdata, pos)
-            ___scrc, stype, sflags, slen = t
-            pos_next = pos + slen
-            pos += S_BLK_HDR.size
-
-            # corrupt header
-            if pos_next < pos:
-                break
-
-            # followed by block-specific header
-            if stype == RAR_BLOCK_OLD_COMMENT and pos + S_COMMENT_HDR.size <= pos_next:
-                declen, ver, meth, crc = S_COMMENT_HDR.unpack_from(hdata, pos)
-                pos += S_COMMENT_HDR.size
-                data = hdata[pos: pos_next]
-                cmt = rar3_decompress(ver, meth, data, declen, sflags,
-                                      crc, self._password)
-                if not self._crc_check or (crc32(cmt) & 0xFFFF == crc):
-                    h.comment = self._decode_comment(cmt)
-
-            pos = pos_next
-        return pos
-
-    def _read_comment_v3(self, inf, pwd=None):
-
-        # read data
-        with XFile(inf.volume_file) as rf:
-            rf.seek(inf.data_offset)
-            data = rf.read(inf.compress_size)
-
-        # decompress
-        cmt = rar3_decompress(inf.extract_version, inf.compress_type, data,
-                              inf.file_size, inf.flags, inf.CRC, pwd, inf.salt)
-
-        # check crc
-        if self._crc_check:
-            crc = crc32(cmt)
-            if crc != inf.CRC:
-                return None
-
-        return self._decode_comment(cmt)
-
-    def _decode(self, val):
-        for c in TRY_ENCODINGS:
-            try:
-                return val.decode(c)
-            except UnicodeError:
-                pass
-        return val.decode(self._charset, "replace")
-
-    def _decode_comment(self, val):
-        return self._decode(val)
-
-    def process_entry(self, fd, item):
-        if item.type == RAR_BLOCK_FILE:
-            # use only first part
-            if item.flags & RAR_FILE_VERSION:
-                pass    # skip old versions
-            elif (item.flags & RAR_FILE_SPLIT_BEFORE) == 0:
-                self._info_map[item.filename.rstrip("/")] = item
-                self._info_list.append(item)
-            elif len(self._info_list) > 0:
-                # final crc is in last block
-                old = self._info_list[-1]
-                old.CRC = item.CRC
-                old._md_expect = item._md_expect
-                old.compress_size += item.compress_size
-
-        # parse new-style comment
-        if item.type == RAR_BLOCK_SUB and item.filename == "CMT":
-            if item.flags & (RAR_FILE_SPLIT_BEFORE | RAR_FILE_SPLIT_AFTER):
-                pass
-            elif item.flags & RAR_FILE_SOLID:
-                # file comment
-                cmt = self._read_comment_v3(item, self._password)
-                if len(self._info_list) > 0:
-                    old = self._info_list[-1]
-                    old.comment = cmt
-            else:
-                # archive comment
-                cmt = self._read_comment_v3(item, self._password)
-                self.comment = cmt
-
-        if item.type == RAR_BLOCK_MAIN:
-            if item.flags & RAR_MAIN_COMMENT:
-                self.comment = item.comment
-            if item.flags & RAR_MAIN_PASSWORD:
-                self._needs_password = True
-
-    # put file compressed data into temporary .rar archive, and run
-    # unrar on that, thus avoiding unrar going over whole archive
-    def _open_hack(self, inf, pwd):
-        # create main header: crc, type, flags, size, res1, res2
-        prefix = RAR_ID + S_BLK_HDR.pack(0x90CF, 0x73, 0, 13) + b"\0" * (2 + 4)
-        return self._open_hack_core(inf, pwd, prefix, b"")
-
-
-#
-# RAR5 format
-#
-
-class Rar5Info(RarInfo):
-    """Shared fields for RAR5 records.
-    """
-    extract_version = 50
-    header_crc = None
-    header_size = None
-    header_offset = None
-    data_offset = None
-
-    # type=all
-    block_type = None
-    block_flags = None
-    add_size = 0
-    block_extra_size = 0
-
-    # type=MAIN
-    volume_number = None
-    _md_class = None
-    _md_expect = None
-
-    def _must_disable_hack(self):
-        return False
-
-
-class Rar5BaseFile(Rar5Info):
-    """Shared sturct for file & service record.
-    """
-    type = -1
-    file_flags = None
-    file_encryption = (0, 0, 0, b"", b"", b"")
-    file_compress_flags = None
-    file_redir = None
-    file_owner = None
-    file_version = None
-    blake2sp_hash = None
-
-    def _must_disable_hack(self):
-        if self.flags & RAR_FILE_PASSWORD:
-            return True
-        if self.block_flags & (RAR5_BLOCK_FLAG_SPLIT_BEFORE | RAR5_BLOCK_FLAG_SPLIT_AFTER):
-            return True
-        if self.file_compress_flags & RAR5_COMPR_SOLID:
-            return True
-        if self.file_redir:
-            return True
-        return False
-
-
-class Rar5FileInfo(Rar5BaseFile):
-    """RAR5 file record.
-    """
-    type = RAR_BLOCK_FILE
-
-    def is_symlink(self):
-        """Returns True if entry is a symlink."""
-        # pylint: disable=unsubscriptable-object
-        return (
-            self.file_redir is not None and
-            self.file_redir[0] in (
-                RAR5_XREDIR_UNIX_SYMLINK,
-                RAR5_XREDIR_WINDOWS_SYMLINK,
-                RAR5_XREDIR_WINDOWS_JUNCTION,
-            )
-        )
-
-    def is_file(self):
-        """Returns True if entry is a normal file."""
-        return not (self.is_dir() or self.is_symlink())
-
-    def is_dir(self):
-        """Returns True if entry is a directory."""
-        if not self.file_redir:
-            if self.file_flags & RAR5_FILE_FLAG_ISDIR:
-                return True
-        return False
-
-
-class Rar5ServiceInfo(Rar5BaseFile):
-    """RAR5 service record.
-    """
-    type = RAR_BLOCK_SUB
-
-
-class Rar5MainInfo(Rar5Info):
-    """RAR5 archive main record.
-    """
-    type = RAR_BLOCK_MAIN
-    main_flags = None
-    main_volume_number = None
-
-    def _must_disable_hack(self):
-        if self.main_flags & RAR5_MAIN_FLAG_SOLID:
-            return True
-        return False
-
-
-class Rar5EncryptionInfo(Rar5Info):
-    """RAR5 archive header encryption record.
-    """
-    type = RAR5_BLOCK_ENCRYPTION
-    encryption_algo = None
-    encryption_flags = None
-    encryption_kdf_count = None
-    encryption_salt = None
-    encryption_check_value = None
-
-    def needs_password(self):
-        return True
-
-
-class Rar5EndArcInfo(Rar5Info):
-    """RAR5 end of archive record.
-    """
-    type = RAR_BLOCK_ENDARC
-    endarc_flags = None
-
-
-class RAR5Parser(CommonParser):
-    """Parse RAR5 format.
-    """
-    _expect_sig = RAR5_ID
-    _hdrenc_main = None
-
-    # AES encrypted headers
-    _last_aes256_key = (-1, None, None)   # (kdf_count, salt, key)
-
-    def _gen_key(self, kdf_count, salt):
-        if self._last_aes256_key[:2] == (kdf_count, salt):
-            return self._last_aes256_key[2]
-        if kdf_count > 24:
-            raise BadRarFile("Too large kdf_count")
-        pwd = self._password
-        if isinstance(pwd, str):
-            pwd = pwd.encode("utf8")
-        key = pbkdf2_hmac("sha256", pwd, salt, 1 << kdf_count)
-        self._last_aes256_key = (kdf_count, salt, key)
-        return key
-
-    def _decrypt_header(self, fd):
-        if not _have_crypto:
-            raise NoCrypto("Cannot parse encrypted headers - no crypto")
-        h = self._hdrenc_main
-        key = self._gen_key(h.encryption_kdf_count, h.encryption_salt)
-        iv = fd.read(16)
-        return HeaderDecrypt(fd, key, iv)
-
-    def _parse_block_header(self, fd):
-        """Parse common block header
-        """
-        header_offset = fd.tell()
-
-        preload = 4 + 3
-        start_bytes = fd.read(preload)
-        header_crc, pos = load_le32(start_bytes, 0)
-        hdrlen, pos = load_vint(start_bytes, pos)
-        if hdrlen > 2 * 1024 * 1024:
-            return None
-        header_size = pos + hdrlen
-
-        # read full header, check for EOF
-        hdata = start_bytes + fd.read(header_size - len(start_bytes))
-        if len(hdata) != header_size:
-            self._set_error("Unexpected EOF when reading header")
-            return None
-        data_offset = fd.tell()
-
-        calc_crc = crc32(memoryview(hdata)[4:])
-        if header_crc != calc_crc:
-            # header parsing failed.
-            self._set_error("Header CRC error: exp=%x got=%x (xlen = %d)",
-                            header_crc, calc_crc, len(hdata))
-            return None
-
-        block_type, pos = load_vint(hdata, pos)
-
-        if block_type == RAR5_BLOCK_MAIN:
-            h, pos = self._parse_block_common(Rar5MainInfo(), hdata)
-            h = self._parse_main_block(h, hdata, pos)
-        elif block_type == RAR5_BLOCK_FILE:
-            h, pos = self._parse_block_common(Rar5FileInfo(), hdata)
-            h = self._parse_file_block(h, hdata, pos)
-        elif block_type == RAR5_BLOCK_SERVICE:
-            h, pos = self._parse_block_common(Rar5ServiceInfo(), hdata)
-            h = self._parse_file_block(h, hdata, pos)
-        elif block_type == RAR5_BLOCK_ENCRYPTION:
-            h, pos = self._parse_block_common(Rar5EncryptionInfo(), hdata)
-            h = self._parse_encryption_block(h, hdata, pos)
-        elif block_type == RAR5_BLOCK_ENDARC:
-            h, pos = self._parse_block_common(Rar5EndArcInfo(), hdata)
-            h = self._parse_endarc_block(h, hdata, pos)
-        else:
-            h = None
-        if h:
-            h.header_offset = header_offset
-            h.data_offset = data_offset
-        return h
-
-    def _parse_block_common(self, h, hdata):
-        h.header_crc, pos = load_le32(hdata, 0)
-        hdrlen, pos = load_vint(hdata, pos)
-        h.header_size = hdrlen + pos
-        h.block_type, pos = load_vint(hdata, pos)
-        h.block_flags, pos = load_vint(hdata, pos)
-
-        if h.block_flags & RAR5_BLOCK_FLAG_EXTRA_DATA:
-            h.block_extra_size, pos = load_vint(hdata, pos)
-        if h.block_flags & RAR5_BLOCK_FLAG_DATA_AREA:
-            h.add_size, pos = load_vint(hdata, pos)
-
-        h.compress_size = h.add_size
-
-        if h.block_flags & RAR5_BLOCK_FLAG_SKIP_IF_UNKNOWN:
-            h.flags |= RAR_SKIP_IF_UNKNOWN
-        if h.block_flags & RAR5_BLOCK_FLAG_DATA_AREA:
-            h.flags |= RAR_LONG_BLOCK
-        return h, pos
-
-    def _parse_main_block(self, h, hdata, pos):
-        h.main_flags, pos = load_vint(hdata, pos)
-        if h.main_flags & RAR5_MAIN_FLAG_HAS_VOLNR:
-            h.main_volume_number, pos = load_vint(hdata, pos)
-
-        h.flags |= RAR_MAIN_NEWNUMBERING
-        if h.main_flags & RAR5_MAIN_FLAG_SOLID:
-            h.flags |= RAR_MAIN_SOLID
-        if h.main_flags & RAR5_MAIN_FLAG_ISVOL:
-            h.flags |= RAR_MAIN_VOLUME
-        if h.main_flags & RAR5_MAIN_FLAG_RECOVERY:
-            h.flags |= RAR_MAIN_RECOVERY
-        if self._hdrenc_main:
-            h.flags |= RAR_MAIN_PASSWORD
-        if h.main_flags & RAR5_MAIN_FLAG_HAS_VOLNR == 0:
-            h.flags |= RAR_MAIN_FIRSTVOLUME
-
-        return h
-
-    def _parse_file_block(self, h, hdata, pos):
-        h.file_flags, pos = load_vint(hdata, pos)
-        h.file_size, pos = load_vint(hdata, pos)
-        h.mode, pos = load_vint(hdata, pos)
-
-        if h.file_flags & RAR5_FILE_FLAG_HAS_MTIME:
-            h.mtime, pos = load_unixtime(hdata, pos)
-            h.date_time = h.mtime.timetuple()[:6]
-        if h.file_flags & RAR5_FILE_FLAG_HAS_CRC32:
-            h.CRC, pos = load_le32(hdata, pos)
-            h._md_class = CRC32Context
-            h._md_expect = h.CRC
-
-        h.file_compress_flags, pos = load_vint(hdata, pos)
-        h.file_host_os, pos = load_vint(hdata, pos)
-        h.orig_filename, pos = load_vstr(hdata, pos)
-        h.filename = h.orig_filename.decode("utf8", "replace").rstrip("/")
-
-        # use compatible values
-        if h.file_host_os == RAR5_OS_WINDOWS:
-            h.host_os = RAR_OS_WIN32
-        else:
-            h.host_os = RAR_OS_UNIX
-        h.compress_type = RAR_M0 + ((h.file_compress_flags >> 7) & 7)
-
-        if h.block_extra_size:
-            # allow 1 byte of garbage
-            while pos < len(hdata) - 1:
-                xsize, pos = load_vint(hdata, pos)
-                xdata, pos = load_bytes(hdata, xsize, pos)
-                self._process_file_extra(h, xdata)
-
-        if h.block_flags & RAR5_BLOCK_FLAG_SPLIT_BEFORE:
-            h.flags |= RAR_FILE_SPLIT_BEFORE
-        if h.block_flags & RAR5_BLOCK_FLAG_SPLIT_AFTER:
-            h.flags |= RAR_FILE_SPLIT_AFTER
-        if h.file_flags & RAR5_FILE_FLAG_ISDIR:
-            h.flags |= RAR_FILE_DIRECTORY
-        if h.file_compress_flags & RAR5_COMPR_SOLID:
-            h.flags |= RAR_FILE_SOLID
-
-        if h.is_dir():
-            h.filename = h.filename + "/"
-        return h
-
-    def _parse_endarc_block(self, h, hdata, pos):
-        h.endarc_flags, pos = load_vint(hdata, pos)
-        if h.endarc_flags & RAR5_ENDARC_FLAG_NEXT_VOL:
-            h.flags |= RAR_ENDARC_NEXT_VOLUME
-        return h
-
-    def _parse_encryption_block(self, h, hdata, pos):
-        h.encryption_algo, pos = load_vint(hdata, pos)
-        h.encryption_flags, pos = load_vint(hdata, pos)
-        h.encryption_kdf_count, pos = load_byte(hdata, pos)
-        h.encryption_salt, pos = load_bytes(hdata, 16, pos)
-        if h.encryption_flags & RAR5_ENC_FLAG_HAS_CHECKVAL:
-            h.encryption_check_value = load_bytes(hdata, 12, pos)
-        if h.encryption_algo != RAR5_XENC_CIPHER_AES256:
-            raise BadRarFile("Unsupported header encryption cipher")
-        self._hdrenc_main = h
-        return h
-
-    def _process_file_extra(self, h, xdata):
-        xtype, pos = load_vint(xdata, 0)
-        if xtype == RAR5_XFILE_TIME:
-            self._parse_file_xtime(h, xdata, pos)
-        elif xtype == RAR5_XFILE_ENCRYPTION:
-            self._parse_file_encryption(h, xdata, pos)
-        elif xtype == RAR5_XFILE_HASH:
-            self._parse_file_hash(h, xdata, pos)
-        elif xtype == RAR5_XFILE_VERSION:
-            self._parse_file_version(h, xdata, pos)
-        elif xtype == RAR5_XFILE_REDIR:
-            self._parse_file_redir(h, xdata, pos)
-        elif xtype == RAR5_XFILE_OWNER:
-            self._parse_file_owner(h, xdata, pos)
-        elif xtype == RAR5_XFILE_SERVICE:
-            pass
-        else:
-            pass
-
-    # extra block for file time record
-    def _parse_file_xtime(self, h, xdata, pos):
-        tflags, pos = load_vint(xdata, pos)
-
-        ldr = load_windowstime
-        if tflags & RAR5_XTIME_UNIXTIME:
-            ldr = load_unixtime
-
-        if tflags & RAR5_XTIME_HAS_MTIME:
-            h.mtime, pos = ldr(xdata, pos)
-            h.date_time = h.mtime.timetuple()[:6]
-        if tflags & RAR5_XTIME_HAS_CTIME:
-            h.ctime, pos = ldr(xdata, pos)
-        if tflags & RAR5_XTIME_HAS_ATIME:
-            h.atime, pos = ldr(xdata, pos)
-
-        if tflags & RAR5_XTIME_UNIXTIME_NS:
-            if tflags & RAR5_XTIME_HAS_MTIME:
-                nsec, pos = load_le32(xdata, pos)
-                h.mtime = to_nsdatetime(h.mtime, nsec)
-            if tflags & RAR5_XTIME_HAS_CTIME:
-                nsec, pos = load_le32(xdata, pos)
-                h.ctime = to_nsdatetime(h.ctime, nsec)
-            if tflags & RAR5_XTIME_HAS_ATIME:
-                nsec, pos = load_le32(xdata, pos)
-                h.atime = to_nsdatetime(h.atime, nsec)
-
-    # just remember encryption info
-    def _parse_file_encryption(self, h, xdata, pos):
-        algo, pos = load_vint(xdata, pos)
-        flags, pos = load_vint(xdata, pos)
-        kdf_count, pos = load_byte(xdata, pos)
-        salt, pos = load_bytes(xdata, 16, pos)
-        iv, pos = load_bytes(xdata, 16, pos)
-        checkval = None
-        if flags & RAR5_XENC_CHECKVAL:
-            checkval, pos = load_bytes(xdata, 12, pos)
-        if flags & RAR5_XENC_TWEAKED:
-            h._md_expect = None
-            h._md_class = NoHashContext
-
-        h.file_encryption = (algo, flags, kdf_count, salt, iv, checkval)
-        h.flags |= RAR_FILE_PASSWORD
-
-    def _parse_file_hash(self, h, xdata, pos):
-        hash_type, pos = load_vint(xdata, pos)
-        if hash_type == RAR5_XHASH_BLAKE2SP:
-            h.blake2sp_hash, pos = load_bytes(xdata, 32, pos)
-            if (h.file_encryption[1] & RAR5_XENC_TWEAKED) == 0:
-                h._md_class = Blake2SP
-                h._md_expect = h.blake2sp_hash
-
-    def _parse_file_version(self, h, xdata, pos):
-        flags, pos = load_vint(xdata, pos)
-        version, pos = load_vint(xdata, pos)
-        h.file_version = (flags, version)
-
-    def _parse_file_redir(self, h, xdata, pos):
-        redir_type, pos = load_vint(xdata, pos)
-        redir_flags, pos = load_vint(xdata, pos)
-        redir_name, pos = load_vstr(xdata, pos)
-        redir_name = redir_name.decode("utf8", "replace")
-        h.file_redir = (redir_type, redir_flags, redir_name)
-
-    def _parse_file_owner(self, h, xdata, pos):
-        user_name = group_name = user_id = group_id = None
-
-        flags, pos = load_vint(xdata, pos)
-        if flags & RAR5_XOWNER_UNAME:
-            user_name, pos = load_vstr(xdata, pos)
-        if flags & RAR5_XOWNER_GNAME:
-            group_name, pos = load_vstr(xdata, pos)
-        if flags & RAR5_XOWNER_UID:
-            user_id, pos = load_vint(xdata, pos)
-        if flags & RAR5_XOWNER_GID:
-            group_id, pos = load_vint(xdata, pos)
-
-        h.file_owner = (user_name, group_name, user_id, group_id)
-
-    def process_entry(self, fd, item):
-        if item.block_type == RAR5_BLOCK_FILE:
-            if item.file_version:
-                pass    # skip old versions
-            elif (item.block_flags & RAR5_BLOCK_FLAG_SPLIT_BEFORE) == 0:
-                # use only first part
-                self._info_map[item.filename.rstrip("/")] = item
-                self._info_list.append(item)
-            elif len(self._info_list) > 0:
-                # final crc is in last block
-                old = self._info_list[-1]
-                old.CRC = item.CRC
-                old._md_expect = item._md_expect
-                old.blake2sp_hash = item.blake2sp_hash
-                old.compress_size += item.compress_size
-        elif item.block_type == RAR5_BLOCK_SERVICE:
-            if item.filename == "CMT":
-                self._load_comment(fd, item)
-
-    def _load_comment(self, fd, item):
-        if item.block_flags & (RAR5_BLOCK_FLAG_SPLIT_BEFORE | RAR5_BLOCK_FLAG_SPLIT_AFTER):
-            return None
-        if item.compress_type != RAR_M0:
-            return None
-
-        if item.flags & RAR_FILE_PASSWORD:
-            algo, ___flags, kdf_count, salt, iv, ___checkval = item.file_encryption
-            if algo != RAR5_XENC_CIPHER_AES256:
-                return None
-            key = self._gen_key(kdf_count, salt)
-            f = HeaderDecrypt(fd, key, iv)
-            cmt = f.read(item.file_size)
-        else:
-            # archive comment
-            with self._open_clear(item) as cmtstream:
-                cmt = cmtstream.read()
-
-        # rar bug? - appends zero to comment
-        cmt = cmt.split(b"\0", 1)[0]
-        self.comment = cmt.decode("utf8")
-        return None
-
-    def _open_hack(self, inf, pwd):
-        # len, type, blk_flags, flags
-        main_hdr = b"\x03\x01\x00\x00"
-        endarc_hdr = b"\x03\x05\x00\x00"
-        main_hdr = S_LONG.pack(crc32(main_hdr)) + main_hdr
-        endarc_hdr = S_LONG.pack(crc32(endarc_hdr)) + endarc_hdr
-        return self._open_hack_core(inf, pwd, RAR5_ID + main_hdr, endarc_hdr)
-
-
-##
-## Utility classes
-##
-
-class UnicodeFilename:
-    """Handle RAR3 unicode filename decompression.
-    """
-    def __init__(self, name, encdata):
-        self.std_name = bytearray(name)
-        self.encdata = bytearray(encdata)
-        self.pos = self.encpos = 0
-        self.buf = bytearray()
-        self.failed = 0
-
-    def enc_byte(self):
-        """Copy encoded byte."""
-        try:
-            c = self.encdata[self.encpos]
-            self.encpos += 1
-            return c
-        except IndexError:
-            self.failed = 1
-            return 0
-
-    def std_byte(self):
-        """Copy byte from 8-bit representation."""
-        try:
-            return self.std_name[self.pos]
-        except IndexError:
-            self.failed = 1
-            return ord("?")
-
-    def put(self, lo, hi):
-        """Copy 16-bit value to result."""
-        self.buf.append(lo)
-        self.buf.append(hi)
-        self.pos += 1
-
-    def decode(self):
-        """Decompress compressed UTF16 value."""
-        hi = self.enc_byte()
-        flagbits = 0
-        while self.encpos < len(self.encdata):
-            if flagbits == 0:
-                flags = self.enc_byte()
-                flagbits = 8
-            flagbits -= 2
-            t = (flags >> flagbits) & 3
-            if t == 0:
-                self.put(self.enc_byte(), 0)
-            elif t == 1:
-                self.put(self.enc_byte(), hi)
-            elif t == 2:
-                self.put(self.enc_byte(), self.enc_byte())
-            else:
-                n = self.enc_byte()
-                if n & 0x80:
-                    c = self.enc_byte()
-                    for _ in range((n & 0x7f) + 2):
-                        lo = (self.std_byte() + c) & 0xFF
-                        self.put(lo, hi)
-                else:
-                    for _ in range(n + 2):
-                        self.put(self.std_byte(), 0)
-        return self.buf.decode("utf-16le", "replace")
-
-
-class RarExtFile(io.RawIOBase):
-    """Base class for file-like object that :meth:`RarFile.open` returns.
-
-    Provides public methods and common crc checking.
-
-    Behaviour:
-     - no short reads - .read() and .readinfo() read as much as requested.
-     - no internal buffer, use io.BufferedReader for that.
-    """
-    name = None     #: Filename of the archive entry
-    mode = "rb"
-    _parser = None
-    _inf = None
-    _fd = None
-    _remain = 0
-    _returncode = 0
-    _md_context = None
-
-    def _open_extfile(self, parser, inf):
-        self.name = inf.filename
-        self._parser = parser
-        self._inf = inf
-
-        if self._fd:
-            self._fd.close()
-        md_class = self._inf._md_class or NoHashContext
-        self._md_context = md_class()
-        self._fd = None
-        self._remain = self._inf.file_size
-
-    def read(self, n=-1):
-        """Read all or specified amount of data from archive entry."""
-
-        # sanitize count
-        if n is None or n < 0:
-            n = self._remain
-        elif n > self._remain:
-            n = self._remain
-        if n == 0:
-            return b""
-
-        buf = []
-        orig = n
-        while n > 0:
-            # actual read
-            data = self._read(n)
-            if not data:
-                break
-            buf.append(data)
-            self._md_context.update(data)
-            self._remain -= len(data)
-            n -= len(data)
-        data = b"".join(buf)
-        if n > 0:
-            raise BadRarFile("Failed the read enough data: req=%d got=%d" % (orig, len(data)))
-
-        # done?
-        if not data or self._remain == 0:
-            # self.close()
-            self._check()
-        return data
-
-    def _check(self):
-        """Check final CRC."""
-        final = self._md_context.digest()
-        exp = self._inf._md_expect
-        if exp is None:
-            return
-        if final is None:
-            return
-        if self._returncode:
-            check_returncode(self._returncode, "", tool_setup().get_errmap())
-        if self._remain != 0:
-            raise BadRarFile("Failed the read enough data")
-        if final != exp:
-            raise BadRarFile("Corrupt file - CRC check failed: %s - exp=%r got=%r" % (
-                self._inf.filename, exp, final))
-
-    def _read(self, cnt):
-        """Actual read that gets sanitized cnt."""
-        raise NotImplementedError("_read")
-
-    def close(self):
-        """Close open resources."""
-
-        super().close()
-
-        if self._fd:
-            self._fd.close()
-            self._fd = None
-
-    def __del__(self):
-        """Hook delete to make sure tempfile is removed."""
-        self.close()
-
-    def readinto(self, buf):
-        """Zero-copy read directly into buffer.
-
-        Returns bytes read.
-        """
-        raise NotImplementedError("readinto")
-
-    def tell(self):
-        """Return current reading position in uncompressed data."""
-        return self._inf.file_size - self._remain
-
-    def seek(self, offset, whence=0):
-        """Seek in data.
-
-        On uncompressed files, the seeking works by actual
-        seeks so it's fast.  On compresses files its slow
-        - forward seeking happends by reading ahead,
-        backwards by re-opening and decompressing from the start.
-        """
-
-        # disable crc check when seeking
-        self._md_context = NoHashContext()
-
-        fsize = self._inf.file_size
-        cur_ofs = self.tell()
-
-        if whence == 0:     # seek from beginning of file
-            new_ofs = offset
-        elif whence == 1:   # seek from current position
-            new_ofs = cur_ofs + offset
-        elif whence == 2:   # seek from end of file
-            new_ofs = fsize + offset
-        else:
-            raise ValueError("Invalid value for whence")
-
-        # sanity check
-        if new_ofs < 0:
-            new_ofs = 0
-        elif new_ofs > fsize:
-            new_ofs = fsize
-
-        # do the actual seek
-        if new_ofs >= cur_ofs:
-            self._skip(new_ofs - cur_ofs)
-        else:
-            # reopen and seek
-            self._open_extfile(self._parser, self._inf)
-            self._skip(new_ofs)
-        return self.tell()
-
-    def _skip(self, cnt):
-        """Read and discard data"""
-        empty_read(self, cnt, BSIZE)
-
-    def readable(self):
-        """Returns True"""
-        return True
-
-    def writable(self):
-        """Returns False.
-
-        Writing is not supported.
-        """
-        return False
-
-    def seekable(self):
-        """Returns True.
-
-        Seeking is supported, although it's slow on compressed files.
-        """
-        return True
-
-    def readall(self):
-        """Read all remaining data"""
-        # avoid RawIOBase default impl
-        return self.read()
-
-
-class PipeReader(RarExtFile):
-    """Read data from pipe, handle tempfile cleanup."""
-
-    def __init__(self, parser, inf, cmd, tempfile=None):
-        super().__init__()
-        self._cmd = cmd
-        self._proc = None
-        self._tempfile = tempfile
-        self._open_extfile(parser, inf)
-
-    def _close_proc(self):
-        if not self._proc:
-            return
-        for f in (self._proc.stdout, self._proc.stderr, self._proc.stdin):
-            if f:
-                f.close()
-        self._proc.wait()
-        self._returncode = self._proc.returncode
-        self._proc = None
-
-    def _open_extfile(self, parser, inf):
-        super()._open_extfile(parser, inf)
-
-        # stop old process
-        self._close_proc()
-
-        # launch new process
-        self._returncode = 0
-        self._proc = custom_popen(self._cmd)
-        self._fd = self._proc.stdout
-
-    def _read(self, cnt):
-        """Read from pipe."""
-
-        # normal read is usually enough
-        data = self._fd.read(cnt)
-        if len(data) == cnt or not data:
-            return data
-
-        # short read, try looping
-        buf = [data]
-        cnt -= len(data)
-        while cnt > 0:
-            data = self._fd.read(cnt)
-            if not data:
-                break
-            cnt -= len(data)
-            buf.append(data)
-        return b"".join(buf)
-
-    def close(self):
-        """Close open resources."""
-
-        self._close_proc()
-        super().close()
-
-        if self._tempfile:
-            try:
-                os.unlink(self._tempfile)
-            except OSError:
-                pass
-            self._tempfile = None
-
-    def readinto(self, buf):
-        """Zero-copy read directly into buffer."""
-        cnt = len(buf)
-        if cnt > self._remain:
-            cnt = self._remain
-        vbuf = memoryview(buf)
-        res = got = 0
-        while got < cnt:
-            res = self._fd.readinto(vbuf[got: cnt])
-            if not res:
-                break
-            self._md_context.update(vbuf[got: got + res])
-            self._remain -= res
-            got += res
-        return got
-
-
-class DirectReader(RarExtFile):
-    """Read uncompressed data directly from archive.
-    """
-    _cur = None
-    _cur_avail = None
-    _volfile = None
-
-    def __init__(self, parser, inf):
-        super().__init__()
-        self._open_extfile(parser, inf)
-
-    def _open_extfile(self, parser, inf):
-        super()._open_extfile(parser, inf)
-
-        self._volfile = self._inf.volume_file
-        self._fd = XFile(self._volfile, 0)
-        self._fd.seek(self._inf.header_offset, 0)
-        self._cur = self._parser._parse_header(self._fd)
-        self._cur_avail = self._cur.add_size
-
-    def _skip(self, cnt):
-        """RAR Seek, skipping through rar files to get to correct position
-        """
-
-        while cnt > 0:
-            # next vol needed?
-            if self._cur_avail == 0:
-                if not self._open_next():
-                    break
-
-            # fd is in read pos, do the read
-            if cnt > self._cur_avail:
-                cnt -= self._cur_avail
-                self._remain -= self._cur_avail
-                self._cur_avail = 0
-            else:
-                self._fd.seek(cnt, 1)
-                self._cur_avail -= cnt
-                self._remain -= cnt
-                cnt = 0
-
-    def _read(self, cnt):
-        """Read from potentially multi-volume archive."""
-
-        buf = []
-        while cnt > 0:
-            # next vol needed?
-            if self._cur_avail == 0:
-                if not self._open_next():
-                    break
-
-            # fd is in read pos, do the read
-            if cnt > self._cur_avail:
-                data = self._fd.read(self._cur_avail)
-            else:
-                data = self._fd.read(cnt)
-            if not data:
-                break
-
-            # got some data
-            cnt -= len(data)
-            self._cur_avail -= len(data)
-            buf.append(data)
-
-        if len(buf) == 1:
-            return buf[0]
-        return b"".join(buf)
-
-    def _open_next(self):
-        """Proceed to next volume."""
-
-        # is the file split over archives?
-        if (self._cur.flags & RAR_FILE_SPLIT_AFTER) == 0:
-            return False
-
-        if self._fd:
-            self._fd.close()
-            self._fd = None
-
-        # open next part
-        self._volfile = self._parser._next_volname(self._volfile)
-        fd = open(self._volfile, "rb", 0)
-        self._fd = fd
-        sig = fd.read(len(self._parser._expect_sig))
-        if sig != self._parser._expect_sig:
-            raise BadRarFile("Invalid signature")
-
-        # loop until first file header
-        while True:
-            cur = self._parser._parse_header(fd)
-            if not cur:
-                raise BadRarFile("Unexpected EOF")
-            if cur.type in (RAR_BLOCK_MARK, RAR_BLOCK_MAIN):
-                if cur.add_size:
-                    fd.seek(cur.add_size, 1)
-                continue
-            if cur.orig_filename != self._inf.orig_filename:
-                raise BadRarFile("Did not found file entry")
-            self._cur = cur
-            self._cur_avail = cur.add_size
-            return True
-
-    def readinto(self, buf):
-        """Zero-copy read directly into buffer."""
-        got = 0
-        vbuf = memoryview(buf)
-        while got < len(buf):
-            # next vol needed?
-            if self._cur_avail == 0:
-                if not self._open_next():
-                    break
-
-            # length for next read
-            cnt = len(buf) - got
-            if cnt > self._cur_avail:
-                cnt = self._cur_avail
-
-            # read into temp view
-            res = self._fd.readinto(vbuf[got: got + cnt])
-            if not res:
-                break
-            self._md_context.update(vbuf[got: got + res])
-            self._cur_avail -= res
-            self._remain -= res
-            got += res
-        return got
-
-
-class HeaderDecrypt:
-    """File-like object that decrypts from another file"""
-    def __init__(self, f, key, iv):
-        self.f = f
-        self.ciph = AES_CBC_Decrypt(key, iv)
-        self.buf = b""
-
-    def tell(self):
-        """Current file pos - works only on block boundaries."""
-        return self.f.tell()
-
-    def read(self, cnt=None):
-        """Read and decrypt."""
-        if cnt > 8 * 1024:
-            raise BadRarFile("Bad count to header decrypt - wrong password?")
-
-        # consume old data
-        if cnt <= len(self.buf):
-            res = self.buf[:cnt]
-            self.buf = self.buf[cnt:]
-            return res
-        res = self.buf
-        self.buf = b""
-        cnt -= len(res)
-
-        # decrypt new data
-        blklen = 16
-        while cnt > 0:
-            enc = self.f.read(blklen)
-            if len(enc) < blklen:
-                break
-            dec = self.ciph.decrypt(enc)
-            if cnt >= len(dec):
-                res += dec
-                cnt -= len(dec)
-            else:
-                res += dec[:cnt]
-                self.buf = dec[cnt:]
-                cnt = 0
-
-        return res
-
-
-class XFile:
-    """Input may be filename or file object.
-    """
-    __slots__ = ("_fd", "_need_close")
-
-    def __init__(self, xfile, bufsize=1024):
-        if is_filelike(xfile):
-            self._need_close = False
-            self._fd = xfile
-            self._fd.seek(0)
-        else:
-            self._need_close = True
-            self._fd = open(xfile, "rb", bufsize)
-
-    def read(self, n=None):
-        """Read from file."""
-        return self._fd.read(n)
-
-    def tell(self):
-        """Return file pos."""
-        return self._fd.tell()
-
-    def seek(self, ofs, whence=0):
-        """Move file pos."""
-        return self._fd.seek(ofs, whence)
-
-    def readinto(self, buf):
-        """Read into buffer."""
-        return self._fd.readinto(buf)
-
-    def close(self):
-        """Close file object."""
-        if self._need_close:
-            self._fd.close()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, typ, val, tb):
-        self.close()
-
-
-class NoHashContext:
-    """No-op hash function."""
-    def __init__(self, data=None):
-        """Initialize"""
-    def update(self, data):
-        """Update data"""
-    def digest(self):
-        """Final hash"""
-    def hexdigest(self):
-        """Hexadecimal digest."""
-
-
-class CRC32Context:
-    """Hash context that uses CRC32."""
-    __slots__ = ["_crc"]
-
-    def __init__(self, data=None):
-        self._crc = 0
-        if data:
-            self.update(data)
-
-    def update(self, data):
-        """Process data."""
-        self._crc = crc32(data, self._crc)
-
-    def digest(self):
-        """Final hash."""
-        return self._crc
-
-    def hexdigest(self):
-        """Hexadecimal digest."""
-        return "%08x" % self.digest()
-
-
-class Blake2SP:
-    """Blake2sp hash context.
-    """
-    __slots__ = ["_thread", "_buf", "_cur", "_digest"]
-    digest_size = 32
-    block_size = 64
-    parallelism = 8
-
-    def __init__(self, data=None):
-        self._buf = b""
-        self._cur = 0
-        self._digest = None
-        self._thread = []
-
-        for i in range(self.parallelism):
-            ctx = self._blake2s(i, 0, i == (self.parallelism - 1))
-            self._thread.append(ctx)
-
-        if data:
-            self.update(data)
-
-    def _blake2s(self, ofs, depth, is_last):
-        return blake2s(node_offset=ofs, node_depth=depth, last_node=is_last,
-                       depth=2, inner_size=32, fanout=self.parallelism)
-
-    def _add_block(self, blk):
-        self._thread[self._cur].update(blk)
-        self._cur = (self._cur + 1) % self.parallelism
-
-    def update(self, data):
-        """Hash data.
-        """
-        view = memoryview(data)
-        bs = self.block_size
-        if self._buf:
-            need = bs - len(self._buf)
-            if len(view) < need:
-                self._buf += view.tobytes()
-                return
-            self._add_block(self._buf + view[:need].tobytes())
-            view = view[need:]
-        while len(view) >= bs:
-            self._add_block(view[:bs])
-            view = view[bs:]
-        self._buf = view.tobytes()
-
-    def digest(self):
-        """Return final digest value.
-        """
-        if self._digest is None:
-            if self._buf:
-                self._add_block(self._buf)
-                self._buf = b""
-            ctx = self._blake2s(0, 1, True)
-            for t in self._thread:
-                ctx.update(t.digest())
-            self._digest = ctx.digest()
-        return self._digest
-
-    def hexdigest(self):
-        """Hexadecimal digest."""
-        return hexlify(self.digest()).decode("ascii")
-
-
-class Rar3Sha1:
-    """Emulate buggy SHA1 from RAR3.
-    """
-    digest_size = 20
-    block_size = 64
-
-    _BLK_BE = struct.Struct(b">16L")
-    _BLK_LE = struct.Struct(b"<16L")
-
-    __slots__ = ("_nbytes", "_md", "_rarbug")
-
-    def __init__(self, data=b"", rarbug=False):
-        self._md = sha1()
-        self._nbytes = 0
-        self._rarbug = rarbug
-        self.update(data)
-
-    def update(self, data):
-        """Process more data."""
-        self._md.update(data)
-        bufpos = self._nbytes & 63
-        self._nbytes += len(data)
-
-        if self._rarbug and len(data) > 64:
-            dpos = self.block_size - bufpos
-            while dpos + self.block_size <= len(data):
-                self._corrupt(data, dpos)
-                dpos += self.block_size
-
-    def digest(self):
-        """Return final state."""
-        return self._md.digest()
-
-    def hexdigest(self):
-        """Return final state as hex string."""
-        return self._md.hexdigest()
-
-    def _corrupt(self, data, dpos):
-        """Corruption from SHA1 core."""
-        ws = list(self._BLK_BE.unpack_from(data, dpos))
-        for t in range(16, 80):
-            tmp = ws[(t - 3) & 15] ^ ws[(t - 8) & 15] ^ ws[(t - 14) & 15] ^ ws[(t - 16) & 15]
-            ws[t & 15] = ((tmp << 1) | (tmp >> (32 - 1))) & 0xFFFFFFFF
-        self._BLK_LE.pack_into(data, dpos, *ws)
-
-
-##
-## Utility functions
-##
-
-S_LONG = Struct("<L")
-S_SHORT = Struct("<H")
-S_BYTE = Struct("<B")
-
-S_BLK_HDR = Struct("<HBHH")
-S_FILE_HDR = Struct("<LLBLLBBHL")
-S_COMMENT_HDR = Struct("<HBBH")
-
-
-def load_vint(buf, pos):
-    """Load RAR5 variable-size int."""
-    limit = min(pos + 11, len(buf))
-    res = ofs = 0
-    while pos < limit:
-        b = buf[pos]
-        res += ((b & 0x7F) << ofs)
-        pos += 1
-        ofs += 7
-        if b < 0x80:
-            return res, pos
-    raise BadRarFile("cannot load vint")
-
-
-def load_byte(buf, pos):
-    """Load single byte"""
-    end = pos + 1
-    if end > len(buf):
-        raise BadRarFile("cannot load byte")
-    return S_BYTE.unpack_from(buf, pos)[0], end
-
-
-def load_le32(buf, pos):
-    """Load little-endian 32-bit integer"""
-    end = pos + 4
-    if end > len(buf):
-        raise BadRarFile("cannot load le32")
-    return S_LONG.unpack_from(buf, pos)[0], pos + 4
-
-
-def load_bytes(buf, num, pos):
-    """Load sequence of bytes"""
-    end = pos + num
-    if end > len(buf):
-        raise BadRarFile("cannot load bytes")
-    return buf[pos: end], end
-
-
-def load_vstr(buf, pos):
-    """Load bytes prefixed by vint length"""
-    slen, pos = load_vint(buf, pos)
-    return load_bytes(buf, slen, pos)
-
-
-def load_dostime(buf, pos):
-    """Load LE32 dos timestamp"""
-    stamp, pos = load_le32(buf, pos)
-    tup = parse_dos_time(stamp)
-    return to_datetime(tup), pos
-
-
-def load_unixtime(buf, pos):
-    """Load LE32 unix timestamp"""
-    secs, pos = load_le32(buf, pos)
-    dt = datetime.fromtimestamp(secs, timezone.utc)
-    return dt, pos
-
-
-def load_windowstime(buf, pos):
-    """Load LE64 windows timestamp"""
-    # unix epoch (1970) in seconds from windows epoch (1601)
-    unix_epoch = 11644473600
-    val1, pos = load_le32(buf, pos)
-    val2, pos = load_le32(buf, pos)
-    secs, n1secs = divmod((val2 << 32) | val1, 10000000)
-    dt = datetime.fromtimestamp(secs - unix_epoch, timezone.utc)
-    dt = to_nsdatetime(dt, n1secs * 100)
-    return dt, pos
-
-
-def _next_newvol(volfile):
-    """New-style next volume
-    """
-    i = len(volfile) - 1
-    while i >= 0:
-        if volfile[i] >= "0" and volfile[i] <= "9":
-            return _inc_volname(volfile, i)
-        i -= 1
-    raise BadRarName("Cannot construct volume name: " + volfile)
-
-
-def _next_oldvol(volfile):
-    """Old-style next volume
-    """
-    # rar -> r00
-    if volfile[-4:].lower() == ".rar":
-        return volfile[:-2] + "00"
-    return _inc_volname(volfile, len(volfile) - 1)
-
-
-def _inc_volname(volfile, i):
-    """increase digits with carry, otherwise just increment char
-    """
-    fn = list(volfile)
-    while i >= 0:
-        if fn[i] != "9":
-            fn[i] = chr(ord(fn[i]) + 1)
-            break
-        fn[i] = "0"
-        i -= 1
-    return "".join(fn)
-
-
-def _parse_ext_time(h, data, pos):
-    """Parse all RAR3 extended time fields
-    """
-    # flags and rest of data can be missing
-    flags = 0
-    if pos + 2 <= len(data):
-        flags = S_SHORT.unpack_from(data, pos)[0]
-        pos += 2
-
-    mtime, pos = _parse_xtime(flags >> 3 * 4, data, pos, h.mtime)
-    h.ctime, pos = _parse_xtime(flags >> 2 * 4, data, pos)
-    h.atime, pos = _parse_xtime(flags >> 1 * 4, data, pos)
-    h.arctime, pos = _parse_xtime(flags >> 0 * 4, data, pos)
-    if mtime:
-        h.mtime = mtime
-        h.date_time = mtime.timetuple()[:6]
-    return pos
-
-
-def _parse_xtime(flag, data, pos, basetime=None):
-    """Parse one RAR3 extended time field
-    """
-    res = None
-    if flag & 8:
-        if not basetime:
-            basetime, pos = load_dostime(data, pos)
-
-        # load second fractions of 100ns units
-        rem = 0
-        cnt = flag & 3
-        for _ in range(cnt):
-            b, pos = load_byte(data, pos)
-            rem = (b << 16) | (rem >> 8)
-
-        # dostime has room for 30 seconds only, correct if needed
-        if flag & 4 and basetime.second < 59:
-            basetime = basetime.replace(second=basetime.second + 1)
-
-        res = to_nsdatetime(basetime, rem * 100)
-    return res, pos
-
-
-def is_filelike(obj):
-    """Filename or file object?
-    """
-    if isinstance(obj, (bytes, str, Path)):
-        return False
-    res = True
-    for a in ("read", "tell", "seek"):
-        res = res and hasattr(obj, a)
-    if not res:
-        raise ValueError("Invalid object passed as file")
-    return True
-
-
-def rar3_s2k(pwd, salt):
-    """String-to-key hash for RAR3.
-    """
-    if not isinstance(pwd, str):
-        pwd = pwd.decode("utf8")
-    seed = bytearray(pwd.encode("utf-16le") + salt)
-    h = Rar3Sha1(rarbug=True)
-    iv = b""
-    for i in range(16):
-        for j in range(0x4000):
-            cnt = S_LONG.pack(i * 0x4000 + j)
-            h.update(seed)
-            h.update(cnt[:3])
-            if j == 0:
-                iv += h.digest()[19:20]
-    key_be = h.digest()[:16]
-    key_le = pack("<LLLL", *unpack(">LLLL", key_be))
-    return key_le, iv
-
-
-def rar3_decompress(vers, meth, data, declen=0, flags=0, crc=0, pwd=None, salt=None):
-    """Decompress blob of compressed data.
-
-    Used for data with non-standard header - eg. comments.
-    """
-    # already uncompressed?
-    if meth == RAR_M0 and (flags & RAR_FILE_PASSWORD) == 0:
-        return data
-
-    # take only necessary flags
-    flags = flags & (RAR_FILE_PASSWORD | RAR_FILE_SALT | RAR_FILE_DICTMASK)
-    flags |= RAR_LONG_BLOCK
-
-    # file header
-    fname = b"data"
-    date = ((2010 - 1980) << 25) + (12 << 21) + (31 << 16)
-    mode = 0x20
-    fhdr = S_FILE_HDR.pack(len(data), declen, RAR_OS_MSDOS, crc,
-                           date, vers, meth, len(fname), mode)
-    fhdr += fname
-    if salt:
-        fhdr += salt
-
-    # full header
-    hlen = S_BLK_HDR.size + len(fhdr)
-    hdr = S_BLK_HDR.pack(0, RAR_BLOCK_FILE, flags, hlen) + fhdr
-    hcrc = crc32(hdr[2:]) & 0xFFFF
-    hdr = S_BLK_HDR.pack(hcrc, RAR_BLOCK_FILE, flags, hlen) + fhdr
-
-    # archive main header
-    mh = S_BLK_HDR.pack(0x90CF, RAR_BLOCK_MAIN, 0, 13) + b"\0" * (2 + 4)
-
-    # decompress via temp rar
-    setup = tool_setup()
-    tmpfd, tmpname = mkstemp(suffix=".rar", dir=HACK_TMP_DIR)
-    tmpf = os.fdopen(tmpfd, "wb")
-    try:
-        tmpf.write(RAR_ID + mh + hdr + data)
-        tmpf.close()
-
-        curpwd = (flags & RAR_FILE_PASSWORD) and pwd or None
-        cmd = setup.open_cmdline(curpwd, tmpname)
-        p = custom_popen(cmd)
-        return p.communicate()[0]
-    finally:
-        tmpf.close()
-        os.unlink(tmpname)
-
-
-def sanitize_filename(fname, pathsep, is_win32):
-    """Simulate unrar sanitization.
-    """
-    if is_win32:
-        if len(fname) > 1 and fname[1] == ":":
-            fname = fname[2:]
-        rc = RC_BAD_CHARS_WIN32
-    else:
-        rc = RC_BAD_CHARS_UNIX
-    if rc.search(fname):
-        fname = rc.sub("_", fname)
-
-    parts = []
-    for seg in fname.split("/"):
-        if seg in ("", ".", ".."):
-            continue
-        if is_win32 and seg[-1] in (" ", "."):
-            seg = seg[:-1] + "_"
-        parts.append(seg)
-    return pathsep.join(parts)
-
-
-def empty_read(src, size, blklen):
-    """Read and drop fixed amount of data.
-    """
-    while size > 0:
-        if size > blklen:
-            res = src.read(blklen)
-        else:
-            res = src.read(size)
-        if not res:
-            raise BadRarFile("cannot load data")
-        size -= len(res)
-
-
-def to_datetime(t):
-    """Convert 6-part time tuple into datetime object.
-    """
-    # extract values
-    year, mon, day, h, m, s = t
-
-    # assume the values are valid
-    try:
-        return datetime(year, mon, day, h, m, s)
-    except ValueError:
-        pass
-
-    # sanitize invalid values
-    mday = (0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
-    mon = max(1, min(mon, 12))
-    day = max(1, min(day, mday[mon]))
-    h = min(h, 23)
-    m = min(m, 59)
-    s = min(s, 59)
-    if mon == 2 and day == 29:
-        try:
-            return datetime(year, mon, day, h, m, s)
-        except ValueError:
-            day = 28
-    return datetime(year, mon, day, h, m, s)
-
-
-def parse_dos_time(stamp):
-    """Parse standard 32-bit DOS timestamp.
-    """
-    sec, stamp = stamp & 0x1F, stamp >> 5
-    mn, stamp = stamp & 0x3F, stamp >> 6
-    hr, stamp = stamp & 0x1F, stamp >> 5
-    day, stamp = stamp & 0x1F, stamp >> 5
-    mon, stamp = stamp & 0x0F, stamp >> 4
-    yr = (stamp & 0x7F) + 1980
-    return (yr, mon, day, hr, mn, sec * 2)
-
-
-# pylint: disable=arguments-differ,signature-differs
-class nsdatetime(datetime):
-    """Datetime that carries nanoseconds.
-
-    Arithmetic not supported, will lose nanoseconds.
-
-    .. versionadded:: 4.0
-    """
-    __slots__ = ("nanosecond",)
-    nanosecond: int     #: Number of nanoseconds, 0 <= nanosecond < 999999999
-
-    def __new__(cls, year, month, day, hour=0, minute=0, second=0,
-                microsecond=0, tzinfo=None, *, fold=0, nanosecond=0):
-        usec, mod = divmod(nanosecond, 1000) if nanosecond else (microsecond, 0)
-        if mod == 0:
-            return datetime(year, month, day, hour, minute, second, usec, tzinfo, fold=fold)
-        self = super().__new__(cls, year, month, day, hour, minute, second, usec, tzinfo, fold=fold)
-        self.nanosecond = nanosecond
-        return self
-
-    def isoformat(self, sep="T", timespec="auto"):
-        """Formats with nanosecond precision by default.
-        """
-        if timespec == "auto":
-            pre, post = super().isoformat(sep, "microseconds").split(".", 1)
-            return f"{pre}.{self.nanosecond:09d}{post[6:]}"
-        return super().isoformat(sep, timespec)
-
-    def astimezone(self, tz=None):
-        """Convert to new timezone.
-        """
-        tmp = super().astimezone(tz)
-        return self.__class__(tmp.year, tmp.month, tmp.day, tmp.hour, tmp.minute, tmp.second,
-                              nanosecond=self.nanosecond, tzinfo=tmp.tzinfo, fold=tmp.fold)
-
-    def replace(self, year=None, month=None, day=None, hour=None, minute=None, second=None,
-                microsecond=None, tzinfo=None, *, fold=None, nanosecond=None):
-        """Return new timestamp with specified fields replaced.
-        """
-        return self.__class__(
-            self.year if year is None else year,
-            self.month if month is None else month,
-            self.day if day is None else day,
-            self.hour if hour is None else hour,
-            self.minute if minute is None else minute,
-            self.second if second is None else second,
-            nanosecond=((self.nanosecond if microsecond is None else microsecond * 1000)
-                        if nanosecond is None else nanosecond),
-            tzinfo=self.tzinfo if tzinfo is None else tzinfo,
-            fold=self.fold if fold is None else fold)
-
-    def __hash__(self):
-        return hash((super().__hash__(), self.nanosecond)) if self.nanosecond else super().__hash__()
-
-    def __eq__(self, other):
-        return super().__eq__(other) and self.nanosecond == (
-            other.nanosecond if isinstance(other, nsdatetime) else other.microsecond * 1000)
-
-    def __gt__(self, other):
-        return super().__gt__(other) or (super().__eq__(other) and self.nanosecond > (
-            other.nanosecond if isinstance(other, nsdatetime) else other.microsecond * 1000))
-
-    def __lt__(self, other):
-        return not (self > other or self == other)
-
-    def __ge__(self, other):
-        return not self < other
-
-    def __le__(self, other):
-        return not self > other
-
-    def __ne__(self, other):
-        return not self == other
-
-
-def to_nsdatetime(dt, nsec):
-    """Apply nanoseconds to datetime.
-    """
-    if not nsec:
-        return dt
-    return nsdatetime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second,
-                      tzinfo=dt.tzinfo, fold=dt.fold, nanosecond=nsec)
-
-
-def to_nsecs(dt):
-    """Convert datatime instance to nanoseconds.
-    """
-    secs = int(dt.timestamp())
-    nsecs = dt.nanosecond if isinstance(dt, nsdatetime) else dt.microsecond * 1000
-    return secs * 1000000000 + nsecs
-
-
-def custom_popen(cmd):
-    """Disconnect cmd from parent fds, read only from stdout.
-    """
-    creationflags = 0x08000000 if WIN32 else 0  # CREATE_NO_WINDOW
-    try:
-        p = Popen(cmd, bufsize=0, stdout=PIPE, stderr=STDOUT, stdin=DEVNULL,
-                  creationflags=creationflags)
-    except OSError as ex:
-        if ex.errno == errno.ENOENT:
-            raise RarCannotExec("Unrar not installed?")
-        if ex.errno == errno.EACCES or ex.errno == errno.EPERM:
-            raise RarCannotExec("Cannot execute unrar")
-        raise
-    return p
-
-
-def check_returncode(code, out, errmap):
-    """Raise exception according to unrar exit code.
-    """
-    if code == 0:
-        return
-
-    if code > 0 and code < len(errmap):
-        exc = errmap[code]
-    elif code == 255:
-        exc = RarUserBreak
-    elif code < 0:
-        exc = RarSignalExit
-    else:
-        exc = RarUnknownError
-
-    # format message
-    if out:
-        msg = "%s [%d]: %s" % (exc.__doc__, code, out)
-    else:
-        msg = "%s [%d]" % (exc.__doc__, code)
-
-    raise exc(msg)
-
-
-def membuf_tempfile(memfile):
-    """Write in-memory file object to real file.
-    """
-    memfile.seek(0, 0)
-
-    tmpfd, tmpname = mkstemp(suffix=".rar", dir=HACK_TMP_DIR)
-    tmpf = os.fdopen(tmpfd, "wb")
-
-    try:
-        shutil.copyfileobj(memfile, tmpf, BSIZE)
-        tmpf.close()
-    except BaseException:
-        tmpf.close()
-        os.unlink(tmpname)
-        raise
-    return tmpname
-
-
-#
-# Find working command-line tool
-#
-
-class ToolSetup:
-    def __init__(self, setup):
-        self.setup = setup
-
-    def check(self):
-        cmdline = self.get_cmdline("check_cmd", None)
-        try:
-            p = custom_popen(cmdline)
-            out, _ = p.communicate()
-            return p.returncode == 0
-        except RarCannotExec:
-            return False
-
-    def open_cmdline(self, pwd, rarfn, filefn=None):
-        cmdline = self.get_cmdline("open_cmd", pwd)
-        cmdline.append(rarfn)
-        if filefn:
-            self.add_file_arg(cmdline, filefn)
-        return cmdline
-
-    def get_errmap(self):
-        return self.setup["errmap"]
-
-    def get_cmdline(self, key, pwd, nodash=False):
-        cmdline = list(self.setup[key])
-        cmdline[0] = globals()[cmdline[0]]
-        self.add_password_arg(cmdline, pwd)
-        if not nodash:
-            cmdline.append("--")
-        return cmdline
-
-    def add_file_arg(self, cmdline, filename):
-        cmdline.append(filename)
-
-    def add_password_arg(self, cmdline, pwd):
-        """Append password switch to commandline.
-        """
-        if pwd is not None:
-            if not isinstance(pwd, str):
-                pwd = pwd.decode("utf8")
-            args = self.setup["password"]
-            if isinstance(args, str):
-                cmdline.append(args + pwd)
-            else:
-                cmdline.extend(args)
-                cmdline.append(pwd)
-        else:
-            cmdline.extend(self.setup["no_password"])
-
-
-UNRAR_CONFIG = {
-    "open_cmd": ("UNRAR_TOOL", "p", "-inul"),
-    "check_cmd": ("UNRAR_TOOL", "-inul"),
-    "password": "-p",
-    "no_password": ("-p-",),
-    # map return code to exception class, codes from rar.txt
-    "errmap": [None,
-               RarWarning, RarFatalError, RarCRCError, RarLockedArchiveError,    # 1..4
-               RarWriteError, RarOpenError, RarUserError, RarMemoryError,        # 5..8
-               RarCreateError, RarNoFilesError, RarWrongPassword]                # 9..11
-}
-
-# Problems with unar RAR backend:
-# - Does not support RAR2 locked files [fails to read]
-# - Does not support RAR5 Blake2sp hash [reading works]
-UNAR_CONFIG = {
-    "open_cmd": ("UNAR_TOOL", "-q", "-o", "-"),
-    "check_cmd": ("UNAR_TOOL", "-version"),
-    "password": ("-p",),
-    "no_password": ("-p", ""),
-    "errmap": [None],
-}
-
-# Problems with libarchive RAR backend:
-# - Does not support solid archives.
-# - Does not support password-protected archives.
-# - Does not support RARVM-based compression filters.
-BSDTAR_CONFIG = {
-    "open_cmd": ("BSDTAR_TOOL", "-x", "--to-stdout", "-f"),
-    "check_cmd": ("BSDTAR_TOOL", "--version"),
-    "password": None,
-    "no_password": (),
-    "errmap": [None],
-}
-
-CURRENT_SETUP = None
-
-
-def tool_setup(unrar=True, unar=True, bsdtar=True, force=False):
-    """Pick a tool, return cached ToolSetup.
-    """
-    global CURRENT_SETUP
-    if force:
-        CURRENT_SETUP = None
-    if CURRENT_SETUP is not None:
-        return CURRENT_SETUP
-    lst = []
-    if unrar:
-        lst.append(UNRAR_CONFIG)
-    if unar:
-        lst.append(UNAR_CONFIG)
-    if bsdtar:
-        lst.append(BSDTAR_CONFIG)
-
-    for conf in lst:
-        setup = ToolSetup(conf)
-        if setup.check():
-            CURRENT_SETUP = setup
-            break
-    if CURRENT_SETUP is None:
-        raise RarCannotExec("Cannot find working tool")
-    return CURRENT_SETUP
-
-
-def main(args):
-    """Minimal command-line interface for rarfile module.
-    """
-    import argparse
-    p = argparse.ArgumentParser(description=main.__doc__)
-    g = p.add_mutually_exclusive_group(required=True)
-    g.add_argument("-l", "--list", metavar="<rarfile>",
-                   help="Show archive listing")
-    g.add_argument("-e", "--extract", nargs=2,
-                   metavar=("<rarfile>", "<output_dir>"),
-                   help="Extract archive into target dir")
-    g.add_argument("-t", "--test", metavar="<rarfile>",
-                   help="Test if a archive is valid")
-    cmd = p.parse_args(args)
-
-    if cmd.list:
-        with RarFile(cmd.list) as rf:
-            rf.printdir()
-    elif cmd.test:
-        with RarFile(cmd.test) as rf:
-            rf.testrar()
-    elif cmd.extract:
-        with RarFile(cmd.extract[0]) as rf:
-            rf.extractall(cmd.extract[1])
-
-
-if __name__ == "__main__":
-    main(sys.argv[1:])
-
+# rarfile.py
+#
+# Copyright (c) 2005-2020  Marko Kreen <markokr@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+"""RAR archive reader.
+
+This is Python module for Rar archive reading.  The interface
+is made as :mod:`zipfile`-like as possible.
+
+Basic logic:
+ - Parse archive structure with Python.
+ - Extract non-compressed files with Python
+ - Extract compressed files with unrar.
+ - Optionally write compressed data to temp file to speed up unrar,
+   otherwise it needs to scan whole archive on each execution.
+
+Example::
+
+    import rarfile
+
+    rf = rarfile.RarFile("myarchive.rar")
+    for f in rf.infolist():
+        print(f.filename, f.file_size)
+        if f.filename == "README":
+            print(rf.read(f))
+
+Archive files can also be accessed via file-like object returned
+by :meth:`RarFile.open`::
+
+    import rarfile
+
+    with rarfile.RarFile("archive.rar") as rf:
+        with rf.open("README") as f:
+            for ln in f:
+                print(ln.strip())
+
+For decompression to work, either ``unrar`` or ``unar`` tool must be in PATH.
+"""
+
+import errno
+import io
+import os
+import re
+import shutil
+import struct
+import sys
+import warnings
+from binascii import crc32, hexlify
+from datetime import datetime, timezone
+from hashlib import blake2s, pbkdf2_hmac, sha1
+from pathlib import Path
+from struct import Struct, pack, unpack
+from subprocess import DEVNULL, PIPE, STDOUT, Popen
+from tempfile import mkstemp
+
+# only needed for encrypted headers
+try:
+    try:
+        from cryptography.hazmat.backends import default_backend
+        from cryptography.hazmat.primitives.ciphers import (
+            Cipher, algorithms, modes,
+        )
+        _have_crypto = 1
+    except ImportError:
+        from Crypto.Cipher import AES
+        _have_crypto = 2
+except ImportError:
+    _have_crypto = 0
+
+
+class AES_CBC_Decrypt:
+    """Decrypt API"""
+    def __init__(self, key, iv):
+        if _have_crypto == 2:
+            self.decrypt = AES.new(key, AES.MODE_CBC, iv).decrypt
+        else:
+            ciph = Cipher(algorithms.AES(key), modes.CBC(iv), default_backend())
+            self.decrypt = ciph.decryptor().update
+
+
+__version__ = "4.0"
+
+# export only interesting items
+__all__ = ["is_rarfile", "is_rarfile_sfx", "RarInfo", "RarFile", "RarExtFile"]
+
+##
+## Module configuration.  Can be tuned after importing.
+##
+
+#: executable for unrar tool
+# by axiner
+# UNRAR_TOOL = "unrar"
+UNRAR_TOOL = Path(__file__).absolute().parent.joinpath("UnRAR.exe").as_posix()
+
+#: executable for unar tool
+UNAR_TOOL = "unar"
+
+#: executable for bsdtar tool
+BSDTAR_TOOL = "bsdtar"
+
+#: default fallback charset
+DEFAULT_CHARSET = "windows-1252"
+
+#: list of encodings to try, with fallback to DEFAULT_CHARSET if none succeed
+TRY_ENCODINGS = ("utf8", "utf-16le")
+
+#: whether to speed up decompression by using tmp archive
+USE_EXTRACT_HACK = 1
+
+#: limit the filesize for tmp archive usage
+HACK_SIZE_LIMIT = 20 * 1024 * 1024
+
+#: set specific directory for mkstemp() used by hack dir usage
+HACK_TMP_DIR = None
+
+#: Separator for path name components.  Always "/".
+PATH_SEP = "/"
+
+##
+## rar constants
+##
+
+# block types
+RAR_BLOCK_MARK = 0x72           # r
+RAR_BLOCK_MAIN = 0x73           # s
+RAR_BLOCK_FILE = 0x74           # t
+RAR_BLOCK_OLD_COMMENT = 0x75    # u
+RAR_BLOCK_OLD_EXTRA = 0x76      # v
+RAR_BLOCK_OLD_SUB = 0x77        # w
+RAR_BLOCK_OLD_RECOVERY = 0x78   # x
+RAR_BLOCK_OLD_AUTH = 0x79       # y
+RAR_BLOCK_SUB = 0x7a            # z
+RAR_BLOCK_ENDARC = 0x7b         # {
+
+# flags for RAR_BLOCK_MAIN
+RAR_MAIN_VOLUME = 0x0001
+RAR_MAIN_COMMENT = 0x0002
+RAR_MAIN_LOCK = 0x0004
+RAR_MAIN_SOLID = 0x0008
+RAR_MAIN_NEWNUMBERING = 0x0010
+RAR_MAIN_AUTH = 0x0020
+RAR_MAIN_RECOVERY = 0x0040
+RAR_MAIN_PASSWORD = 0x0080
+RAR_MAIN_FIRSTVOLUME = 0x0100
+RAR_MAIN_ENCRYPTVER = 0x0200
+
+# flags for RAR_BLOCK_FILE
+RAR_FILE_SPLIT_BEFORE = 0x0001
+RAR_FILE_SPLIT_AFTER = 0x0002
+RAR_FILE_PASSWORD = 0x0004
+RAR_FILE_COMMENT = 0x0008
+RAR_FILE_SOLID = 0x0010
+RAR_FILE_DICTMASK = 0x00e0
+RAR_FILE_DICT64 = 0x0000
+RAR_FILE_DICT128 = 0x0020
+RAR_FILE_DICT256 = 0x0040
+RAR_FILE_DICT512 = 0x0060
+RAR_FILE_DICT1024 = 0x0080
+RAR_FILE_DICT2048 = 0x00a0
+RAR_FILE_DICT4096 = 0x00c0
+RAR_FILE_DIRECTORY = 0x00e0
+RAR_FILE_LARGE = 0x0100
+RAR_FILE_UNICODE = 0x0200
+RAR_FILE_SALT = 0x0400
+RAR_FILE_VERSION = 0x0800
+RAR_FILE_EXTTIME = 0x1000
+RAR_FILE_EXTFLAGS = 0x2000
+
+# flags for RAR_BLOCK_ENDARC
+RAR_ENDARC_NEXT_VOLUME = 0x0001
+RAR_ENDARC_DATACRC = 0x0002
+RAR_ENDARC_REVSPACE = 0x0004
+RAR_ENDARC_VOLNR = 0x0008
+
+# flags common to all blocks
+RAR_SKIP_IF_UNKNOWN = 0x4000
+RAR_LONG_BLOCK = 0x8000
+
+# Host OS types
+RAR_OS_MSDOS = 0    #: MSDOS (only in RAR3)
+RAR_OS_OS2 = 1      #: OS2 (only in RAR3)
+RAR_OS_WIN32 = 2    #: Windows
+RAR_OS_UNIX = 3     #: UNIX
+RAR_OS_MACOS = 4    #: MacOS (only in RAR3)
+RAR_OS_BEOS = 5     #: BeOS (only in RAR3)
+
+# Compression methods - "0".."5"
+RAR_M0 = 0x30   #: No compression.
+RAR_M1 = 0x31   #: Compression level `-m1` - Fastest compression.
+RAR_M2 = 0x32   #: Compression level `-m2`.
+RAR_M3 = 0x33   #: Compression level `-m3`.
+RAR_M4 = 0x34   #: Compression level `-m4`.
+RAR_M5 = 0x35   #: Compression level `-m5` - Maximum compression.
+
+#
+# RAR5 constants
+#
+
+RAR5_BLOCK_MAIN = 1
+RAR5_BLOCK_FILE = 2
+RAR5_BLOCK_SERVICE = 3
+RAR5_BLOCK_ENCRYPTION = 4
+RAR5_BLOCK_ENDARC = 5
+
+RAR5_BLOCK_FLAG_EXTRA_DATA = 0x01
+RAR5_BLOCK_FLAG_DATA_AREA = 0x02
+RAR5_BLOCK_FLAG_SKIP_IF_UNKNOWN = 0x04
+RAR5_BLOCK_FLAG_SPLIT_BEFORE = 0x08
+RAR5_BLOCK_FLAG_SPLIT_AFTER = 0x10
+RAR5_BLOCK_FLAG_DEPENDS_PREV = 0x20
+RAR5_BLOCK_FLAG_KEEP_WITH_PARENT = 0x40
+
+RAR5_MAIN_FLAG_ISVOL = 0x01
+RAR5_MAIN_FLAG_HAS_VOLNR = 0x02
+RAR5_MAIN_FLAG_SOLID = 0x04
+RAR5_MAIN_FLAG_RECOVERY = 0x08
+RAR5_MAIN_FLAG_LOCKED = 0x10
+
+RAR5_FILE_FLAG_ISDIR = 0x01
+RAR5_FILE_FLAG_HAS_MTIME = 0x02
+RAR5_FILE_FLAG_HAS_CRC32 = 0x04
+RAR5_FILE_FLAG_UNKNOWN_SIZE = 0x08
+
+RAR5_COMPR_SOLID = 0x40
+
+RAR5_ENC_FLAG_HAS_CHECKVAL = 0x01
+
+RAR5_ENDARC_FLAG_NEXT_VOL = 0x01
+
+RAR5_XFILE_ENCRYPTION = 1
+RAR5_XFILE_HASH = 2
+RAR5_XFILE_TIME = 3
+RAR5_XFILE_VERSION = 4
+RAR5_XFILE_REDIR = 5
+RAR5_XFILE_OWNER = 6
+RAR5_XFILE_SERVICE = 7
+
+RAR5_XTIME_UNIXTIME = 0x01
+RAR5_XTIME_HAS_MTIME = 0x02
+RAR5_XTIME_HAS_CTIME = 0x04
+RAR5_XTIME_HAS_ATIME = 0x08
+RAR5_XTIME_UNIXTIME_NS = 0x10
+
+RAR5_XENC_CIPHER_AES256 = 0
+
+RAR5_XENC_CHECKVAL = 0x01
+RAR5_XENC_TWEAKED = 0x02
+
+RAR5_XHASH_BLAKE2SP = 0
+
+RAR5_XREDIR_UNIX_SYMLINK = 1
+RAR5_XREDIR_WINDOWS_SYMLINK = 2
+RAR5_XREDIR_WINDOWS_JUNCTION = 3
+RAR5_XREDIR_HARD_LINK = 4
+RAR5_XREDIR_FILE_COPY = 5
+
+RAR5_XREDIR_ISDIR = 0x01
+
+RAR5_XOWNER_UNAME = 0x01
+RAR5_XOWNER_GNAME = 0x02
+RAR5_XOWNER_UID = 0x04
+RAR5_XOWNER_GID = 0x08
+
+RAR5_OS_WINDOWS = 0
+RAR5_OS_UNIX = 1
+
+DOS_MODE_ARCHIVE = 0x20
+DOS_MODE_DIR = 0x10
+DOS_MODE_SYSTEM = 0x04
+DOS_MODE_HIDDEN = 0x02
+DOS_MODE_READONLY = 0x01
+
+##
+## internal constants
+##
+
+RAR_ID = b"Rar!\x1a\x07\x00"
+RAR5_ID = b"Rar!\x1a\x07\x01\x00"
+
+WIN32 = sys.platform == "win32"
+BSIZE = 512 * 1024 if WIN32 else 64 * 1024
+
+SFX_MAX_SIZE = 2 * 1024 * 1024
+RAR_V3 = 3
+RAR_V5 = 5
+
+_BAD_CHARS = r"""\x00-\x1F<>|"?*"""
+RC_BAD_CHARS_UNIX = re.compile(r"[%s]" % _BAD_CHARS)
+RC_BAD_CHARS_WIN32 = re.compile(r"[%s:^\\]" % _BAD_CHARS)
+
+
+def _get_rar_version(xfile):
+    """Check quickly whether file is rar archive.
+    """
+    with XFile(xfile) as fd:
+        buf = fd.read(len(RAR5_ID))
+    if buf.startswith(RAR_ID):
+        return RAR_V3
+    elif buf.startswith(RAR5_ID):
+        return RAR_V5
+    return 0
+
+
+def _find_sfx_header(xfile):
+    sig = RAR_ID[:-1]
+    buf = io.BytesIO()
+    steps = (64, SFX_MAX_SIZE)
+
+    with XFile(xfile) as fd:
+        for step in steps:
+            data = fd.read(step)
+            if not data:
+                break
+            buf.write(data)
+            curdata = buf.getvalue()
+            findpos = 0
+            while True:
+                pos = curdata.find(sig, findpos)
+                if pos < 0:
+                    break
+                if curdata[pos:pos + len(RAR_ID)] == RAR_ID:
+                    return RAR_V3, pos
+                if curdata[pos:pos + len(RAR5_ID)] == RAR5_ID:
+                    return RAR_V5, pos
+                findpos = pos + len(sig)
+    return 0, 0
+
+
+##
+## Public interface
+##
+
+def is_rarfile(xfile):
+    """Check quickly whether file is rar archive.
+    """
+    return _get_rar_version(xfile) > 0
+
+
+def is_rarfile_sfx(xfile):
+    """Check whether file is rar archive with support for SFX.
+
+    It will read 2M from file.
+    """
+    return _find_sfx_header(xfile)[0] > 0
+
+
+class Error(Exception):
+    """Base class for rarfile errors."""
+
+
+class BadRarFile(Error):
+    """Incorrect data in archive."""
+
+
+class NotRarFile(Error):
+    """The file is not RAR archive."""
+
+
+class BadRarName(Error):
+    """Cannot guess multipart name components."""
+
+
+class NoRarEntry(Error):
+    """File not found in RAR"""
+
+
+class PasswordRequired(Error):
+    """File requires password"""
+
+
+class NeedFirstVolume(Error):
+    """Need to start from first volume.
+
+    Attributes:
+
+        current_volume
+            Volume number of current file or None if not known
+    """
+    def __init__(self, msg, volume):
+        super().__init__(msg)
+        self.current_volume = volume
+
+
+class NoCrypto(Error):
+    """Cannot parse encrypted headers - no crypto available."""
+
+
+class RarExecError(Error):
+    """Problem reported by unrar/rar."""
+
+
+class RarWarning(RarExecError):
+    """Non-fatal error"""
+
+
+class RarFatalError(RarExecError):
+    """Fatal error"""
+
+
+class RarCRCError(RarExecError):
+    """CRC error during unpacking"""
+
+
+class RarLockedArchiveError(RarExecError):
+    """Must not modify locked archive"""
+
+
+class RarWriteError(RarExecError):
+    """Write error"""
+
+
+class RarOpenError(RarExecError):
+    """Open error"""
+
+
+class RarUserError(RarExecError):
+    """User error"""
+
+
+class RarMemoryError(RarExecError):
+    """Memory error"""
+
+
+class RarCreateError(RarExecError):
+    """Create error"""
+
+
+class RarNoFilesError(RarExecError):
+    """No files that match pattern were found"""
+
+
+class RarUserBreak(RarExecError):
+    """User stop"""
+
+
+class RarWrongPassword(RarExecError):
+    """Incorrect password"""
+
+
+class RarUnknownError(RarExecError):
+    """Unknown exit code"""
+
+
+class RarSignalExit(RarExecError):
+    """Unrar exited with signal"""
+
+
+class RarCannotExec(RarExecError):
+    """Executable not found."""
+
+
+class UnsupportedWarning(UserWarning):
+    """Archive uses feature that are unsupported by rarfile.
+
+    .. versionadded:: 4.0
+    """
+
+
+class RarInfo:
+    r"""An entry in rar archive.
+
+    Timestamps as :class:`~datetime.datetime` are without timezone in RAR3,
+    with UTC timezone in RAR5 archives.
+
+    Attributes:
+
+        filename
+            File name with relative path.
+            Path separator is "/".  Always unicode string.
+
+        date_time
+            File modification timestamp.   As tuple of (year, month, day, hour, minute, second).
+            RAR5 allows archives where it is missing, it's None then.
+
+        comment
+            Optional file comment field.  Unicode string.  (RAR3-only)
+
+        file_size
+            Uncompressed size.
+
+        compress_size
+            Compressed size.
+
+        compress_type
+            Compression method: one of :data:`RAR_M0` .. :data:`RAR_M5` constants.
+
+        extract_version
+            Minimal Rar version needed for decompressing.  As (major*10 + minor),
+            so 2.9 is 29.
+
+            RAR3: 10, 20, 29
+
+            RAR5 does not have such field in archive, it's simply set to 50.
+
+        host_os
+            Host OS type, one of RAR_OS_* constants.
+
+            RAR3: :data:`RAR_OS_WIN32`, :data:`RAR_OS_UNIX`, :data:`RAR_OS_MSDOS`,
+            :data:`RAR_OS_OS2`, :data:`RAR_OS_BEOS`.
+
+            RAR5: :data:`RAR_OS_WIN32`, :data:`RAR_OS_UNIX`.
+
+        mode
+            File attributes. May be either dos-style or unix-style, depending on host_os.
+
+        mtime
+            File modification time.  Same value as :attr:`date_time`
+            but as :class:`~datetime.datetime` object with extended precision.
+
+        ctime
+            Optional time field: creation time.  As :class:`~datetime.datetime` object.
+
+        atime
+            Optional time field: last access time.  As :class:`~datetime.datetime` object.
+
+        arctime
+            Optional time field: archival time.  As :class:`~datetime.datetime` object.
+            (RAR3-only)
+
+        CRC
+            CRC-32 of uncompressed file, unsigned int.
+
+            RAR5: may be None.
+
+        blake2sp_hash
+            Blake2SP hash over decompressed data.  (RAR5-only)
+
+        volume
+            Volume nr, starting from 0.
+
+        volume_file
+            Volume file name, where file starts.
+
+        file_redir
+            If not None, file is link of some sort.  Contains tuple of (type, flags, target).
+            (RAR5-only)
+
+            Type is one of constants:
+
+                :data:`RAR5_XREDIR_UNIX_SYMLINK`
+                    Unix symlink.
+                :data:`RAR5_XREDIR_WINDOWS_SYMLINK`
+                    Windows symlink.
+                :data:`RAR5_XREDIR_WINDOWS_JUNCTION`
+                    Windows junction.
+                :data:`RAR5_XREDIR_HARD_LINK`
+                    Hard link to target.
+                :data:`RAR5_XREDIR_FILE_COPY`
+                    Current file is copy of another archive entry.
+
+            Flags may contain bits:
+
+                :data:`RAR5_XREDIR_ISDIR`
+                    Symlink points to directory.
+    """
+
+    # zipfile-compatible fields
+    filename = None
+    file_size = None
+    compress_size = None
+    date_time = None
+    CRC = None
+    volume = None
+    orig_filename = None
+
+    # optional extended time fields, datetime() objects.
+    mtime = None
+    ctime = None
+    atime = None
+
+    extract_version = None
+    mode = None
+    host_os = None
+    compress_type = None
+
+    # rar3-only fields
+    comment = None
+    arctime = None
+
+    # rar5-only fields
+    blake2sp_hash = None
+    file_redir = None
+
+    # internal fields
+    flags = 0
+    type = None
+
+    # zipfile compat
+    def is_dir(self):
+        """Returns True if entry is a directory.
+
+        .. versionadded:: 4.0
+        """
+        return False
+
+    def is_symlink(self):
+        """Returns True if entry is a symlink.
+
+        .. versionadded:: 4.0
+        """
+        return False
+
+    def is_file(self):
+        """Returns True if entry is a normal file.
+
+        .. versionadded:: 4.0
+        """
+        return False
+
+    def needs_password(self):
+        """Returns True if data is stored password-protected.
+        """
+        if self.type == RAR_BLOCK_FILE:
+            return (self.flags & RAR_FILE_PASSWORD) > 0
+        return False
+
+    def isdir(self):
+        """Returns True if entry is a directory.
+
+        .. deprecated:: 4.0
+        """
+        return self.is_dir()
+
+
+class RarFile:
+    """Parse RAR structure, provide access to files in archive.
+    """
+
+    #: File name, if available.  Unicode string or None.
+    filename = None
+
+    #: Archive comment.  Unicode string or None.
+    comment = None
+
+    def __init__(self, file, mode="r", charset=None, info_callback=None,
+                 crc_check=True, errors="stop"):
+        """Open and parse a RAR archive.
+
+        Parameters:
+
+            file
+                archive file name or file-like object.
+            mode
+                only "r" is supported.
+            charset
+                fallback charset to use, if filenames are not already Unicode-enabled.
+            info_callback
+                debug callback, gets to see all archive entries.
+            crc_check
+                set to False to disable CRC checks
+            errors
+                Either "stop" to quietly stop parsing on errors,
+                or "strict" to raise errors.  Default is "stop".
+        """
+        if is_filelike(file):
+            self.filename = getattr(file, "name", None)
+        else:
+            if isinstance(file, Path):
+                file = str(file)
+            self.filename = file
+        self._rarfile = file
+
+        self._charset = charset or DEFAULT_CHARSET
+        self._info_callback = info_callback
+        self._crc_check = crc_check
+        self._password = None
+        self._file_parser = None
+
+        if errors == "stop":
+            self._strict = False
+        elif errors == "strict":
+            self._strict = True
+        else:
+            raise ValueError("Invalid value for errors= parameter.")
+
+        if mode != "r":
+            raise NotImplementedError("RarFile supports only mode=r")
+
+        self._parse()
+
+    def __enter__(self):
+        """Open context."""
+        return self
+
+    def __exit__(self, typ, value, traceback):
+        """Exit context."""
+        self.close()
+
+    def __iter__(self):
+        """Iterate over members."""
+        return iter(self.infolist())
+
+    def setpassword(self, pwd):
+        """Sets the password to use when extracting.
+        """
+        self._password = pwd
+        if self._file_parser:
+            if self._file_parser.has_header_encryption():
+                self._file_parser = None
+        if not self._file_parser:
+            self._parse()
+        else:
+            self._file_parser.setpassword(self._password)
+
+    def needs_password(self):
+        """Returns True if any archive entries require password for extraction.
+        """
+        return self._file_parser.needs_password()
+
+    def namelist(self):
+        """Return list of filenames in archive.
+        """
+        return [f.filename for f in self.infolist()]
+
+    def infolist(self):
+        """Return RarInfo objects for all files/directories in archive.
+        """
+        return self._file_parser.infolist()
+
+    def volumelist(self):
+        """Returns filenames of archive volumes.
+
+        In case of single-volume archive, the list contains
+        just the name of main archive file.
+        """
+        return self._file_parser.volumelist()
+
+    def getinfo(self, name):
+        """Return RarInfo for file.
+        """
+        return self._file_parser.getinfo(name)
+
+    def open(self, name, mode="r", pwd=None):
+        """Returns file-like object (:class:`RarExtFile`) from where the data can be read.
+
+        The object implements :class:`io.RawIOBase` interface, so it can
+        be further wrapped with :class:`io.BufferedReader`
+        and :class:`io.TextIOWrapper`.
+
+        On older Python where io module is not available, it implements
+        only .read(), .seek(), .tell() and .close() methods.
+
+        The object is seekable, although the seeking is fast only on
+        uncompressed files, on compressed files the seeking is implemented
+        by reading ahead and/or restarting the decompression.
+
+        Parameters:
+
+            name
+                file name or RarInfo instance.
+            mode
+                must be "r"
+            pwd
+                password to use for extracting.
+        """
+
+        if mode != "r":
+            raise NotImplementedError("RarFile.open() supports only mode=r")
+
+        # entry lookup
+        inf = self.getinfo(name)
+        if inf.is_dir():
+            raise io.UnsupportedOperation("Directory does not have any data: " + inf.filename)
+
+        # check password
+        if inf.needs_password():
+            pwd = pwd or self._password
+            if pwd is None:
+                raise PasswordRequired("File %s requires password" % inf.filename)
+        else:
+            pwd = None
+
+        return self._file_parser.open(inf, pwd)
+
+    def read(self, name, pwd=None):
+        """Return uncompressed data for archive entry.
+
+        For longer files using :meth:`~RarFile.open` may be better idea.
+
+        Parameters:
+
+            name
+                filename or RarInfo instance
+            pwd
+                password to use for extracting.
+        """
+
+        with self.open(name, "r", pwd) as f:
+            return f.read()
+
+    def close(self):
+        """Release open resources."""
+        pass
+
+    def printdir(self, file=None):
+        """Print archive file list to stdout or given file.
+        """
+        if file is None:
+            file = sys.stdout
+        for f in self.infolist():
+            print(f.filename, file=file)
+
+    def extract(self, member, path=None, pwd=None):
+        """Extract single file into current directory.
+
+        Parameters:
+
+            member
+                filename or :class:`RarInfo` instance
+            path
+                optional destination path
+            pwd
+                optional password to use
+        """
+        inf = self.getinfo(member)
+        return self._extract_one(inf, path, pwd, True)
+
+    def extractall(self, path=None, members=None, pwd=None):
+        """Extract all files into current directory.
+
+        Parameters:
+
+            path
+                optional destination path
+            members
+                optional filename or :class:`RarInfo` instance list to extract
+            pwd
+                optional password to use
+        """
+        if members is None:
+            members = self.namelist()
+
+        done = set()
+        dirs = []
+        for m in members:
+            inf = self.getinfo(m)
+            dst = self._extract_one(inf, path, pwd, not inf.is_dir())
+            if inf.is_dir():
+                if dst not in done:
+                    dirs.append((dst, inf))
+                    done.add(dst)
+        if dirs:
+            dirs.sort(reverse=True)
+            for dst, inf in dirs:
+                self._set_attrs(inf, dst)
+
+    def testrar(self, pwd=None):
+        """Read all files and test CRC.
+        """
+        for member in self.infolist():
+            if member.is_file():
+                with self.open(member, 'r', pwd) as f:
+                    empty_read(f, member.file_size, BSIZE)
+
+    def strerror(self):
+        """Return error string if parsing failed or None if no problems.
+        """
+        if not self._file_parser:
+            return "Not a RAR file"
+        return self._file_parser.strerror()
+
+    ##
+    ## private methods
+    ##
+
+    def _parse(self):
+        """Run parser for file type
+        """
+        ver, sfx_ofs = _find_sfx_header(self._rarfile)
+        if ver == RAR_V3:
+            p3 = RAR3Parser(self._rarfile, self._password, self._crc_check,
+                            self._charset, self._strict, self._info_callback,
+                            sfx_ofs)
+            self._file_parser = p3  # noqa
+        elif ver == RAR_V5:
+            p5 = RAR5Parser(self._rarfile, self._password, self._crc_check,
+                            self._charset, self._strict, self._info_callback,
+                            sfx_ofs)
+            self._file_parser = p5  # noqa
+        else:
+            raise NotRarFile("Not a RAR file")
+
+        self._file_parser.parse()
+        self.comment = self._file_parser.comment
+
+    def _extract_one(self, info, path, pwd, set_attrs):
+        fname = sanitize_filename(
+            info.filename, os.path.sep, WIN32
+        )
+
+        if path is None:
+            path = os.getcwd()
+        else:
+            path = os.fspath(path)
+        dstfn = os.path.join(path, fname)
+
+        dirname = os.path.dirname(dstfn)
+        if dirname and dirname != ".":
+            os.makedirs(dirname, exist_ok=True)
+
+        if info.is_file():
+            return self._make_file(info, dstfn, pwd, set_attrs)
+        if info.is_dir():
+            return self._make_dir(info, dstfn, pwd, set_attrs)
+        if info.is_symlink():
+            return self._make_symlink(info, dstfn, pwd, set_attrs)
+        return None
+
+    def _create_helper(self, name, flags, info):
+        return os.open(name, flags)
+
+    def _make_file(self, info, dstfn, pwd, set_attrs):
+        def helper(name, flags):
+            return self._create_helper(name, flags, info)
+        with self.open(info, "r", pwd) as src:
+            with open(dstfn, "wb", opener=helper) as dst:
+                shutil.copyfileobj(src, dst)
+        if set_attrs:
+            self._set_attrs(info, dstfn)
+        return dstfn
+
+    def _make_dir(self, info, dstfn, pwd, set_attrs):
+        os.makedirs(dstfn, exist_ok=True)
+        if set_attrs:
+            self._set_attrs(info, dstfn)
+        return dstfn
+
+    def _make_symlink(self, info, dstfn, pwd, set_attrs):
+        target_is_directory = False
+        if info.host_os == RAR_OS_UNIX:
+            link_name = self.read(info, pwd)
+            target_is_directory = (info.flags & RAR_FILE_DIRECTORY) == RAR_FILE_DIRECTORY
+        elif info.file_redir:
+            redir_type, redir_flags, link_name = info.file_redir
+            if redir_type == RAR5_XREDIR_WINDOWS_JUNCTION:
+                warnings.warn(f"Windows junction not supported - {info.filename}", UnsupportedWarning)
+                return None
+            target_is_directory = (redir_type & RAR5_XREDIR_ISDIR) > 0
+        else:
+            warnings.warn(f"Unsupported link type - {info.filename}", UnsupportedWarning)
+            return None
+
+        os.symlink(link_name, dstfn, target_is_directory=target_is_directory)
+        return dstfn
+
+    def _set_attrs(self, info, dstfn):
+        if info.host_os == RAR_OS_UNIX:
+            os.chmod(dstfn, info.mode & 0o777)
+        elif info.host_os in (RAR_OS_WIN32, RAR_OS_MSDOS):
+            # only keep R/O attr, except for dirs on win32
+            if info.mode & DOS_MODE_READONLY and (info.is_file() or not WIN32):
+                st = os.stat(dstfn)
+                new_mode = st.st_mode & ~0o222
+                os.chmod(dstfn, new_mode)
+
+        if info.mtime:
+            mtime_ns = to_nsecs(info.mtime)
+            atime_ns = to_nsecs(info.atime) if info.atime else mtime_ns
+            os.utime(dstfn, ns=(atime_ns, mtime_ns))
+
+
+#
+# File format parsing
+#
+
+class CommonParser:
+    """Shared parser parts."""
+    _main = None
+    _hdrenc_main = None
+    _needs_password = False
+    _fd = None
+    _expect_sig = None
+    _parse_error = None
+    _password = None
+    comment = None
+
+    def __init__(self, rarfile, password, crc_check, charset, strict, info_cb, sfx_offset):
+        self._rarfile = rarfile
+        self._password = password
+        self._crc_check = crc_check
+        self._charset = charset
+        self._strict = strict
+        self._info_callback = info_cb
+        self._info_list = []
+        self._info_map = {}
+        self._vol_list = []
+        self._sfx_offset = sfx_offset
+
+    def has_header_encryption(self):
+        """Returns True if headers are encrypted
+        """
+        if self._hdrenc_main:
+            return True
+        if self._main:
+            if self._main.flags & RAR_MAIN_PASSWORD:
+                return True
+        return False
+
+    def setpassword(self, pwd):
+        """Set cached password."""
+        self._password = pwd
+
+    def volumelist(self):
+        """Volume files"""
+        return self._vol_list
+
+    def needs_password(self):
+        """Is password required"""
+        return self._needs_password
+
+    def strerror(self):
+        """Last error"""
+        return self._parse_error
+
+    def infolist(self):
+        """List of RarInfo records.
+        """
+        return self._info_list
+
+    def getinfo(self, member):
+        """Return RarInfo for filename
+        """
+        if isinstance(member, RarInfo):
+            fname = member.filename
+        elif isinstance(member, Path):
+            fname = str(member)
+        else:
+            fname = member
+
+        if fname.endswith("/"):
+            fname = fname.rstrip("/")
+
+        try:
+            return self._info_map[fname]
+        except KeyError:
+            raise NoRarEntry("No such file: %s" % fname)
+
+    def parse(self):
+        """Process file."""
+        self._fd = None
+        try:
+            self._parse_real()
+        finally:
+            if self._fd:
+                self._fd.close()
+                self._fd = None
+
+    def _parse_real(self):
+        """Actually read file.
+        """
+        fd = XFile(self._rarfile)
+        self._fd = fd
+        fd.seek(self._sfx_offset, 0)
+        sig = fd.read(len(self._expect_sig))
+        if sig != self._expect_sig:
+            raise NotRarFile("Not a Rar archive")
+
+        volume = 0  # first vol (.rar) is 0
+        more_vols = False
+        endarc = False
+        volfile = self._rarfile
+        self._vol_list = [self._rarfile]
+        raise_need_first_vol = False
+        while True:
+            if endarc:
+                h = None    # don"t read past ENDARC
+            else:
+                h = self._parse_header(fd)
+            if not h:
+                if raise_need_first_vol:
+                    # did not find ENDARC with VOLNR
+                    raise NeedFirstVolume("Need to start from first volume", None)
+                if more_vols:
+                    volume += 1
+                    fd.close()
+                    try:
+                        volfile = self._next_volname(volfile)
+                        fd = XFile(volfile)
+                    except IOError:
+                        self._set_error("Cannot open next volume: %s", volfile)
+                        break
+                    self._fd = fd
+                    sig = fd.read(len(self._expect_sig))
+                    if sig != self._expect_sig:
+                        self._set_error("Invalid volume sig: %s", volfile)
+                        break
+                    more_vols = False
+                    endarc = False
+                    self._vol_list.append(volfile)
+                    self._main = None
+                    continue
+                break
+            h.volume = volume
+            h.volume_file = volfile
+
+            if h.type == RAR_BLOCK_MAIN and not self._main:
+                self._main = h
+                if volume == 0 and (h.flags & RAR_MAIN_NEWNUMBERING):
+                    # RAR 2.x does not set FIRSTVOLUME,
+                    # so check it only if NEWNUMBERING is used
+                    if (h.flags & RAR_MAIN_FIRSTVOLUME) == 0:
+                        if getattr(h, "main_volume_number", None) is not None:
+                            # rar5 may have more info
+                            raise NeedFirstVolume(
+                                "Need to start from first volume (current: %r)"
+                                % (h.main_volume_number,),
+                                h.main_volume_number
+                            )
+                        # delay raise until we have volnr from ENDARC
+                        raise_need_first_vol = True
+                if h.flags & RAR_MAIN_PASSWORD:
+                    self._needs_password = True
+                    if not self._password:
+                        break
+            elif h.type == RAR_BLOCK_ENDARC:
+                more_vols = (h.flags & RAR_ENDARC_NEXT_VOLUME) > 0
+                endarc = True
+                if raise_need_first_vol and (h.flags & RAR_ENDARC_VOLNR) > 0:
+                    raise NeedFirstVolume(
+                        "Need to start from first volume (current: %r)"
+                        % (h.endarc_volnr,),
+                        h.endarc_volnr
+                    )
+            elif h.type == RAR_BLOCK_FILE:
+                # RAR 2.x does not write RAR_BLOCK_ENDARC
+                if h.flags & RAR_FILE_SPLIT_AFTER:
+                    more_vols = True
+                # RAR 2.x does not set RAR_MAIN_FIRSTVOLUME
+                if volume == 0 and h.flags & RAR_FILE_SPLIT_BEFORE:
+                    raise_need_first_vol = True
+
+            if h.needs_password():
+                self._needs_password = True
+
+            # store it
+            self.process_entry(fd, h)
+
+            if self._info_callback:
+                self._info_callback(h)
+
+            # go to next header
+            if h.add_size > 0:
+                fd.seek(h.data_offset + h.add_size, 0)
+
+    def process_entry(self, fd, item):
+        """Examine item, add into lookup cache."""
+        raise NotImplementedError()
+
+    def _decrypt_header(self, fd):
+        raise NotImplementedError("_decrypt_header")
+
+    def _parse_block_header(self, fd):
+        raise NotImplementedError("_parse_block_header")
+
+    def _open_hack(self, inf, pwd):
+        raise NotImplementedError("_open_hack")
+
+    def _parse_header(self, fd):
+        """Read single header
+        """
+        try:
+            # handle encrypted headers
+            if (self._main and self._main.flags & RAR_MAIN_PASSWORD) or self._hdrenc_main:
+                if not self._password:
+                    return None
+                fd = self._decrypt_header(fd)
+
+            # now read actual header
+            return self._parse_block_header(fd)
+        except struct.error:
+            self._set_error("Broken header in RAR file")
+            return None
+
+    def _next_volname(self, volfile):
+        """Given current vol name, construct next one
+        """
+        if is_filelike(volfile):
+            raise IOError("Working on single FD")
+        if self._main.flags & RAR_MAIN_NEWNUMBERING:
+            return _next_newvol(volfile)
+        return _next_oldvol(volfile)
+
+    def _set_error(self, msg, *args):
+        if args:
+            msg = msg % args
+        self._parse_error = msg
+        if self._strict:
+            raise BadRarFile(msg)
+
+    def open(self, inf, pwd):
+        """Return stream object for file data."""
+
+        if inf.file_redir:
+            redir_type, redir_flags, redir_name = inf.file_redir
+            # cannot leave to unrar as it expects copied file to exist
+            if redir_type in (RAR5_XREDIR_FILE_COPY, RAR5_XREDIR_HARD_LINK):
+                inf = self.getinfo(redir_name)
+                if not inf:
+                    raise BadRarFile("cannot find copied file")
+            elif redir_type in (
+                RAR5_XREDIR_UNIX_SYMLINK, RAR5_XREDIR_WINDOWS_SYMLINK,
+                RAR5_XREDIR_WINDOWS_JUNCTION,
+            ):
+                return io.BytesIO(redir_name.encode("utf8"))
+        if inf.flags & RAR_FILE_SPLIT_BEFORE:
+            raise NeedFirstVolume("Partial file, please start from first volume: " + inf.filename, None)
+
+        # is temp write usable?
+        use_hack = 1
+        if not self._main:
+            use_hack = 0
+        elif self._main._must_disable_hack():
+            use_hack = 0
+        elif inf._must_disable_hack():
+            use_hack = 0
+        elif is_filelike(self._rarfile):
+            pass
+        elif inf.file_size > HACK_SIZE_LIMIT:
+            use_hack = 0
+        elif not USE_EXTRACT_HACK:
+            use_hack = 0
+
+        # now extract
+        if inf.compress_type == RAR_M0 and (inf.flags & RAR_FILE_PASSWORD) == 0 and inf.file_redir is None:
+            return self._open_clear(inf)
+        elif use_hack:
+            return self._open_hack(inf, pwd)
+        elif is_filelike(self._rarfile):
+            return self._open_unrar_membuf(self._rarfile, inf, pwd)
+        else:
+            return self._open_unrar(self._rarfile, inf, pwd)
+
+    def _open_clear(self, inf):
+        return DirectReader(self, inf)
+
+    def _open_hack_core(self, inf, pwd, prefix, suffix):
+
+        size = inf.compress_size + inf.header_size
+        rf = XFile(inf.volume_file, 0)
+        rf.seek(inf.header_offset)
+
+        tmpfd, tmpname = mkstemp(suffix=".rar", dir=HACK_TMP_DIR)
+        tmpf = os.fdopen(tmpfd, "wb")
+
+        try:
+            tmpf.write(prefix)
+            while size > 0:
+                if size > BSIZE:
+                    buf = rf.read(BSIZE)
+                else:
+                    buf = rf.read(size)
+                if not buf:
+                    raise BadRarFile("read failed: " + inf.filename)
+                tmpf.write(buf)
+                size -= len(buf)
+            tmpf.write(suffix)
+            tmpf.close()
+            rf.close()
+        except BaseException:
+            rf.close()
+            tmpf.close()
+            os.unlink(tmpname)
+            raise
+
+        return self._open_unrar(tmpname, inf, pwd, tmpname)
+
+    def _open_unrar_membuf(self, memfile, inf, pwd):
+        """Write in-memory archive to temp file, needed for solid archives.
+        """
+        tmpname = membuf_tempfile(memfile)
+        return self._open_unrar(tmpname, inf, pwd, tmpname, force_file=True)
+
+    def _open_unrar(self, rarfile, inf, pwd=None, tmpfile=None, force_file=False):
+        """Extract using unrar
+        """
+        setup = tool_setup()
+
+        # not giving filename avoids encoding related problems
+        fn = None
+        if not tmpfile or force_file:
+            fn = inf.filename
+
+        # read from unrar pipe
+        cmd = setup.open_cmdline(pwd, rarfile, fn)
+        return PipeReader(self, inf, cmd, tmpfile)
+
+
+#
+# RAR3 format
+#
+
+class Rar3Info(RarInfo):
+    """RAR3 specific fields."""
+    extract_version = 15
+    salt = None
+    add_size = 0
+    header_crc = None
+    header_size = None
+    header_offset = None
+    data_offset = None
+    _md_class = None
+    _md_expect = None
+    _name_size = None
+
+    # make sure some rar5 fields are always present
+    file_redir = None
+    blake2sp_hash = None
+
+    endarc_datacrc = None
+    endarc_volnr = None
+
+    def _must_disable_hack(self):
+        if self.type == RAR_BLOCK_FILE:
+            if self.flags & RAR_FILE_PASSWORD:
+                return True
+            elif self.flags & (RAR_FILE_SPLIT_BEFORE | RAR_FILE_SPLIT_AFTER):
+                return True
+        elif self.type == RAR_BLOCK_MAIN:
+            if self.flags & (RAR_MAIN_SOLID | RAR_MAIN_PASSWORD):
+                return True
+        return False
+
+    def is_dir(self):
+        """Returns True if entry is a directory."""
+        if self.type == RAR_BLOCK_FILE and not self.is_symlink():
+            return (self.flags & RAR_FILE_DIRECTORY) == RAR_FILE_DIRECTORY
+        return False
+
+    def is_symlink(self):
+        """Returns True if entry is a symlink."""
+        return (
+            self.type == RAR_BLOCK_FILE and
+            self.host_os == RAR_OS_UNIX and
+            self.mode & 0xF000 == 0xA000
+        )
+
+    def is_file(self):
+        """Returns True if entry is a normal file."""
+        return (
+            self.type == RAR_BLOCK_FILE and
+            not (self.is_dir() or self.is_symlink())
+        )
+
+
+class RAR3Parser(CommonParser):
+    """Parse RAR3 file format.
+    """
+    _expect_sig = RAR_ID
+    _last_aes_key = (None, None, None)   # (salt, key, iv)
+
+    def _decrypt_header(self, fd):
+        if not _have_crypto:
+            raise NoCrypto("Cannot parse encrypted headers - no crypto")
+        salt = fd.read(8)
+        if self._last_aes_key[0] == salt:
+            key, iv = self._last_aes_key[1:]
+        else:
+            key, iv = rar3_s2k(self._password, salt)
+            self._last_aes_key = (salt, key, iv)
+        return HeaderDecrypt(fd, key, iv)
+
+    def _parse_block_header(self, fd):
+        """Parse common block header
+        """
+        h = Rar3Info()
+        h.header_offset = fd.tell()
+
+        # read and parse base header
+        buf = fd.read(S_BLK_HDR.size)
+        if not buf:
+            return None
+        t = S_BLK_HDR.unpack_from(buf)
+        h.header_crc, h.type, h.flags, h.header_size = t
+
+        # read full header
+        if h.header_size > S_BLK_HDR.size:
+            hdata = buf + fd.read(h.header_size - S_BLK_HDR.size)
+        else:
+            hdata = buf
+        h.data_offset = fd.tell()
+
+        # unexpected EOF?
+        if len(hdata) != h.header_size:
+            self._set_error("Unexpected EOF when reading header")
+            return None
+
+        pos = S_BLK_HDR.size
+
+        # block has data assiciated with it?
+        if h.flags & RAR_LONG_BLOCK:
+            h.add_size, pos = load_le32(hdata, pos)
+        else:
+            h.add_size = 0
+
+        # parse interesting ones, decide header boundaries for crc
+        if h.type == RAR_BLOCK_MARK:
+            return h
+        elif h.type == RAR_BLOCK_MAIN:
+            pos += 6
+            if h.flags & RAR_MAIN_ENCRYPTVER:
+                pos += 1
+            crc_pos = pos
+            if h.flags & RAR_MAIN_COMMENT:
+                self._parse_subblocks(h, hdata, pos)
+        elif h.type == RAR_BLOCK_FILE:
+            pos = self._parse_file_header(h, hdata, pos - 4)
+            crc_pos = pos
+            if h.flags & RAR_FILE_COMMENT:
+                pos = self._parse_subblocks(h, hdata, pos)
+        elif h.type == RAR_BLOCK_SUB:
+            pos = self._parse_file_header(h, hdata, pos - 4)
+            crc_pos = h.header_size
+        elif h.type == RAR_BLOCK_OLD_AUTH:
+            pos += 8
+            crc_pos = pos
+        elif h.type == RAR_BLOCK_OLD_EXTRA:
+            pos += 7
+            crc_pos = pos
+        elif h.type == RAR_BLOCK_ENDARC:
+            if h.flags & RAR_ENDARC_DATACRC:
+                h.endarc_datacrc, pos = load_le32(hdata, pos)
+            if h.flags & RAR_ENDARC_VOLNR:
+                h.endarc_volnr = S_SHORT.unpack_from(hdata, pos)[0]
+                pos += 2
+            crc_pos = h.header_size
+        else:
+            crc_pos = h.header_size
+
+        # check crc
+        if h.type == RAR_BLOCK_OLD_SUB:
+            crcdat = hdata[2:] + fd.read(h.add_size)
+        else:
+            crcdat = hdata[2:crc_pos]
+
+        calc_crc = crc32(crcdat) & 0xFFFF
+
+        # return good header
+        if h.header_crc == calc_crc:
+            return h
+
+        # header parsing failed.
+        self._set_error("Header CRC error (%02x): exp=%x got=%x (xlen = %d)",
+                        h.type, h.header_crc, calc_crc, len(crcdat))
+
+        # instead panicing, send eof
+        return None
+
+    def _parse_file_header(self, h, hdata, pos):
+        """Read file-specific header
+        """
+        fld = S_FILE_HDR.unpack_from(hdata, pos)
+        pos += S_FILE_HDR.size
+
+        h.compress_size = fld[0]
+        h.file_size = fld[1]
+        h.host_os = fld[2]
+        h.CRC = fld[3]
+        h.date_time = parse_dos_time(fld[4])
+        h.mtime = to_datetime(h.date_time)
+        h.extract_version = fld[5]
+        h.compress_type = fld[6]
+        h._name_size = name_size = fld[7]
+        h.mode = fld[8]
+
+        h._md_class = CRC32Context
+        h._md_expect = h.CRC
+
+        if h.flags & RAR_FILE_LARGE:
+            h1, pos = load_le32(hdata, pos)
+            h2, pos = load_le32(hdata, pos)
+            h.compress_size |= h1 << 32
+            h.file_size |= h2 << 32
+            h.add_size = h.compress_size
+
+        name, pos = load_bytes(hdata, name_size, pos)
+        if h.flags & RAR_FILE_UNICODE and b"\0" in name:
+            # stored in custom encoding
+            nul = name.find(b"\0")
+            h.orig_filename = name[:nul]
+            u = UnicodeFilename(h.orig_filename, name[nul + 1:])
+            h.filename = u.decode()
+
+            # if parsing failed fall back to simple name
+            if u.failed:
+                h.filename = self._decode(h.orig_filename)
+        elif h.flags & RAR_FILE_UNICODE:
+            # stored in UTF8
+            h.orig_filename = name
+            h.filename = name.decode("utf8", "replace")
+        else:
+            # stored in random encoding
+            h.orig_filename = name
+            h.filename = self._decode(name)
+
+        # change separator, set dir suffix
+        h.filename = h.filename.replace("\\", "/").rstrip("/")
+        if h.is_dir():
+            h.filename = h.filename + "/"
+
+        if h.flags & RAR_FILE_SALT:
+            h.salt, pos = load_bytes(hdata, 8, pos)
+        else:
+            h.salt = None
+
+        # optional extended time stamps
+        if h.flags & RAR_FILE_EXTTIME:
+            pos = _parse_ext_time(h, hdata, pos)
+        else:
+            h.mtime = h.atime = h.ctime = h.arctime = None
+
+        return pos
+
+    def _parse_subblocks(self, h, hdata, pos):
+        """Find old-style comment subblock
+        """
+        while pos < len(hdata):
+            # ordinary block header
+            t = S_BLK_HDR.unpack_from(hdata, pos)
+            ___scrc, stype, sflags, slen = t
+            pos_next = pos + slen
+            pos += S_BLK_HDR.size
+
+            # corrupt header
+            if pos_next < pos:
+                break
+
+            # followed by block-specific header
+            if stype == RAR_BLOCK_OLD_COMMENT and pos + S_COMMENT_HDR.size <= pos_next:
+                declen, ver, meth, crc = S_COMMENT_HDR.unpack_from(hdata, pos)
+                pos += S_COMMENT_HDR.size
+                data = hdata[pos: pos_next]
+                cmt = rar3_decompress(ver, meth, data, declen, sflags,
+                                      crc, self._password)
+                if not self._crc_check or (crc32(cmt) & 0xFFFF == crc):
+                    h.comment = self._decode_comment(cmt)
+
+            pos = pos_next
+        return pos
+
+    def _read_comment_v3(self, inf, pwd=None):
+
+        # read data
+        with XFile(inf.volume_file) as rf:
+            rf.seek(inf.data_offset)
+            data = rf.read(inf.compress_size)
+
+        # decompress
+        cmt = rar3_decompress(inf.extract_version, inf.compress_type, data,
+                              inf.file_size, inf.flags, inf.CRC, pwd, inf.salt)
+
+        # check crc
+        if self._crc_check:
+            crc = crc32(cmt)
+            if crc != inf.CRC:
+                return None
+
+        return self._decode_comment(cmt)
+
+    def _decode(self, val):
+        for c in TRY_ENCODINGS:
+            try:
+                return val.decode(c)
+            except UnicodeError:
+                pass
+        return val.decode(self._charset, "replace")
+
+    def _decode_comment(self, val):
+        return self._decode(val)
+
+    def process_entry(self, fd, item):
+        if item.type == RAR_BLOCK_FILE:
+            # use only first part
+            if item.flags & RAR_FILE_VERSION:
+                pass    # skip old versions
+            elif (item.flags & RAR_FILE_SPLIT_BEFORE) == 0:
+                self._info_map[item.filename.rstrip("/")] = item
+                self._info_list.append(item)
+            elif len(self._info_list) > 0:
+                # final crc is in last block
+                old = self._info_list[-1]
+                old.CRC = item.CRC
+                old._md_expect = item._md_expect
+                old.compress_size += item.compress_size
+
+        # parse new-style comment
+        if item.type == RAR_BLOCK_SUB and item.filename == "CMT":
+            if item.flags & (RAR_FILE_SPLIT_BEFORE | RAR_FILE_SPLIT_AFTER):
+                pass
+            elif item.flags & RAR_FILE_SOLID:
+                # file comment
+                cmt = self._read_comment_v3(item, self._password)
+                if len(self._info_list) > 0:
+                    old = self._info_list[-1]
+                    old.comment = cmt
+            else:
+                # archive comment
+                cmt = self._read_comment_v3(item, self._password)
+                self.comment = cmt
+
+        if item.type == RAR_BLOCK_MAIN:
+            if item.flags & RAR_MAIN_COMMENT:
+                self.comment = item.comment
+            if item.flags & RAR_MAIN_PASSWORD:
+                self._needs_password = True
+
+    # put file compressed data into temporary .rar archive, and run
+    # unrar on that, thus avoiding unrar going over whole archive
+    def _open_hack(self, inf, pwd):
+        # create main header: crc, type, flags, size, res1, res2
+        prefix = RAR_ID + S_BLK_HDR.pack(0x90CF, 0x73, 0, 13) + b"\0" * (2 + 4)
+        return self._open_hack_core(inf, pwd, prefix, b"")
+
+
+#
+# RAR5 format
+#
+
+class Rar5Info(RarInfo):
+    """Shared fields for RAR5 records.
+    """
+    extract_version = 50
+    header_crc = None
+    header_size = None
+    header_offset = None
+    data_offset = None
+
+    # type=all
+    block_type = None
+    block_flags = None
+    add_size = 0
+    block_extra_size = 0
+
+    # type=MAIN
+    volume_number = None
+    _md_class = None
+    _md_expect = None
+
+    def _must_disable_hack(self):
+        return False
+
+
+class Rar5BaseFile(Rar5Info):
+    """Shared sturct for file & service record.
+    """
+    type = -1
+    file_flags = None
+    file_encryption = (0, 0, 0, b"", b"", b"")
+    file_compress_flags = None
+    file_redir = None
+    file_owner = None
+    file_version = None
+    blake2sp_hash = None
+
+    def _must_disable_hack(self):
+        if self.flags & RAR_FILE_PASSWORD:
+            return True
+        if self.block_flags & (RAR5_BLOCK_FLAG_SPLIT_BEFORE | RAR5_BLOCK_FLAG_SPLIT_AFTER):
+            return True
+        if self.file_compress_flags & RAR5_COMPR_SOLID:
+            return True
+        if self.file_redir:
+            return True
+        return False
+
+
+class Rar5FileInfo(Rar5BaseFile):
+    """RAR5 file record.
+    """
+    type = RAR_BLOCK_FILE
+
+    def is_symlink(self):
+        """Returns True if entry is a symlink."""
+        # pylint: disable=unsubscriptable-object
+        return (
+            self.file_redir is not None and
+            self.file_redir[0] in (
+                RAR5_XREDIR_UNIX_SYMLINK,
+                RAR5_XREDIR_WINDOWS_SYMLINK,
+                RAR5_XREDIR_WINDOWS_JUNCTION,
+            )
+        )
+
+    def is_file(self):
+        """Returns True if entry is a normal file."""
+        return not (self.is_dir() or self.is_symlink())
+
+    def is_dir(self):
+        """Returns True if entry is a directory."""
+        if not self.file_redir:
+            if self.file_flags & RAR5_FILE_FLAG_ISDIR:
+                return True
+        return False
+
+
+class Rar5ServiceInfo(Rar5BaseFile):
+    """RAR5 service record.
+    """
+    type = RAR_BLOCK_SUB
+
+
+class Rar5MainInfo(Rar5Info):
+    """RAR5 archive main record.
+    """
+    type = RAR_BLOCK_MAIN
+    main_flags = None
+    main_volume_number = None
+
+    def _must_disable_hack(self):
+        if self.main_flags & RAR5_MAIN_FLAG_SOLID:
+            return True
+        return False
+
+
+class Rar5EncryptionInfo(Rar5Info):
+    """RAR5 archive header encryption record.
+    """
+    type = RAR5_BLOCK_ENCRYPTION
+    encryption_algo = None
+    encryption_flags = None
+    encryption_kdf_count = None
+    encryption_salt = None
+    encryption_check_value = None
+
+    def needs_password(self):
+        return True
+
+
+class Rar5EndArcInfo(Rar5Info):
+    """RAR5 end of archive record.
+    """
+    type = RAR_BLOCK_ENDARC
+    endarc_flags = None
+
+
+class RAR5Parser(CommonParser):
+    """Parse RAR5 format.
+    """
+    _expect_sig = RAR5_ID
+    _hdrenc_main = None
+
+    # AES encrypted headers
+    _last_aes256_key = (-1, None, None)   # (kdf_count, salt, key)
+
+    def _gen_key(self, kdf_count, salt):
+        if self._last_aes256_key[:2] == (kdf_count, salt):
+            return self._last_aes256_key[2]
+        if kdf_count > 24:
+            raise BadRarFile("Too large kdf_count")
+        pwd = self._password
+        if isinstance(pwd, str):
+            pwd = pwd.encode("utf8")
+        key = pbkdf2_hmac("sha256", pwd, salt, 1 << kdf_count)
+        self._last_aes256_key = (kdf_count, salt, key)
+        return key
+
+    def _decrypt_header(self, fd):
+        if not _have_crypto:
+            raise NoCrypto("Cannot parse encrypted headers - no crypto")
+        h = self._hdrenc_main
+        key = self._gen_key(h.encryption_kdf_count, h.encryption_salt)
+        iv = fd.read(16)
+        return HeaderDecrypt(fd, key, iv)
+
+    def _parse_block_header(self, fd):
+        """Parse common block header
+        """
+        header_offset = fd.tell()
+
+        preload = 4 + 3
+        start_bytes = fd.read(preload)
+        header_crc, pos = load_le32(start_bytes, 0)
+        hdrlen, pos = load_vint(start_bytes, pos)
+        if hdrlen > 2 * 1024 * 1024:
+            return None
+        header_size = pos + hdrlen
+
+        # read full header, check for EOF
+        hdata = start_bytes + fd.read(header_size - len(start_bytes))
+        if len(hdata) != header_size:
+            self._set_error("Unexpected EOF when reading header")
+            return None
+        data_offset = fd.tell()
+
+        calc_crc = crc32(memoryview(hdata)[4:])
+        if header_crc != calc_crc:
+            # header parsing failed.
+            self._set_error("Header CRC error: exp=%x got=%x (xlen = %d)",
+                            header_crc, calc_crc, len(hdata))
+            return None
+
+        block_type, pos = load_vint(hdata, pos)
+
+        if block_type == RAR5_BLOCK_MAIN:
+            h, pos = self._parse_block_common(Rar5MainInfo(), hdata)
+            h = self._parse_main_block(h, hdata, pos)
+        elif block_type == RAR5_BLOCK_FILE:
+            h, pos = self._parse_block_common(Rar5FileInfo(), hdata)
+            h = self._parse_file_block(h, hdata, pos)
+        elif block_type == RAR5_BLOCK_SERVICE:
+            h, pos = self._parse_block_common(Rar5ServiceInfo(), hdata)
+            h = self._parse_file_block(h, hdata, pos)
+        elif block_type == RAR5_BLOCK_ENCRYPTION:
+            h, pos = self._parse_block_common(Rar5EncryptionInfo(), hdata)
+            h = self._parse_encryption_block(h, hdata, pos)
+        elif block_type == RAR5_BLOCK_ENDARC:
+            h, pos = self._parse_block_common(Rar5EndArcInfo(), hdata)
+            h = self._parse_endarc_block(h, hdata, pos)
+        else:
+            h = None
+        if h:
+            h.header_offset = header_offset
+            h.data_offset = data_offset
+        return h
+
+    def _parse_block_common(self, h, hdata):
+        h.header_crc, pos = load_le32(hdata, 0)
+        hdrlen, pos = load_vint(hdata, pos)
+        h.header_size = hdrlen + pos
+        h.block_type, pos = load_vint(hdata, pos)
+        h.block_flags, pos = load_vint(hdata, pos)
+
+        if h.block_flags & RAR5_BLOCK_FLAG_EXTRA_DATA:
+            h.block_extra_size, pos = load_vint(hdata, pos)
+        if h.block_flags & RAR5_BLOCK_FLAG_DATA_AREA:
+            h.add_size, pos = load_vint(hdata, pos)
+
+        h.compress_size = h.add_size
+
+        if h.block_flags & RAR5_BLOCK_FLAG_SKIP_IF_UNKNOWN:
+            h.flags |= RAR_SKIP_IF_UNKNOWN
+        if h.block_flags & RAR5_BLOCK_FLAG_DATA_AREA:
+            h.flags |= RAR_LONG_BLOCK
+        return h, pos
+
+    def _parse_main_block(self, h, hdata, pos):
+        h.main_flags, pos = load_vint(hdata, pos)
+        if h.main_flags & RAR5_MAIN_FLAG_HAS_VOLNR:
+            h.main_volume_number, pos = load_vint(hdata, pos)
+
+        h.flags |= RAR_MAIN_NEWNUMBERING
+        if h.main_flags & RAR5_MAIN_FLAG_SOLID:
+            h.flags |= RAR_MAIN_SOLID
+        if h.main_flags & RAR5_MAIN_FLAG_ISVOL:
+            h.flags |= RAR_MAIN_VOLUME
+        if h.main_flags & RAR5_MAIN_FLAG_RECOVERY:
+            h.flags |= RAR_MAIN_RECOVERY
+        if self._hdrenc_main:
+            h.flags |= RAR_MAIN_PASSWORD
+        if h.main_flags & RAR5_MAIN_FLAG_HAS_VOLNR == 0:
+            h.flags |= RAR_MAIN_FIRSTVOLUME
+
+        return h
+
+    def _parse_file_block(self, h, hdata, pos):
+        h.file_flags, pos = load_vint(hdata, pos)
+        h.file_size, pos = load_vint(hdata, pos)
+        h.mode, pos = load_vint(hdata, pos)
+
+        if h.file_flags & RAR5_FILE_FLAG_HAS_MTIME:
+            h.mtime, pos = load_unixtime(hdata, pos)
+            h.date_time = h.mtime.timetuple()[:6]
+        if h.file_flags & RAR5_FILE_FLAG_HAS_CRC32:
+            h.CRC, pos = load_le32(hdata, pos)
+            h._md_class = CRC32Context
+            h._md_expect = h.CRC
+
+        h.file_compress_flags, pos = load_vint(hdata, pos)
+        h.file_host_os, pos = load_vint(hdata, pos)
+        h.orig_filename, pos = load_vstr(hdata, pos)
+        h.filename = h.orig_filename.decode("utf8", "replace").rstrip("/")
+
+        # use compatible values
+        if h.file_host_os == RAR5_OS_WINDOWS:
+            h.host_os = RAR_OS_WIN32
+        else:
+            h.host_os = RAR_OS_UNIX
+        h.compress_type = RAR_M0 + ((h.file_compress_flags >> 7) & 7)
+
+        if h.block_extra_size:
+            # allow 1 byte of garbage
+            while pos < len(hdata) - 1:
+                xsize, pos = load_vint(hdata, pos)
+                xdata, pos = load_bytes(hdata, xsize, pos)
+                self._process_file_extra(h, xdata)
+
+        if h.block_flags & RAR5_BLOCK_FLAG_SPLIT_BEFORE:
+            h.flags |= RAR_FILE_SPLIT_BEFORE
+        if h.block_flags & RAR5_BLOCK_FLAG_SPLIT_AFTER:
+            h.flags |= RAR_FILE_SPLIT_AFTER
+        if h.file_flags & RAR5_FILE_FLAG_ISDIR:
+            h.flags |= RAR_FILE_DIRECTORY
+        if h.file_compress_flags & RAR5_COMPR_SOLID:
+            h.flags |= RAR_FILE_SOLID
+
+        if h.is_dir():
+            h.filename = h.filename + "/"
+        return h
+
+    def _parse_endarc_block(self, h, hdata, pos):
+        h.endarc_flags, pos = load_vint(hdata, pos)
+        if h.endarc_flags & RAR5_ENDARC_FLAG_NEXT_VOL:
+            h.flags |= RAR_ENDARC_NEXT_VOLUME
+        return h
+
+    def _parse_encryption_block(self, h, hdata, pos):
+        h.encryption_algo, pos = load_vint(hdata, pos)
+        h.encryption_flags, pos = load_vint(hdata, pos)
+        h.encryption_kdf_count, pos = load_byte(hdata, pos)
+        h.encryption_salt, pos = load_bytes(hdata, 16, pos)
+        if h.encryption_flags & RAR5_ENC_FLAG_HAS_CHECKVAL:
+            h.encryption_check_value = load_bytes(hdata, 12, pos)
+        if h.encryption_algo != RAR5_XENC_CIPHER_AES256:
+            raise BadRarFile("Unsupported header encryption cipher")
+        self._hdrenc_main = h
+        return h
+
+    def _process_file_extra(self, h, xdata):
+        xtype, pos = load_vint(xdata, 0)
+        if xtype == RAR5_XFILE_TIME:
+            self._parse_file_xtime(h, xdata, pos)
+        elif xtype == RAR5_XFILE_ENCRYPTION:
+            self._parse_file_encryption(h, xdata, pos)
+        elif xtype == RAR5_XFILE_HASH:
+            self._parse_file_hash(h, xdata, pos)
+        elif xtype == RAR5_XFILE_VERSION:
+            self._parse_file_version(h, xdata, pos)
+        elif xtype == RAR5_XFILE_REDIR:
+            self._parse_file_redir(h, xdata, pos)
+        elif xtype == RAR5_XFILE_OWNER:
+            self._parse_file_owner(h, xdata, pos)
+        elif xtype == RAR5_XFILE_SERVICE:
+            pass
+        else:
+            pass
+
+    # extra block for file time record
+    def _parse_file_xtime(self, h, xdata, pos):
+        tflags, pos = load_vint(xdata, pos)
+
+        ldr = load_windowstime
+        if tflags & RAR5_XTIME_UNIXTIME:
+            ldr = load_unixtime
+
+        if tflags & RAR5_XTIME_HAS_MTIME:
+            h.mtime, pos = ldr(xdata, pos)
+            h.date_time = h.mtime.timetuple()[:6]
+        if tflags & RAR5_XTIME_HAS_CTIME:
+            h.ctime, pos = ldr(xdata, pos)
+        if tflags & RAR5_XTIME_HAS_ATIME:
+            h.atime, pos = ldr(xdata, pos)
+
+        if tflags & RAR5_XTIME_UNIXTIME_NS:
+            if tflags & RAR5_XTIME_HAS_MTIME:
+                nsec, pos = load_le32(xdata, pos)
+                h.mtime = to_nsdatetime(h.mtime, nsec)
+            if tflags & RAR5_XTIME_HAS_CTIME:
+                nsec, pos = load_le32(xdata, pos)
+                h.ctime = to_nsdatetime(h.ctime, nsec)
+            if tflags & RAR5_XTIME_HAS_ATIME:
+                nsec, pos = load_le32(xdata, pos)
+                h.atime = to_nsdatetime(h.atime, nsec)
+
+    # just remember encryption info
+    def _parse_file_encryption(self, h, xdata, pos):
+        algo, pos = load_vint(xdata, pos)
+        flags, pos = load_vint(xdata, pos)
+        kdf_count, pos = load_byte(xdata, pos)
+        salt, pos = load_bytes(xdata, 16, pos)
+        iv, pos = load_bytes(xdata, 16, pos)
+        checkval = None
+        if flags & RAR5_XENC_CHECKVAL:
+            checkval, pos = load_bytes(xdata, 12, pos)
+        if flags & RAR5_XENC_TWEAKED:
+            h._md_expect = None
+            h._md_class = NoHashContext
+
+        h.file_encryption = (algo, flags, kdf_count, salt, iv, checkval)
+        h.flags |= RAR_FILE_PASSWORD
+
+    def _parse_file_hash(self, h, xdata, pos):
+        hash_type, pos = load_vint(xdata, pos)
+        if hash_type == RAR5_XHASH_BLAKE2SP:
+            h.blake2sp_hash, pos = load_bytes(xdata, 32, pos)
+            if (h.file_encryption[1] & RAR5_XENC_TWEAKED) == 0:
+                h._md_class = Blake2SP
+                h._md_expect = h.blake2sp_hash
+
+    def _parse_file_version(self, h, xdata, pos):
+        flags, pos = load_vint(xdata, pos)
+        version, pos = load_vint(xdata, pos)
+        h.file_version = (flags, version)
+
+    def _parse_file_redir(self, h, xdata, pos):
+        redir_type, pos = load_vint(xdata, pos)
+        redir_flags, pos = load_vint(xdata, pos)
+        redir_name, pos = load_vstr(xdata, pos)
+        redir_name = redir_name.decode("utf8", "replace")
+        h.file_redir = (redir_type, redir_flags, redir_name)
+
+    def _parse_file_owner(self, h, xdata, pos):
+        user_name = group_name = user_id = group_id = None
+
+        flags, pos = load_vint(xdata, pos)
+        if flags & RAR5_XOWNER_UNAME:
+            user_name, pos = load_vstr(xdata, pos)
+        if flags & RAR5_XOWNER_GNAME:
+            group_name, pos = load_vstr(xdata, pos)
+        if flags & RAR5_XOWNER_UID:
+            user_id, pos = load_vint(xdata, pos)
+        if flags & RAR5_XOWNER_GID:
+            group_id, pos = load_vint(xdata, pos)
+
+        h.file_owner = (user_name, group_name, user_id, group_id)
+
+    def process_entry(self, fd, item):
+        if item.block_type == RAR5_BLOCK_FILE:
+            if item.file_version:
+                pass    # skip old versions
+            elif (item.block_flags & RAR5_BLOCK_FLAG_SPLIT_BEFORE) == 0:
+                # use only first part
+                self._info_map[item.filename.rstrip("/")] = item
+                self._info_list.append(item)
+            elif len(self._info_list) > 0:
+                # final crc is in last block
+                old = self._info_list[-1]
+                old.CRC = item.CRC
+                old._md_expect = item._md_expect
+                old.blake2sp_hash = item.blake2sp_hash
+                old.compress_size += item.compress_size
+        elif item.block_type == RAR5_BLOCK_SERVICE:
+            if item.filename == "CMT":
+                self._load_comment(fd, item)
+
+    def _load_comment(self, fd, item):
+        if item.block_flags & (RAR5_BLOCK_FLAG_SPLIT_BEFORE | RAR5_BLOCK_FLAG_SPLIT_AFTER):
+            return None
+        if item.compress_type != RAR_M0:
+            return None
+
+        if item.flags & RAR_FILE_PASSWORD:
+            algo, ___flags, kdf_count, salt, iv, ___checkval = item.file_encryption
+            if algo != RAR5_XENC_CIPHER_AES256:
+                return None
+            key = self._gen_key(kdf_count, salt)
+            f = HeaderDecrypt(fd, key, iv)
+            cmt = f.read(item.file_size)
+        else:
+            # archive comment
+            with self._open_clear(item) as cmtstream:
+                cmt = cmtstream.read()
+
+        # rar bug? - appends zero to comment
+        cmt = cmt.split(b"\0", 1)[0]
+        self.comment = cmt.decode("utf8")
+        return None
+
+    def _open_hack(self, inf, pwd):
+        # len, type, blk_flags, flags
+        main_hdr = b"\x03\x01\x00\x00"
+        endarc_hdr = b"\x03\x05\x00\x00"
+        main_hdr = S_LONG.pack(crc32(main_hdr)) + main_hdr
+        endarc_hdr = S_LONG.pack(crc32(endarc_hdr)) + endarc_hdr
+        return self._open_hack_core(inf, pwd, RAR5_ID + main_hdr, endarc_hdr)
+
+
+##
+## Utility classes
+##
+
+class UnicodeFilename:
+    """Handle RAR3 unicode filename decompression.
+    """
+    def __init__(self, name, encdata):
+        self.std_name = bytearray(name)
+        self.encdata = bytearray(encdata)
+        self.pos = self.encpos = 0
+        self.buf = bytearray()
+        self.failed = 0
+
+    def enc_byte(self):
+        """Copy encoded byte."""
+        try:
+            c = self.encdata[self.encpos]
+            self.encpos += 1
+            return c
+        except IndexError:
+            self.failed = 1
+            return 0
+
+    def std_byte(self):
+        """Copy byte from 8-bit representation."""
+        try:
+            return self.std_name[self.pos]
+        except IndexError:
+            self.failed = 1
+            return ord("?")
+
+    def put(self, lo, hi):
+        """Copy 16-bit value to result."""
+        self.buf.append(lo)
+        self.buf.append(hi)
+        self.pos += 1
+
+    def decode(self):
+        """Decompress compressed UTF16 value."""
+        hi = self.enc_byte()
+        flagbits = 0
+        while self.encpos < len(self.encdata):
+            if flagbits == 0:
+                flags = self.enc_byte()
+                flagbits = 8
+            flagbits -= 2
+            t = (flags >> flagbits) & 3
+            if t == 0:
+                self.put(self.enc_byte(), 0)
+            elif t == 1:
+                self.put(self.enc_byte(), hi)
+            elif t == 2:
+                self.put(self.enc_byte(), self.enc_byte())
+            else:
+                n = self.enc_byte()
+                if n & 0x80:
+                    c = self.enc_byte()
+                    for _ in range((n & 0x7f) + 2):
+                        lo = (self.std_byte() + c) & 0xFF
+                        self.put(lo, hi)
+                else:
+                    for _ in range(n + 2):
+                        self.put(self.std_byte(), 0)
+        return self.buf.decode("utf-16le", "replace")
+
+
+class RarExtFile(io.RawIOBase):
+    """Base class for file-like object that :meth:`RarFile.open` returns.
+
+    Provides public methods and common crc checking.
+
+    Behaviour:
+     - no short reads - .read() and .readinfo() read as much as requested.
+     - no internal buffer, use io.BufferedReader for that.
+    """
+    name = None     #: Filename of the archive entry
+    mode = "rb"
+    _parser = None
+    _inf = None
+    _fd = None
+    _remain = 0
+    _returncode = 0
+    _md_context = None
+
+    def _open_extfile(self, parser, inf):
+        self.name = inf.filename
+        self._parser = parser
+        self._inf = inf
+
+        if self._fd:
+            self._fd.close()
+        md_class = self._inf._md_class or NoHashContext
+        self._md_context = md_class()
+        self._fd = None
+        self._remain = self._inf.file_size
+
+    def read(self, n=-1):
+        """Read all or specified amount of data from archive entry."""
+
+        # sanitize count
+        if n is None or n < 0:
+            n = self._remain
+        elif n > self._remain:
+            n = self._remain
+        if n == 0:
+            return b""
+
+        buf = []
+        orig = n
+        while n > 0:
+            # actual read
+            data = self._read(n)
+            if not data:
+                break
+            buf.append(data)
+            self._md_context.update(data)
+            self._remain -= len(data)
+            n -= len(data)
+        data = b"".join(buf)
+        if n > 0:
+            raise BadRarFile("Failed the read enough data: req=%d got=%d" % (orig, len(data)))
+
+        # done?
+        if not data or self._remain == 0:
+            # self.close()
+            self._check()
+        return data
+
+    def _check(self):
+        """Check final CRC."""
+        final = self._md_context.digest()
+        exp = self._inf._md_expect
+        if exp is None:
+            return
+        if final is None:
+            return
+        if self._returncode:
+            check_returncode(self._returncode, "", tool_setup().get_errmap())
+        if self._remain != 0:
+            raise BadRarFile("Failed the read enough data")
+        if final != exp:
+            raise BadRarFile("Corrupt file - CRC check failed: %s - exp=%r got=%r" % (
+                self._inf.filename, exp, final))
+
+    def _read(self, cnt):
+        """Actual read that gets sanitized cnt."""
+        raise NotImplementedError("_read")
+
+    def close(self):
+        """Close open resources."""
+
+        super().close()
+
+        if self._fd:
+            self._fd.close()
+            self._fd = None
+
+    def __del__(self):
+        """Hook delete to make sure tempfile is removed."""
+        self.close()
+
+    def readinto(self, buf):
+        """Zero-copy read directly into buffer.
+
+        Returns bytes read.
+        """
+        raise NotImplementedError("readinto")
+
+    def tell(self):
+        """Return current reading position in uncompressed data."""
+        return self._inf.file_size - self._remain
+
+    def seek(self, offset, whence=0):
+        """Seek in data.
+
+        On uncompressed files, the seeking works by actual
+        seeks so it's fast.  On compresses files its slow
+        - forward seeking happends by reading ahead,
+        backwards by re-opening and decompressing from the start.
+        """
+
+        # disable crc check when seeking
+        self._md_context = NoHashContext()
+
+        fsize = self._inf.file_size
+        cur_ofs = self.tell()
+
+        if whence == 0:     # seek from beginning of file
+            new_ofs = offset
+        elif whence == 1:   # seek from current position
+            new_ofs = cur_ofs + offset
+        elif whence == 2:   # seek from end of file
+            new_ofs = fsize + offset
+        else:
+            raise ValueError("Invalid value for whence")
+
+        # sanity check
+        if new_ofs < 0:
+            new_ofs = 0
+        elif new_ofs > fsize:
+            new_ofs = fsize
+
+        # do the actual seek
+        if new_ofs >= cur_ofs:
+            self._skip(new_ofs - cur_ofs)
+        else:
+            # reopen and seek
+            self._open_extfile(self._parser, self._inf)
+            self._skip(new_ofs)
+        return self.tell()
+
+    def _skip(self, cnt):
+        """Read and discard data"""
+        empty_read(self, cnt, BSIZE)
+
+    def readable(self):
+        """Returns True"""
+        return True
+
+    def writable(self):
+        """Returns False.
+
+        Writing is not supported.
+        """
+        return False
+
+    def seekable(self):
+        """Returns True.
+
+        Seeking is supported, although it's slow on compressed files.
+        """
+        return True
+
+    def readall(self):
+        """Read all remaining data"""
+        # avoid RawIOBase default impl
+        return self.read()
+
+
+class PipeReader(RarExtFile):
+    """Read data from pipe, handle tempfile cleanup."""
+
+    def __init__(self, parser, inf, cmd, tempfile=None):
+        super().__init__()
+        self._cmd = cmd
+        self._proc = None
+        self._tempfile = tempfile
+        self._open_extfile(parser, inf)
+
+    def _close_proc(self):
+        if not self._proc:
+            return
+        for f in (self._proc.stdout, self._proc.stderr, self._proc.stdin):
+            if f:
+                f.close()
+        self._proc.wait()
+        self._returncode = self._proc.returncode
+        self._proc = None
+
+    def _open_extfile(self, parser, inf):
+        super()._open_extfile(parser, inf)
+
+        # stop old process
+        self._close_proc()
+
+        # launch new process
+        self._returncode = 0
+        self._proc = custom_popen(self._cmd)
+        self._fd = self._proc.stdout
+
+    def _read(self, cnt):
+        """Read from pipe."""
+
+        # normal read is usually enough
+        data = self._fd.read(cnt)
+        if len(data) == cnt or not data:
+            return data
+
+        # short read, try looping
+        buf = [data]
+        cnt -= len(data)
+        while cnt > 0:
+            data = self._fd.read(cnt)
+            if not data:
+                break
+            cnt -= len(data)
+            buf.append(data)
+        return b"".join(buf)
+
+    def close(self):
+        """Close open resources."""
+
+        self._close_proc()
+        super().close()
+
+        if self._tempfile:
+            try:
+                os.unlink(self._tempfile)
+            except OSError:
+                pass
+            self._tempfile = None
+
+    def readinto(self, buf):
+        """Zero-copy read directly into buffer."""
+        cnt = len(buf)
+        if cnt > self._remain:
+            cnt = self._remain
+        vbuf = memoryview(buf)
+        res = got = 0
+        while got < cnt:
+            res = self._fd.readinto(vbuf[got: cnt])
+            if not res:
+                break
+            self._md_context.update(vbuf[got: got + res])
+            self._remain -= res
+            got += res
+        return got
+
+
+class DirectReader(RarExtFile):
+    """Read uncompressed data directly from archive.
+    """
+    _cur = None
+    _cur_avail = None
+    _volfile = None
+
+    def __init__(self, parser, inf):
+        super().__init__()
+        self._open_extfile(parser, inf)
+
+    def _open_extfile(self, parser, inf):
+        super()._open_extfile(parser, inf)
+
+        self._volfile = self._inf.volume_file
+        self._fd = XFile(self._volfile, 0)
+        self._fd.seek(self._inf.header_offset, 0)
+        self._cur = self._parser._parse_header(self._fd)
+        self._cur_avail = self._cur.add_size
+
+    def _skip(self, cnt):
+        """RAR Seek, skipping through rar files to get to correct position
+        """
+
+        while cnt > 0:
+            # next vol needed?
+            if self._cur_avail == 0:
+                if not self._open_next():
+                    break
+
+            # fd is in read pos, do the read
+            if cnt > self._cur_avail:
+                cnt -= self._cur_avail
+                self._remain -= self._cur_avail
+                self._cur_avail = 0
+            else:
+                self._fd.seek(cnt, 1)
+                self._cur_avail -= cnt
+                self._remain -= cnt
+                cnt = 0
+
+    def _read(self, cnt):
+        """Read from potentially multi-volume archive."""
+
+        buf = []
+        while cnt > 0:
+            # next vol needed?
+            if self._cur_avail == 0:
+                if not self._open_next():
+                    break
+
+            # fd is in read pos, do the read
+            if cnt > self._cur_avail:
+                data = self._fd.read(self._cur_avail)
+            else:
+                data = self._fd.read(cnt)
+            if not data:
+                break
+
+            # got some data
+            cnt -= len(data)
+            self._cur_avail -= len(data)
+            buf.append(data)
+
+        if len(buf) == 1:
+            return buf[0]
+        return b"".join(buf)
+
+    def _open_next(self):
+        """Proceed to next volume."""
+
+        # is the file split over archives?
+        if (self._cur.flags & RAR_FILE_SPLIT_AFTER) == 0:
+            return False
+
+        if self._fd:
+            self._fd.close()
+            self._fd = None
+
+        # open next part
+        self._volfile = self._parser._next_volname(self._volfile)
+        fd = open(self._volfile, "rb", 0)
+        self._fd = fd
+        sig = fd.read(len(self._parser._expect_sig))
+        if sig != self._parser._expect_sig:
+            raise BadRarFile("Invalid signature")
+
+        # loop until first file header
+        while True:
+            cur = self._parser._parse_header(fd)
+            if not cur:
+                raise BadRarFile("Unexpected EOF")
+            if cur.type in (RAR_BLOCK_MARK, RAR_BLOCK_MAIN):
+                if cur.add_size:
+                    fd.seek(cur.add_size, 1)
+                continue
+            if cur.orig_filename != self._inf.orig_filename:
+                raise BadRarFile("Did not found file entry")
+            self._cur = cur
+            self._cur_avail = cur.add_size
+            return True
+
+    def readinto(self, buf):
+        """Zero-copy read directly into buffer."""
+        got = 0
+        vbuf = memoryview(buf)
+        while got < len(buf):
+            # next vol needed?
+            if self._cur_avail == 0:
+                if not self._open_next():
+                    break
+
+            # length for next read
+            cnt = len(buf) - got
+            if cnt > self._cur_avail:
+                cnt = self._cur_avail
+
+            # read into temp view
+            res = self._fd.readinto(vbuf[got: got + cnt])
+            if not res:
+                break
+            self._md_context.update(vbuf[got: got + res])
+            self._cur_avail -= res
+            self._remain -= res
+            got += res
+        return got
+
+
+class HeaderDecrypt:
+    """File-like object that decrypts from another file"""
+    def __init__(self, f, key, iv):
+        self.f = f
+        self.ciph = AES_CBC_Decrypt(key, iv)
+        self.buf = b""
+
+    def tell(self):
+        """Current file pos - works only on block boundaries."""
+        return self.f.tell()
+
+    def read(self, cnt=None):
+        """Read and decrypt."""
+        if cnt > 8 * 1024:
+            raise BadRarFile("Bad count to header decrypt - wrong password?")
+
+        # consume old data
+        if cnt <= len(self.buf):
+            res = self.buf[:cnt]
+            self.buf = self.buf[cnt:]
+            return res
+        res = self.buf
+        self.buf = b""
+        cnt -= len(res)
+
+        # decrypt new data
+        blklen = 16
+        while cnt > 0:
+            enc = self.f.read(blklen)
+            if len(enc) < blklen:
+                break
+            dec = self.ciph.decrypt(enc)
+            if cnt >= len(dec):
+                res += dec
+                cnt -= len(dec)
+            else:
+                res += dec[:cnt]
+                self.buf = dec[cnt:]
+                cnt = 0
+
+        return res
+
+
+class XFile:
+    """Input may be filename or file object.
+    """
+    __slots__ = ("_fd", "_need_close")
+
+    def __init__(self, xfile, bufsize=1024):
+        if is_filelike(xfile):
+            self._need_close = False
+            self._fd = xfile
+            self._fd.seek(0)
+        else:
+            self._need_close = True
+            self._fd = open(xfile, "rb", bufsize)
+
+    def read(self, n=None):
+        """Read from file."""
+        return self._fd.read(n)
+
+    def tell(self):
+        """Return file pos."""
+        return self._fd.tell()
+
+    def seek(self, ofs, whence=0):
+        """Move file pos."""
+        return self._fd.seek(ofs, whence)
+
+    def readinto(self, buf):
+        """Read into buffer."""
+        return self._fd.readinto(buf)
+
+    def close(self):
+        """Close file object."""
+        if self._need_close:
+            self._fd.close()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, typ, val, tb):
+        self.close()
+
+
+class NoHashContext:
+    """No-op hash function."""
+    def __init__(self, data=None):
+        """Initialize"""
+    def update(self, data):
+        """Update data"""
+    def digest(self):
+        """Final hash"""
+    def hexdigest(self):
+        """Hexadecimal digest."""
+
+
+class CRC32Context:
+    """Hash context that uses CRC32."""
+    __slots__ = ["_crc"]
+
+    def __init__(self, data=None):
+        self._crc = 0
+        if data:
+            self.update(data)
+
+    def update(self, data):
+        """Process data."""
+        self._crc = crc32(data, self._crc)
+
+    def digest(self):
+        """Final hash."""
+        return self._crc
+
+    def hexdigest(self):
+        """Hexadecimal digest."""
+        return "%08x" % self.digest()
+
+
+class Blake2SP:
+    """Blake2sp hash context.
+    """
+    __slots__ = ["_thread", "_buf", "_cur", "_digest"]
+    digest_size = 32
+    block_size = 64
+    parallelism = 8
+
+    def __init__(self, data=None):
+        self._buf = b""
+        self._cur = 0
+        self._digest = None
+        self._thread = []
+
+        for i in range(self.parallelism):
+            ctx = self._blake2s(i, 0, i == (self.parallelism - 1))
+            self._thread.append(ctx)
+
+        if data:
+            self.update(data)
+
+    def _blake2s(self, ofs, depth, is_last):
+        return blake2s(node_offset=ofs, node_depth=depth, last_node=is_last,
+                       depth=2, inner_size=32, fanout=self.parallelism)
+
+    def _add_block(self, blk):
+        self._thread[self._cur].update(blk)
+        self._cur = (self._cur + 1) % self.parallelism
+
+    def update(self, data):
+        """Hash data.
+        """
+        view = memoryview(data)
+        bs = self.block_size
+        if self._buf:
+            need = bs - len(self._buf)
+            if len(view) < need:
+                self._buf += view.tobytes()
+                return
+            self._add_block(self._buf + view[:need].tobytes())
+            view = view[need:]
+        while len(view) >= bs:
+            self._add_block(view[:bs])
+            view = view[bs:]
+        self._buf = view.tobytes()
+
+    def digest(self):
+        """Return final digest value.
+        """
+        if self._digest is None:
+            if self._buf:
+                self._add_block(self._buf)
+                self._buf = b""
+            ctx = self._blake2s(0, 1, True)
+            for t in self._thread:
+                ctx.update(t.digest())
+            self._digest = ctx.digest()
+        return self._digest
+
+    def hexdigest(self):
+        """Hexadecimal digest."""
+        return hexlify(self.digest()).decode("ascii")
+
+
+class Rar3Sha1:
+    """Emulate buggy SHA1 from RAR3.
+    """
+    digest_size = 20
+    block_size = 64
+
+    _BLK_BE = struct.Struct(b">16L")
+    _BLK_LE = struct.Struct(b"<16L")
+
+    __slots__ = ("_nbytes", "_md", "_rarbug")
+
+    def __init__(self, data=b"", rarbug=False):
+        self._md = sha1()
+        self._nbytes = 0
+        self._rarbug = rarbug
+        self.update(data)
+
+    def update(self, data):
+        """Process more data."""
+        self._md.update(data)
+        bufpos = self._nbytes & 63
+        self._nbytes += len(data)
+
+        if self._rarbug and len(data) > 64:
+            dpos = self.block_size - bufpos
+            while dpos + self.block_size <= len(data):
+                self._corrupt(data, dpos)
+                dpos += self.block_size
+
+    def digest(self):
+        """Return final state."""
+        return self._md.digest()
+
+    def hexdigest(self):
+        """Return final state as hex string."""
+        return self._md.hexdigest()
+
+    def _corrupt(self, data, dpos):
+        """Corruption from SHA1 core."""
+        ws = list(self._BLK_BE.unpack_from(data, dpos))
+        for t in range(16, 80):
+            tmp = ws[(t - 3) & 15] ^ ws[(t - 8) & 15] ^ ws[(t - 14) & 15] ^ ws[(t - 16) & 15]
+            ws[t & 15] = ((tmp << 1) | (tmp >> (32 - 1))) & 0xFFFFFFFF
+        self._BLK_LE.pack_into(data, dpos, *ws)
+
+
+##
+## Utility functions
+##
+
+S_LONG = Struct("<L")
+S_SHORT = Struct("<H")
+S_BYTE = Struct("<B")
+
+S_BLK_HDR = Struct("<HBHH")
+S_FILE_HDR = Struct("<LLBLLBBHL")
+S_COMMENT_HDR = Struct("<HBBH")
+
+
+def load_vint(buf, pos):
+    """Load RAR5 variable-size int."""
+    limit = min(pos + 11, len(buf))
+    res = ofs = 0
+    while pos < limit:
+        b = buf[pos]
+        res += ((b & 0x7F) << ofs)
+        pos += 1
+        ofs += 7
+        if b < 0x80:
+            return res, pos
+    raise BadRarFile("cannot load vint")
+
+
+def load_byte(buf, pos):
+    """Load single byte"""
+    end = pos + 1
+    if end > len(buf):
+        raise BadRarFile("cannot load byte")
+    return S_BYTE.unpack_from(buf, pos)[0], end
+
+
+def load_le32(buf, pos):
+    """Load little-endian 32-bit integer"""
+    end = pos + 4
+    if end > len(buf):
+        raise BadRarFile("cannot load le32")
+    return S_LONG.unpack_from(buf, pos)[0], pos + 4
+
+
+def load_bytes(buf, num, pos):
+    """Load sequence of bytes"""
+    end = pos + num
+    if end > len(buf):
+        raise BadRarFile("cannot load bytes")
+    return buf[pos: end], end
+
+
+def load_vstr(buf, pos):
+    """Load bytes prefixed by vint length"""
+    slen, pos = load_vint(buf, pos)
+    return load_bytes(buf, slen, pos)
+
+
+def load_dostime(buf, pos):
+    """Load LE32 dos timestamp"""
+    stamp, pos = load_le32(buf, pos)
+    tup = parse_dos_time(stamp)
+    return to_datetime(tup), pos
+
+
+def load_unixtime(buf, pos):
+    """Load LE32 unix timestamp"""
+    secs, pos = load_le32(buf, pos)
+    dt = datetime.fromtimestamp(secs, timezone.utc)
+    return dt, pos
+
+
+def load_windowstime(buf, pos):
+    """Load LE64 windows timestamp"""
+    # unix epoch (1970) in seconds from windows epoch (1601)
+    unix_epoch = 11644473600
+    val1, pos = load_le32(buf, pos)
+    val2, pos = load_le32(buf, pos)
+    secs, n1secs = divmod((val2 << 32) | val1, 10000000)
+    dt = datetime.fromtimestamp(secs - unix_epoch, timezone.utc)
+    dt = to_nsdatetime(dt, n1secs * 100)
+    return dt, pos
+
+
+def _next_newvol(volfile):
+    """New-style next volume
+    """
+    i = len(volfile) - 1
+    while i >= 0:
+        if volfile[i] >= "0" and volfile[i] <= "9":
+            return _inc_volname(volfile, i)
+        i -= 1
+    raise BadRarName("Cannot construct volume name: " + volfile)
+
+
+def _next_oldvol(volfile):
+    """Old-style next volume
+    """
+    # rar -> r00
+    if volfile[-4:].lower() == ".rar":
+        return volfile[:-2] + "00"
+    return _inc_volname(volfile, len(volfile) - 1)
+
+
+def _inc_volname(volfile, i):
+    """increase digits with carry, otherwise just increment char
+    """
+    fn = list(volfile)
+    while i >= 0:
+        if fn[i] != "9":
+            fn[i] = chr(ord(fn[i]) + 1)
+            break
+        fn[i] = "0"
+        i -= 1
+    return "".join(fn)
+
+
+def _parse_ext_time(h, data, pos):
+    """Parse all RAR3 extended time fields
+    """
+    # flags and rest of data can be missing
+    flags = 0
+    if pos + 2 <= len(data):
+        flags = S_SHORT.unpack_from(data, pos)[0]
+        pos += 2
+
+    mtime, pos = _parse_xtime(flags >> 3 * 4, data, pos, h.mtime)
+    h.ctime, pos = _parse_xtime(flags >> 2 * 4, data, pos)
+    h.atime, pos = _parse_xtime(flags >> 1 * 4, data, pos)
+    h.arctime, pos = _parse_xtime(flags >> 0 * 4, data, pos)
+    if mtime:
+        h.mtime = mtime
+        h.date_time = mtime.timetuple()[:6]
+    return pos
+
+
+def _parse_xtime(flag, data, pos, basetime=None):
+    """Parse one RAR3 extended time field
+    """
+    res = None
+    if flag & 8:
+        if not basetime:
+            basetime, pos = load_dostime(data, pos)
+
+        # load second fractions of 100ns units
+        rem = 0
+        cnt = flag & 3
+        for _ in range(cnt):
+            b, pos = load_byte(data, pos)
+            rem = (b << 16) | (rem >> 8)
+
+        # dostime has room for 30 seconds only, correct if needed
+        if flag & 4 and basetime.second < 59:
+            basetime = basetime.replace(second=basetime.second + 1)
+
+        res = to_nsdatetime(basetime, rem * 100)
+    return res, pos
+
+
+def is_filelike(obj):
+    """Filename or file object?
+    """
+    if isinstance(obj, (bytes, str, Path)):
+        return False
+    res = True
+    for a in ("read", "tell", "seek"):
+        res = res and hasattr(obj, a)
+    if not res:
+        raise ValueError("Invalid object passed as file")
+    return True
+
+
+def rar3_s2k(pwd, salt):
+    """String-to-key hash for RAR3.
+    """
+    if not isinstance(pwd, str):
+        pwd = pwd.decode("utf8")
+    seed = bytearray(pwd.encode("utf-16le") + salt)
+    h = Rar3Sha1(rarbug=True)
+    iv = b""
+    for i in range(16):
+        for j in range(0x4000):
+            cnt = S_LONG.pack(i * 0x4000 + j)
+            h.update(seed)
+            h.update(cnt[:3])
+            if j == 0:
+                iv += h.digest()[19:20]
+    key_be = h.digest()[:16]
+    key_le = pack("<LLLL", *unpack(">LLLL", key_be))
+    return key_le, iv
+
+
+def rar3_decompress(vers, meth, data, declen=0, flags=0, crc=0, pwd=None, salt=None):
+    """Decompress blob of compressed data.
+
+    Used for data with non-standard header - eg. comments.
+    """
+    # already uncompressed?
+    if meth == RAR_M0 and (flags & RAR_FILE_PASSWORD) == 0:
+        return data
+
+    # take only necessary flags
+    flags = flags & (RAR_FILE_PASSWORD | RAR_FILE_SALT | RAR_FILE_DICTMASK)
+    flags |= RAR_LONG_BLOCK
+
+    # file header
+    fname = b"data"
+    date = ((2010 - 1980) << 25) + (12 << 21) + (31 << 16)
+    mode = 0x20
+    fhdr = S_FILE_HDR.pack(len(data), declen, RAR_OS_MSDOS, crc,
+                           date, vers, meth, len(fname), mode)
+    fhdr += fname
+    if salt:
+        fhdr += salt
+
+    # full header
+    hlen = S_BLK_HDR.size + len(fhdr)
+    hdr = S_BLK_HDR.pack(0, RAR_BLOCK_FILE, flags, hlen) + fhdr
+    hcrc = crc32(hdr[2:]) & 0xFFFF
+    hdr = S_BLK_HDR.pack(hcrc, RAR_BLOCK_FILE, flags, hlen) + fhdr
+
+    # archive main header
+    mh = S_BLK_HDR.pack(0x90CF, RAR_BLOCK_MAIN, 0, 13) + b"\0" * (2 + 4)
+
+    # decompress via temp rar
+    setup = tool_setup()
+    tmpfd, tmpname = mkstemp(suffix=".rar", dir=HACK_TMP_DIR)
+    tmpf = os.fdopen(tmpfd, "wb")
+    try:
+        tmpf.write(RAR_ID + mh + hdr + data)
+        tmpf.close()
+
+        curpwd = (flags & RAR_FILE_PASSWORD) and pwd or None
+        cmd = setup.open_cmdline(curpwd, tmpname)
+        p = custom_popen(cmd)
+        return p.communicate()[0]
+    finally:
+        tmpf.close()
+        os.unlink(tmpname)
+
+
+def sanitize_filename(fname, pathsep, is_win32):
+    """Simulate unrar sanitization.
+    """
+    if is_win32:
+        if len(fname) > 1 and fname[1] == ":":
+            fname = fname[2:]
+        rc = RC_BAD_CHARS_WIN32
+    else:
+        rc = RC_BAD_CHARS_UNIX
+    if rc.search(fname):
+        fname = rc.sub("_", fname)
+
+    parts = []
+    for seg in fname.split("/"):
+        if seg in ("", ".", ".."):
+            continue
+        if is_win32 and seg[-1] in (" ", "."):
+            seg = seg[:-1] + "_"
+        parts.append(seg)
+    return pathsep.join(parts)
+
+
+def empty_read(src, size, blklen):
+    """Read and drop fixed amount of data.
+    """
+    while size > 0:
+        if size > blklen:
+            res = src.read(blklen)
+        else:
+            res = src.read(size)
+        if not res:
+            raise BadRarFile("cannot load data")
+        size -= len(res)
+
+
+def to_datetime(t):
+    """Convert 6-part time tuple into datetime object.
+    """
+    # extract values
+    year, mon, day, h, m, s = t
+
+    # assume the values are valid
+    try:
+        return datetime(year, mon, day, h, m, s)
+    except ValueError:
+        pass
+
+    # sanitize invalid values
+    mday = (0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
+    mon = max(1, min(mon, 12))
+    day = max(1, min(day, mday[mon]))
+    h = min(h, 23)
+    m = min(m, 59)
+    s = min(s, 59)
+    if mon == 2 and day == 29:
+        try:
+            return datetime(year, mon, day, h, m, s)
+        except ValueError:
+            day = 28
+    return datetime(year, mon, day, h, m, s)
+
+
+def parse_dos_time(stamp):
+    """Parse standard 32-bit DOS timestamp.
+    """
+    sec, stamp = stamp & 0x1F, stamp >> 5
+    mn, stamp = stamp & 0x3F, stamp >> 6
+    hr, stamp = stamp & 0x1F, stamp >> 5
+    day, stamp = stamp & 0x1F, stamp >> 5
+    mon, stamp = stamp & 0x0F, stamp >> 4
+    yr = (stamp & 0x7F) + 1980
+    return (yr, mon, day, hr, mn, sec * 2)
+
+
+# pylint: disable=arguments-differ,signature-differs
+class nsdatetime(datetime):
+    """Datetime that carries nanoseconds.
+
+    Arithmetic not supported, will lose nanoseconds.
+
+    .. versionadded:: 4.0
+    """
+    __slots__ = ("nanosecond",)
+    nanosecond: int     #: Number of nanoseconds, 0 <= nanosecond < 999999999
+
+    def __new__(cls, year, month, day, hour=0, minute=0, second=0,
+                microsecond=0, tzinfo=None, *, fold=0, nanosecond=0):
+        usec, mod = divmod(nanosecond, 1000) if nanosecond else (microsecond, 0)
+        if mod == 0:
+            return datetime(year, month, day, hour, minute, second, usec, tzinfo, fold=fold)
+        self = super().__new__(cls, year, month, day, hour, minute, second, usec, tzinfo, fold=fold)
+        self.nanosecond = nanosecond
+        return self
+
+    def isoformat(self, sep="T", timespec="auto"):
+        """Formats with nanosecond precision by default.
+        """
+        if timespec == "auto":
+            pre, post = super().isoformat(sep, "microseconds").split(".", 1)
+            return f"{pre}.{self.nanosecond:09d}{post[6:]}"
+        return super().isoformat(sep, timespec)
+
+    def astimezone(self, tz=None):
+        """Convert to new timezone.
+        """
+        tmp = super().astimezone(tz)
+        return self.__class__(tmp.year, tmp.month, tmp.day, tmp.hour, tmp.minute, tmp.second,
+                              nanosecond=self.nanosecond, tzinfo=tmp.tzinfo, fold=tmp.fold)
+
+    def replace(self, year=None, month=None, day=None, hour=None, minute=None, second=None,
+                microsecond=None, tzinfo=None, *, fold=None, nanosecond=None):
+        """Return new timestamp with specified fields replaced.
+        """
+        return self.__class__(
+            self.year if year is None else year,
+            self.month if month is None else month,
+            self.day if day is None else day,
+            self.hour if hour is None else hour,
+            self.minute if minute is None else minute,
+            self.second if second is None else second,
+            nanosecond=((self.nanosecond if microsecond is None else microsecond * 1000)
+                        if nanosecond is None else nanosecond),
+            tzinfo=self.tzinfo if tzinfo is None else tzinfo,
+            fold=self.fold if fold is None else fold)
+
+    def __hash__(self):
+        return hash((super().__hash__(), self.nanosecond)) if self.nanosecond else super().__hash__()
+
+    def __eq__(self, other):
+        return super().__eq__(other) and self.nanosecond == (
+            other.nanosecond if isinstance(other, nsdatetime) else other.microsecond * 1000)
+
+    def __gt__(self, other):
+        return super().__gt__(other) or (super().__eq__(other) and self.nanosecond > (
+            other.nanosecond if isinstance(other, nsdatetime) else other.microsecond * 1000))
+
+    def __lt__(self, other):
+        return not (self > other or self == other)
+
+    def __ge__(self, other):
+        return not self < other
+
+    def __le__(self, other):
+        return not self > other
+
+    def __ne__(self, other):
+        return not self == other
+
+
+def to_nsdatetime(dt, nsec):
+    """Apply nanoseconds to datetime.
+    """
+    if not nsec:
+        return dt
+    return nsdatetime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second,
+                      tzinfo=dt.tzinfo, fold=dt.fold, nanosecond=nsec)
+
+
+def to_nsecs(dt):
+    """Convert datatime instance to nanoseconds.
+    """
+    secs = int(dt.timestamp())
+    nsecs = dt.nanosecond if isinstance(dt, nsdatetime) else dt.microsecond * 1000
+    return secs * 1000000000 + nsecs
+
+
+def custom_popen(cmd):
+    """Disconnect cmd from parent fds, read only from stdout.
+    """
+    creationflags = 0x08000000 if WIN32 else 0  # CREATE_NO_WINDOW
+    try:
+        p = Popen(cmd, bufsize=0, stdout=PIPE, stderr=STDOUT, stdin=DEVNULL,
+                  creationflags=creationflags)
+    except OSError as ex:
+        if ex.errno == errno.ENOENT:
+            raise RarCannotExec("Unrar not installed?")
+        if ex.errno == errno.EACCES or ex.errno == errno.EPERM:
+            raise RarCannotExec("Cannot execute unrar")
+        raise
+    return p
+
+
+def check_returncode(code, out, errmap):
+    """Raise exception according to unrar exit code.
+    """
+    if code == 0:
+        return
+
+    if code > 0 and code < len(errmap):
+        exc = errmap[code]
+    elif code == 255:
+        exc = RarUserBreak
+    elif code < 0:
+        exc = RarSignalExit
+    else:
+        exc = RarUnknownError
+
+    # format message
+    if out:
+        msg = "%s [%d]: %s" % (exc.__doc__, code, out)
+    else:
+        msg = "%s [%d]" % (exc.__doc__, code)
+
+    raise exc(msg)
+
+
+def membuf_tempfile(memfile):
+    """Write in-memory file object to real file.
+    """
+    memfile.seek(0, 0)
+
+    tmpfd, tmpname = mkstemp(suffix=".rar", dir=HACK_TMP_DIR)
+    tmpf = os.fdopen(tmpfd, "wb")
+
+    try:
+        shutil.copyfileobj(memfile, tmpf, BSIZE)
+        tmpf.close()
+    except BaseException:
+        tmpf.close()
+        os.unlink(tmpname)
+        raise
+    return tmpname
+
+
+#
+# Find working command-line tool
+#
+
+class ToolSetup:
+    def __init__(self, setup):
+        self.setup = setup
+
+    def check(self):
+        cmdline = self.get_cmdline("check_cmd", None)
+        try:
+            p = custom_popen(cmdline)
+            out, _ = p.communicate()
+            return p.returncode == 0
+        except RarCannotExec:
+            return False
+
+    def open_cmdline(self, pwd, rarfn, filefn=None):
+        cmdline = self.get_cmdline("open_cmd", pwd)
+        cmdline.append(rarfn)
+        if filefn:
+            self.add_file_arg(cmdline, filefn)
+        return cmdline
+
+    def get_errmap(self):
+        return self.setup["errmap"]
+
+    def get_cmdline(self, key, pwd, nodash=False):
+        cmdline = list(self.setup[key])
+        cmdline[0] = globals()[cmdline[0]]
+        self.add_password_arg(cmdline, pwd)
+        if not nodash:
+            cmdline.append("--")
+        return cmdline
+
+    def add_file_arg(self, cmdline, filename):
+        cmdline.append(filename)
+
+    def add_password_arg(self, cmdline, pwd):
+        """Append password switch to commandline.
+        """
+        if pwd is not None:
+            if not isinstance(pwd, str):
+                pwd = pwd.decode("utf8")
+            args = self.setup["password"]
+            if isinstance(args, str):
+                cmdline.append(args + pwd)
+            else:
+                cmdline.extend(args)
+                cmdline.append(pwd)
+        else:
+            cmdline.extend(self.setup["no_password"])
+
+
+UNRAR_CONFIG = {
+    "open_cmd": ("UNRAR_TOOL", "p", "-inul"),
+    "check_cmd": ("UNRAR_TOOL", "-inul"),
+    "password": "-p",
+    "no_password": ("-p-",),
+    # map return code to exception class, codes from rar.txt
+    "errmap": [None,
+               RarWarning, RarFatalError, RarCRCError, RarLockedArchiveError,    # 1..4
+               RarWriteError, RarOpenError, RarUserError, RarMemoryError,        # 5..8
+               RarCreateError, RarNoFilesError, RarWrongPassword]                # 9..11
+}
+
+# Problems with unar RAR backend:
+# - Does not support RAR2 locked files [fails to read]
+# - Does not support RAR5 Blake2sp hash [reading works]
+UNAR_CONFIG = {
+    "open_cmd": ("UNAR_TOOL", "-q", "-o", "-"),
+    "check_cmd": ("UNAR_TOOL", "-version"),
+    "password": ("-p",),
+    "no_password": ("-p", ""),
+    "errmap": [None],
+}
+
+# Problems with libarchive RAR backend:
+# - Does not support solid archives.
+# - Does not support password-protected archives.
+# - Does not support RARVM-based compression filters.
+BSDTAR_CONFIG = {
+    "open_cmd": ("BSDTAR_TOOL", "-x", "--to-stdout", "-f"),
+    "check_cmd": ("BSDTAR_TOOL", "--version"),
+    "password": None,
+    "no_password": (),
+    "errmap": [None],
+}
+
+CURRENT_SETUP = None
+
+
+def tool_setup(unrar=True, unar=True, bsdtar=True, force=False):
+    """Pick a tool, return cached ToolSetup.
+    """
+    global CURRENT_SETUP
+    if force:
+        CURRENT_SETUP = None
+    if CURRENT_SETUP is not None:
+        return CURRENT_SETUP
+    lst = []
+    if unrar:
+        lst.append(UNRAR_CONFIG)
+    if unar:
+        lst.append(UNAR_CONFIG)
+    if bsdtar:
+        lst.append(BSDTAR_CONFIG)
+
+    for conf in lst:
+        setup = ToolSetup(conf)
+        if setup.check():
+            CURRENT_SETUP = setup
+            break
+    if CURRENT_SETUP is None:
+        raise RarCannotExec("Cannot find working tool")
+    return CURRENT_SETUP
+
+
+def main(args):
+    """Minimal command-line interface for rarfile module.
+    """
+    import argparse
+    p = argparse.ArgumentParser(description=main.__doc__)
+    g = p.add_mutually_exclusive_group(required=True)
+    g.add_argument("-l", "--list", metavar="<rarfile>",
+                   help="Show archive listing")
+    g.add_argument("-e", "--extract", nargs=2,
+                   metavar=("<rarfile>", "<output_dir>"),
+                   help="Extract archive into target dir")
+    g.add_argument("-t", "--test", metavar="<rarfile>",
+                   help="Test if a archive is valid")
+    cmd = p.parse_args(args)
+
+    if cmd.list:
+        with RarFile(cmd.list) as rf:
+            rf.printdir()
+    elif cmd.test:
+        with RarFile(cmd.test) as rf:
+            rf.testrar()
+    elif cmd.extract:
+        with RarFile(cmd.extract[0]) as rf:
+            rf.extractall(cmd.extract[1])
+
+
+if __name__ == "__main__":
+    main(sys.argv[1:])
+
```

## toollib/common/zipfile.py

 * *Ordering differences only*

```diff
@@ -1,2179 +1,2179 @@
-"""
-Read and write ZIP files.
-
-XXX references to utf-8 need further investigation.
-"""
-import io
-import os
-import importlib.util
-import sys
-import time
-import stat
-import shutil
-import struct
-import binascii
-import threading
-
-try:
-    import zlib # We may need its compression method
-    crc32 = zlib.crc32
-except ImportError:
-    zlib = None
-    crc32 = binascii.crc32
-
-try:
-    import bz2 # We may need its compression method
-except ImportError:
-    bz2 = None
-
-try:
-    import lzma # We may need its compression method
-except ImportError:
-    lzma = None
-
-__all__ = ["BadZipFile", "BadZipfile", "error",
-           "ZIP_STORED", "ZIP_DEFLATED", "ZIP_BZIP2", "ZIP_LZMA",
-           "is_zipfile", "ZipInfo", "ZipFile", "PyZipFile", "LargeZipFile"]
-
-class BadZipFile(Exception):
-    pass
-
-
-class LargeZipFile(Exception):
-    """
-    Raised when writing a zipfile, the zipfile requires ZIP64 extensions
-    and those extensions are disabled.
-    """
-
-error = BadZipfile = BadZipFile      # Pre-3.2 compatibility names
-
-
-ZIP64_LIMIT = (1 << 31) - 1
-ZIP_FILECOUNT_LIMIT = (1 << 16) - 1
-ZIP_MAX_COMMENT = (1 << 16) - 1
-
-# constants for Zip file compression methods
-ZIP_STORED = 0
-ZIP_DEFLATED = 8
-ZIP_BZIP2 = 12
-ZIP_LZMA = 14
-# Other ZIP compression methods not supported
-
-DEFAULT_VERSION = 20
-ZIP64_VERSION = 45
-BZIP2_VERSION = 46
-LZMA_VERSION = 63
-# we recognize (but not necessarily support) all features up to that version
-MAX_EXTRACT_VERSION = 63
-
-# Below are some formats and associated data for reading/writing headers using
-# the struct module.  The names and structures of headers/records are those used
-# in the PKWARE description of the ZIP file format:
-#     http://www.pkware.com/documents/casestudies/APPNOTE.TXT
-# (URL valid as of January 2008)
-
-# The "end of central directory" structure, magic number, size, and indices
-# (section V.I in the format document)
-structEndArchive = b"<4s4H2LH"
-stringEndArchive = b"PK\005\006"
-sizeEndCentDir = struct.calcsize(structEndArchive)
-
-_ECD_SIGNATURE = 0
-_ECD_DISK_NUMBER = 1
-_ECD_DISK_START = 2
-_ECD_ENTRIES_THIS_DISK = 3
-_ECD_ENTRIES_TOTAL = 4
-_ECD_SIZE = 5
-_ECD_OFFSET = 6
-_ECD_COMMENT_SIZE = 7
-# These last two indices are not part of the structure as defined in the
-# spec, but they are used internally by this module as a convenience
-_ECD_COMMENT = 8
-_ECD_LOCATION = 9
-
-# The "central directory" structure, magic number, size, and indices
-# of entries in the structure (section V.F in the format document)
-structCentralDir = "<4s4B4HL2L5H2L"
-stringCentralDir = b"PK\001\002"
-sizeCentralDir = struct.calcsize(structCentralDir)
-
-# indexes of entries in the central directory structure
-_CD_SIGNATURE = 0
-_CD_CREATE_VERSION = 1
-_CD_CREATE_SYSTEM = 2
-_CD_EXTRACT_VERSION = 3
-_CD_EXTRACT_SYSTEM = 4
-_CD_FLAG_BITS = 5
-_CD_COMPRESS_TYPE = 6
-_CD_TIME = 7
-_CD_DATE = 8
-_CD_CRC = 9
-_CD_COMPRESSED_SIZE = 10
-_CD_UNCOMPRESSED_SIZE = 11
-_CD_FILENAME_LENGTH = 12
-_CD_EXTRA_FIELD_LENGTH = 13
-_CD_COMMENT_LENGTH = 14
-_CD_DISK_NUMBER_START = 15
-_CD_INTERNAL_FILE_ATTRIBUTES = 16
-_CD_EXTERNAL_FILE_ATTRIBUTES = 17
-_CD_LOCAL_HEADER_OFFSET = 18
-
-# The "local file header" structure, magic number, size, and indices
-# (section V.A in the format document)
-structFileHeader = "<4s2B4HL2L2H"
-stringFileHeader = b"PK\003\004"
-sizeFileHeader = struct.calcsize(structFileHeader)
-
-_FH_SIGNATURE = 0
-_FH_EXTRACT_VERSION = 1
-_FH_EXTRACT_SYSTEM = 2
-_FH_GENERAL_PURPOSE_FLAG_BITS = 3
-_FH_COMPRESSION_METHOD = 4
-_FH_LAST_MOD_TIME = 5
-_FH_LAST_MOD_DATE = 6
-_FH_CRC = 7
-_FH_COMPRESSED_SIZE = 8
-_FH_UNCOMPRESSED_SIZE = 9
-_FH_FILENAME_LENGTH = 10
-_FH_EXTRA_FIELD_LENGTH = 11
-
-# The "Zip64 end of central directory locator" structure, magic number, and size
-structEndArchive64Locator = "<4sLQL"
-stringEndArchive64Locator = b"PK\x06\x07"
-sizeEndCentDir64Locator = struct.calcsize(structEndArchive64Locator)
-
-# The "Zip64 end of central directory" record, magic number, size, and indices
-# (section V.G in the format document)
-structEndArchive64 = "<4sQ2H2L4Q"
-stringEndArchive64 = b"PK\x06\x06"
-sizeEndCentDir64 = struct.calcsize(structEndArchive64)
-
-_CD64_SIGNATURE = 0
-_CD64_DIRECTORY_RECSIZE = 1
-_CD64_CREATE_VERSION = 2
-_CD64_EXTRACT_VERSION = 3
-_CD64_DISK_NUMBER = 4
-_CD64_DISK_NUMBER_START = 5
-_CD64_NUMBER_ENTRIES_THIS_DISK = 6
-_CD64_NUMBER_ENTRIES_TOTAL = 7
-_CD64_DIRECTORY_SIZE = 8
-_CD64_OFFSET_START_CENTDIR = 9
-
-_DD_SIGNATURE = 0x08074b50
-
-_EXTRA_FIELD_STRUCT = struct.Struct('<HH')
-
-def _strip_extra(extra, xids):
-    # Remove Extra Fields with specified IDs.
-    unpack = _EXTRA_FIELD_STRUCT.unpack
-    modified = False
-    buffer = []
-    start = i = 0
-    while i + 4 <= len(extra):
-        xid, xlen = unpack(extra[i : i + 4])
-        j = i + 4 + xlen
-        if xid in xids:
-            if i != start:
-                buffer.append(extra[start : i])
-            start = j
-            modified = True
-        i = j
-    if not modified:
-        return extra
-    return b''.join(buffer)
-
-def _check_zipfile(fp):
-    try:
-        if _EndRecData(fp):
-            return True         # file has correct magic number
-    except OSError:
-        pass
-    return False
-
-def is_zipfile(filename):
-    """Quickly see if a file is a ZIP file by checking the magic number.
-
-    The filename argument may be a file or file-like object too.
-    """
-    result = False
-    try:
-        if hasattr(filename, "read"):
-            result = _check_zipfile(fp=filename)
-        else:
-            with open(filename, "rb") as fp:
-                result = _check_zipfile(fp)
-    except OSError:
-        pass
-    return result
-
-def _EndRecData64(fpin, offset, endrec):
-    """
-    Read the ZIP64 end-of-archive records and use that to update endrec
-    """
-    try:
-        fpin.seek(offset - sizeEndCentDir64Locator, 2)
-    except OSError:
-        # If the seek fails, the file is not large enough to contain a ZIP64
-        # end-of-archive record, so just return the end record we were given.
-        return endrec
-
-    data = fpin.read(sizeEndCentDir64Locator)
-    if len(data) != sizeEndCentDir64Locator:
-        return endrec
-    sig, diskno, reloff, disks = struct.unpack(structEndArchive64Locator, data)
-    if sig != stringEndArchive64Locator:
-        return endrec
-
-    if diskno != 0 or disks > 1:
-        raise BadZipFile("zipfiles that span multiple disks are not supported")
-
-    # Assume no 'zip64 extensible data'
-    fpin.seek(offset - sizeEndCentDir64Locator - sizeEndCentDir64, 2)
-    data = fpin.read(sizeEndCentDir64)
-    if len(data) != sizeEndCentDir64:
-        return endrec
-    sig, sz, create_version, read_version, disk_num, disk_dir, \
-        dircount, dircount2, dirsize, diroffset = \
-        struct.unpack(structEndArchive64, data)
-    if sig != stringEndArchive64:
-        return endrec
-
-    # Update the original endrec using data from the ZIP64 record
-    endrec[_ECD_SIGNATURE] = sig
-    endrec[_ECD_DISK_NUMBER] = disk_num
-    endrec[_ECD_DISK_START] = disk_dir
-    endrec[_ECD_ENTRIES_THIS_DISK] = dircount
-    endrec[_ECD_ENTRIES_TOTAL] = dircount2
-    endrec[_ECD_SIZE] = dirsize
-    endrec[_ECD_OFFSET] = diroffset
-    return endrec
-
-
-def _EndRecData(fpin):
-    """Return data from the "End of Central Directory" record, or None.
-
-    The data is a list of the nine items in the ZIP "End of central dir"
-    record followed by a tenth item, the file seek offset of this record."""
-
-    # Determine file size
-    fpin.seek(0, 2)
-    filesize = fpin.tell()
-
-    # Check to see if this is ZIP file with no archive comment (the
-    # "end of central directory" structure should be the last item in the
-    # file if this is the case).
-    try:
-        fpin.seek(-sizeEndCentDir, 2)
-    except OSError:
-        return None
-    data = fpin.read()
-    if (len(data) == sizeEndCentDir and
-        data[0:4] == stringEndArchive and
-        data[-2:] == b"\000\000"):
-        # the signature is correct and there's no comment, unpack structure
-        endrec = struct.unpack(structEndArchive, data)
-        endrec=list(endrec)
-
-        # Append a blank comment and record start offset
-        endrec.append(b"")
-        endrec.append(filesize - sizeEndCentDir)
-
-        # Try to read the "Zip64 end of central directory" structure
-        return _EndRecData64(fpin, -sizeEndCentDir, endrec)
-
-    # Either this is not a ZIP file, or it is a ZIP file with an archive
-    # comment.  Search the end of the file for the "end of central directory"
-    # record signature. The comment is the last item in the ZIP file and may be
-    # up to 64K long.  It is assumed that the "end of central directory" magic
-    # number does not appear in the comment.
-    maxCommentStart = max(filesize - (1 << 16) - sizeEndCentDir, 0)
-    fpin.seek(maxCommentStart, 0)
-    data = fpin.read()
-    start = data.rfind(stringEndArchive)
-    if start >= 0:
-        # found the magic number; attempt to unpack and interpret
-        recData = data[start:start+sizeEndCentDir]
-        if len(recData) != sizeEndCentDir:
-            # Zip file is corrupted.
-            return None
-        endrec = list(struct.unpack(structEndArchive, recData))
-        commentSize = endrec[_ECD_COMMENT_SIZE] #as claimed by the zip file
-        comment = data[start+sizeEndCentDir:start+sizeEndCentDir+commentSize]
-        endrec.append(comment)
-        endrec.append(maxCommentStart + start)
-
-        # Try to read the "Zip64 end of central directory" structure
-        return _EndRecData64(fpin, maxCommentStart + start - filesize,
-                             endrec)
-
-    # Unable to find a valid end of central directory structure
-    return None
-
-
-class ZipInfo (object):
-    """Class with attributes describing each file in the ZIP archive."""
-
-    __slots__ = (
-        'orig_filename',
-        'filename',
-        'date_time',
-        'compress_type',
-        '_compresslevel',
-        'comment',
-        'extra',
-        'create_system',
-        'create_version',
-        'extract_version',
-        'reserved',
-        'flag_bits',
-        'volume',
-        'internal_attr',
-        'external_attr',
-        'header_offset',
-        'CRC',
-        'compress_size',
-        'file_size',
-        '_raw_time',
-    )
-
-    def __init__(self, filename="NoName", date_time=(1980,1,1,0,0,0)):
-        self.orig_filename = filename   # Original file name in archive
-
-        # Terminate the file name at the first null byte.  Null bytes in file
-        # names are used as tricks by viruses in archives.
-        null_byte = filename.find(chr(0))
-        if null_byte >= 0:
-            filename = filename[0:null_byte]
-        # This is used to ensure paths in generated ZIP files always use
-        # forward slashes as the directory separator, as required by the
-        # ZIP format specification.
-        if os.sep != "/" and os.sep in filename:
-            filename = filename.replace(os.sep, "/")
-
-        self.filename = filename        # Normalized file name
-        self.date_time = date_time      # year, month, day, hour, min, sec
-
-        if date_time[0] < 1980:
-            raise ValueError('ZIP does not support timestamps before 1980')
-
-        # Standard values:
-        self.compress_type = ZIP_STORED # Type of compression for the file
-        self._compresslevel = None      # Level for the compressor
-        self.comment = b""              # Comment for each file
-        self.extra = b""                # ZIP extra data
-        if sys.platform == 'win32':
-            self.create_system = 0          # System which created ZIP archive
-        else:
-            # Assume everything else is unix-y
-            self.create_system = 3          # System which created ZIP archive
-        self.create_version = DEFAULT_VERSION  # Version which created ZIP archive
-        self.extract_version = DEFAULT_VERSION # Version needed to extract archive
-        self.reserved = 0               # Must be zero
-        self.flag_bits = 0              # ZIP flag bits
-        self.volume = 0                 # Volume number of file header
-        self.internal_attr = 0          # Internal attributes
-        self.external_attr = 0          # External file attributes
-        # Other attributes are set by class ZipFile:
-        # header_offset         Byte offset to the file header
-        # CRC                   CRC-32 of the uncompressed file
-        # compress_size         Size of the compressed file
-        # file_size             Size of the uncompressed file
-
-    def __repr__(self):
-        result = ['<%s filename=%r' % (self.__class__.__name__, self.filename)]
-        if self.compress_type != ZIP_STORED:
-            result.append(' compress_type=%s' %
-                          compressor_names.get(self.compress_type,
-                                               self.compress_type))
-        hi = self.external_attr >> 16
-        lo = self.external_attr & 0xFFFF
-        if hi:
-            result.append(' filemode=%r' % stat.filemode(hi))
-        if lo:
-            result.append(' external_attr=%#x' % lo)
-        isdir = self.is_dir()
-        if not isdir or self.file_size:
-            result.append(' file_size=%r' % self.file_size)
-        if ((not isdir or self.compress_size) and
-            (self.compress_type != ZIP_STORED or
-             self.file_size != self.compress_size)):
-            result.append(' compress_size=%r' % self.compress_size)
-        result.append('>')
-        return ''.join(result)
-
-    def FileHeader(self, zip64=None):
-        """Return the per-file header as a bytes object."""
-        dt = self.date_time
-        dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
-        dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
-        if self.flag_bits & 0x08:
-            # Set these to zero because we write them after the file data
-            CRC = compress_size = file_size = 0
-        else:
-            CRC = self.CRC
-            compress_size = self.compress_size
-            file_size = self.file_size
-
-        extra = self.extra
-
-        min_version = 0
-        if zip64 is None:
-            zip64 = file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT
-        if zip64:
-            fmt = '<HHQQ'
-            extra = extra + struct.pack(fmt,
-                                        1, struct.calcsize(fmt)-4, file_size, compress_size)
-        if file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT:
-            if not zip64:
-                raise LargeZipFile("Filesize would require ZIP64 extensions")
-            # File is larger than what fits into a 4 byte integer,
-            # fall back to the ZIP64 extension
-            file_size = 0xffffffff
-            compress_size = 0xffffffff
-            min_version = ZIP64_VERSION
-
-        if self.compress_type == ZIP_BZIP2:
-            min_version = max(BZIP2_VERSION, min_version)
-        elif self.compress_type == ZIP_LZMA:
-            min_version = max(LZMA_VERSION, min_version)
-
-        self.extract_version = max(min_version, self.extract_version)
-        self.create_version = max(min_version, self.create_version)
-        filename, flag_bits = self._encodeFilenameFlags()
-        header = struct.pack(structFileHeader, stringFileHeader,
-                             self.extract_version, self.reserved, flag_bits,
-                             self.compress_type, dostime, dosdate, CRC,
-                             compress_size, file_size,
-                             len(filename), len(extra))
-        return header + filename + extra
-
-    def _encodeFilenameFlags(self):
-        try:
-            return self.filename.encode('ascii'), self.flag_bits
-        except UnicodeEncodeError:
-            return self.filename.encode('utf-8'), self.flag_bits | 0x800
-
-    def _decodeExtra(self):
-        # Try to decode the extra field.
-        extra = self.extra
-        unpack = struct.unpack
-        while len(extra) >= 4:
-            tp, ln = unpack('<HH', extra[:4])
-            if ln+4 > len(extra):
-                raise BadZipFile("Corrupt extra field %04x (size=%d)" % (tp, ln))
-            if tp == 0x0001:
-                if ln >= 24:
-                    counts = unpack('<QQQ', extra[4:28])
-                elif ln == 16:
-                    counts = unpack('<QQ', extra[4:20])
-                elif ln == 8:
-                    counts = unpack('<Q', extra[4:12])
-                elif ln == 0:
-                    counts = ()
-                else:
-                    raise BadZipFile("Corrupt extra field %04x (size=%d)" % (tp, ln))
-
-                idx = 0
-
-                # ZIP64 extension (large files and/or large archives)
-                if self.file_size in (0xffffffffffffffff, 0xffffffff):
-                    if len(counts) <= idx:
-                        raise BadZipFile(
-                            "Corrupt zip64 extra field. File size not found."
-                        )
-                    self.file_size = counts[idx]
-                    idx += 1
-
-                if self.compress_size == 0xFFFFFFFF:
-                    if len(counts) <= idx:
-                        raise BadZipFile(
-                            "Corrupt zip64 extra field. Compress size not found."
-                        )
-                    self.compress_size = counts[idx]
-                    idx += 1
-
-                if self.header_offset == 0xffffffff:
-                    if len(counts) <= idx:
-                        raise BadZipFile(
-                            "Corrupt zip64 extra field. Header offset not found."
-                        )
-                    old = self.header_offset
-                    self.header_offset = counts[idx]
-                    idx+=1
-
-            extra = extra[ln+4:]
-
-    @classmethod
-    def from_file(cls, filename, arcname=None):
-        """Construct an appropriate ZipInfo for a file on the filesystem.
-
-        filename should be the path to a file or directory on the filesystem.
-
-        arcname is the name which it will have within the archive (by default,
-        this will be the same as filename, but without a drive letter and with
-        leading path separators removed).
-        """
-        if isinstance(filename, os.PathLike):
-            filename = os.fspath(filename)
-        st = os.stat(filename)
-        isdir = stat.S_ISDIR(st.st_mode)
-        mtime = time.localtime(st.st_mtime)
-        date_time = mtime[0:6]
-        # Create ZipInfo instance to store file information
-        if arcname is None:
-            arcname = filename
-        arcname = os.path.normpath(os.path.splitdrive(arcname)[1])
-        while arcname[0] in (os.sep, os.altsep):
-            arcname = arcname[1:]
-        if isdir:
-            arcname += '/'
-        zinfo = cls(arcname, date_time)
-        zinfo.external_attr = (st.st_mode & 0xFFFF) << 16  # Unix attributes
-        if isdir:
-            zinfo.file_size = 0
-            zinfo.external_attr |= 0x10  # MS-DOS directory flag
-        else:
-            zinfo.file_size = st.st_size
-
-        return zinfo
-
-    def is_dir(self):
-        """Return True if this archive member is a directory."""
-        return self.filename[-1] == '/'
-
-
-# ZIP encryption uses the CRC32 one-byte primitive for scrambling some
-# internal keys. We noticed that a direct implementation is faster than
-# relying on binascii.crc32().
-
-_crctable = None
-def _gen_crc(crc):
-    for j in range(8):
-        if crc & 1:
-            crc = (crc >> 1) ^ 0xEDB88320
-        else:
-            crc >>= 1
-    return crc
-
-# ZIP supports a password-based form of encryption. Even though known
-# plaintext attacks have been found against it, it is still useful
-# to be able to get data out of such a file.
-#
-# Usage:
-#     zd = _ZipDecrypter(mypwd)
-#     plain_bytes = zd(cypher_bytes)
-
-def _ZipDecrypter(pwd):
-    key0 = 305419896
-    key1 = 591751049
-    key2 = 878082192
-
-    global _crctable
-    if _crctable is None:
-        _crctable = list(map(_gen_crc, range(256)))
-    crctable = _crctable
-
-    def crc32(ch, crc):
-        """Compute the CRC32 primitive on one byte."""
-        return (crc >> 8) ^ crctable[(crc ^ ch) & 0xFF]
-
-    def update_keys(c):
-        nonlocal key0, key1, key2
-        key0 = crc32(c, key0)
-        key1 = (key1 + (key0 & 0xFF)) & 0xFFFFFFFF
-        key1 = (key1 * 134775813 + 1) & 0xFFFFFFFF
-        key2 = crc32(key1 >> 24, key2)
-
-    for p in pwd:
-        update_keys(p)
-
-    def decrypter(data):
-        """Decrypt a bytes object."""
-        result = bytearray()
-        append = result.append
-        for c in data:
-            k = key2 | 2
-            c ^= ((k * (k^1)) >> 8) & 0xFF
-            update_keys(c)
-            append(c)
-        return bytes(result)
-
-    return decrypter
-
-
-class LZMACompressor:
-
-    def __init__(self):
-        self._comp = None
-
-    def _init(self):
-        props = lzma._encode_filter_properties({'id': lzma.FILTER_LZMA1})
-        self._comp = lzma.LZMACompressor(lzma.FORMAT_RAW, filters=[
-            lzma._decode_filter_properties(lzma.FILTER_LZMA1, props)
-        ])
-        return struct.pack('<BBH', 9, 4, len(props)) + props
-
-    def compress(self, data):
-        if self._comp is None:
-            return self._init() + self._comp.compress(data)
-        return self._comp.compress(data)
-
-    def flush(self):
-        if self._comp is None:
-            return self._init() + self._comp.flush()
-        return self._comp.flush()
-
-
-class LZMADecompressor:
-
-    def __init__(self):
-        self._decomp = None
-        self._unconsumed = b''
-        self.eof = False
-
-    def decompress(self, data):
-        if self._decomp is None:
-            self._unconsumed += data
-            if len(self._unconsumed) <= 4:
-                return b''
-            psize, = struct.unpack('<H', self._unconsumed[2:4])
-            if len(self._unconsumed) <= 4 + psize:
-                return b''
-
-            self._decomp = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[
-                lzma._decode_filter_properties(lzma.FILTER_LZMA1,
-                                               self._unconsumed[4:4 + psize])
-            ])
-            data = self._unconsumed[4 + psize:]
-            del self._unconsumed
-
-        result = self._decomp.decompress(data)
-        self.eof = self._decomp.eof
-        return result
-
-
-compressor_names = {
-    0: 'store',
-    1: 'shrink',
-    2: 'reduce',
-    3: 'reduce',
-    4: 'reduce',
-    5: 'reduce',
-    6: 'implode',
-    7: 'tokenize',
-    8: 'deflate',
-    9: 'deflate64',
-    10: 'implode',
-    12: 'bzip2',
-    14: 'lzma',
-    18: 'terse',
-    19: 'lz77',
-    97: 'wavpack',
-    98: 'ppmd',
-}
-
-def _check_compression(compression):
-    if compression == ZIP_STORED:
-        pass
-    elif compression == ZIP_DEFLATED:
-        if not zlib:
-            raise RuntimeError(
-                "Compression requires the (missing) zlib module")
-    elif compression == ZIP_BZIP2:
-        if not bz2:
-            raise RuntimeError(
-                "Compression requires the (missing) bz2 module")
-    elif compression == ZIP_LZMA:
-        if not lzma:
-            raise RuntimeError(
-                "Compression requires the (missing) lzma module")
-    else:
-        raise NotImplementedError("That compression method is not supported")
-
-
-def _get_compressor(compress_type, compresslevel=None):
-    if compress_type == ZIP_DEFLATED:
-        if compresslevel is not None:
-            return zlib.compressobj(compresslevel, zlib.DEFLATED, -15)
-        return zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION, zlib.DEFLATED, -15)
-    elif compress_type == ZIP_BZIP2:
-        if compresslevel is not None:
-            return bz2.BZ2Compressor(compresslevel)
-        return bz2.BZ2Compressor()
-    # compresslevel is ignored for ZIP_LZMA
-    elif compress_type == ZIP_LZMA:
-        return LZMACompressor()
-    else:
-        return None
-
-
-def _get_decompressor(compress_type):
-    if compress_type == ZIP_STORED:
-        return None
-    elif compress_type == ZIP_DEFLATED:
-        return zlib.decompressobj(-15)
-    elif compress_type == ZIP_BZIP2:
-        return bz2.BZ2Decompressor()
-    elif compress_type == ZIP_LZMA:
-        return LZMADecompressor()
-    else:
-        descr = compressor_names.get(compress_type)
-        if descr:
-            raise NotImplementedError("compression type %d (%s)" % (compress_type, descr))
-        else:
-            raise NotImplementedError("compression type %d" % (compress_type,))
-
-
-class _SharedFile:
-    def __init__(self, file, pos, close, lock, writing):
-        self._file = file
-        self._pos = pos
-        self._close = close
-        self._lock = lock
-        self._writing = writing
-        self.seekable = file.seekable
-        self.tell = file.tell
-
-    def seek(self, offset, whence=0):
-        with self._lock:
-            if self._writing():
-                raise ValueError("Can't reposition in the ZIP file while "
-                        "there is an open writing handle on it. "
-                        "Close the writing handle before trying to read.")
-            self._file.seek(offset, whence)
-            self._pos = self._file.tell()
-            return self._pos
-
-    def read(self, n=-1):
-        with self._lock:
-            if self._writing():
-                raise ValueError("Can't read from the ZIP file while there "
-                        "is an open writing handle on it. "
-                        "Close the writing handle before trying to read.")
-            self._file.seek(self._pos)
-            data = self._file.read(n)
-            self._pos = self._file.tell()
-            return data
-
-    def close(self):
-        if self._file is not None:
-            fileobj = self._file
-            self._file = None
-            self._close(fileobj)
-
-# Provide the tell method for unseekable stream
-class _Tellable:
-    def __init__(self, fp):
-        self.fp = fp
-        self.offset = 0
-
-    def write(self, data):
-        n = self.fp.write(data)
-        self.offset += n
-        return n
-
-    def tell(self):
-        return self.offset
-
-    def flush(self):
-        self.fp.flush()
-
-    def close(self):
-        self.fp.close()
-
-
-class ZipExtFile(io.BufferedIOBase):
-    """File-like object for reading an archive member.
-       Is returned by ZipFile.open().
-    """
-
-    # Max size supported by decompressor.
-    MAX_N = 1 << 31 - 1
-
-    # Read from compressed files in 4k blocks.
-    MIN_READ_SIZE = 4096
-
-    # Chunk size to read during seek
-    MAX_SEEK_READ = 1 << 24
-
-    def __init__(self, fileobj, mode, zipinfo, pwd=None,
-                 close_fileobj=False):
-        self._fileobj = fileobj
-        self._pwd = pwd
-        self._close_fileobj = close_fileobj
-
-        self._compress_type = zipinfo.compress_type
-        self._compress_left = zipinfo.compress_size
-        self._left = zipinfo.file_size
-
-        self._decompressor = _get_decompressor(self._compress_type)
-
-        self._eof = False
-        self._readbuffer = b''
-        self._offset = 0
-
-        self.newlines = None
-
-        self.mode = mode
-        self.name = zipinfo.filename
-
-        if hasattr(zipinfo, 'CRC'):
-            self._expected_crc = zipinfo.CRC
-            self._running_crc = crc32(b'')
-        else:
-            self._expected_crc = None
-
-        self._seekable = False
-        try:
-            if fileobj.seekable():
-                self._orig_compress_start = fileobj.tell()
-                self._orig_compress_size = zipinfo.compress_size
-                self._orig_file_size = zipinfo.file_size
-                self._orig_start_crc = self._running_crc
-                self._seekable = True
-        except AttributeError:
-            pass
-
-        self._decrypter = None
-        if pwd:
-            if zipinfo.flag_bits & 0x8:
-                # compare against the file type from extended local headers
-                check_byte = (zipinfo._raw_time >> 8) & 0xff
-            else:
-                # compare against the CRC otherwise
-                check_byte = (zipinfo.CRC >> 24) & 0xff
-            h = self._init_decrypter()
-            if h != check_byte:
-                raise RuntimeError("Bad password for file %r" % zipinfo.orig_filename)
-
-
-    def _init_decrypter(self):
-        self._decrypter = _ZipDecrypter(self._pwd)
-        # The first 12 bytes in the cypher stream is an encryption header
-        #  used to strengthen the algorithm. The first 11 bytes are
-        #  completely random, while the 12th contains the MSB of the CRC,
-        #  or the MSB of the file time depending on the header type
-        #  and is used to check the correctness of the password.
-        header = self._fileobj.read(12)
-        self._compress_left -= 12
-        return self._decrypter(header)[11]
-
-    def __repr__(self):
-        result = ['<%s.%s' % (self.__class__.__module__,
-                              self.__class__.__qualname__)]
-        if not self.closed:
-            result.append(' name=%r mode=%r' % (self.name, self.mode))
-            if self._compress_type != ZIP_STORED:
-                result.append(' compress_type=%s' %
-                              compressor_names.get(self._compress_type,
-                                                   self._compress_type))
-        else:
-            result.append(' [closed]')
-        result.append('>')
-        return ''.join(result)
-
-    def readline(self, limit=-1):
-        """Read and return a line from the stream.
-
-        If limit is specified, at most limit bytes will be read.
-        """
-
-        if limit < 0:
-            # Shortcut common case - newline found in buffer.
-            i = self._readbuffer.find(b'\n', self._offset) + 1
-            if i > 0:
-                line = self._readbuffer[self._offset: i]
-                self._offset = i
-                return line
-
-        return io.BufferedIOBase.readline(self, limit)
-
-    def peek(self, n=1):
-        """Returns buffered bytes without advancing the position."""
-        if n > len(self._readbuffer) - self._offset:
-            chunk = self.read(n)
-            if len(chunk) > self._offset:
-                self._readbuffer = chunk + self._readbuffer[self._offset:]
-                self._offset = 0
-            else:
-                self._offset -= len(chunk)
-
-        # Return up to 512 bytes to reduce allocation overhead for tight loops.
-        return self._readbuffer[self._offset: self._offset + 512]
-
-    def readable(self):
-        return True
-
-    def read(self, n=-1):
-        """Read and return up to n bytes.
-        If the argument is omitted, None, or negative, data is read and returned until EOF is reached.
-        """
-        if n is None or n < 0:
-            buf = self._readbuffer[self._offset:]
-            self._readbuffer = b''
-            self._offset = 0
-            while not self._eof:
-                buf += self._read1(self.MAX_N)
-            return buf
-
-        end = n + self._offset
-        if end < len(self._readbuffer):
-            buf = self._readbuffer[self._offset:end]
-            self._offset = end
-            return buf
-
-        n = end - len(self._readbuffer)
-        buf = self._readbuffer[self._offset:]
-        self._readbuffer = b''
-        self._offset = 0
-        while n > 0 and not self._eof:
-            data = self._read1(n)
-            if n < len(data):
-                self._readbuffer = data
-                self._offset = n
-                buf += data[:n]
-                break
-            buf += data
-            n -= len(data)
-        return buf
-
-    def _update_crc(self, newdata):
-        # Update the CRC using the given data.
-        if self._expected_crc is None:
-            # No need to compute the CRC if we don't have a reference value
-            return
-        self._running_crc = crc32(newdata, self._running_crc)
-        # Check the CRC if we're at the end of the file
-        if self._eof and self._running_crc != self._expected_crc:
-            raise BadZipFile("Bad CRC-32 for file %r" % self.name)
-
-    def read1(self, n):
-        """Read up to n bytes with at most one read() system call."""
-
-        if n is None or n < 0:
-            buf = self._readbuffer[self._offset:]
-            self._readbuffer = b''
-            self._offset = 0
-            while not self._eof:
-                data = self._read1(self.MAX_N)
-                if data:
-                    buf += data
-                    break
-            return buf
-
-        end = n + self._offset
-        if end < len(self._readbuffer):
-            buf = self._readbuffer[self._offset:end]
-            self._offset = end
-            return buf
-
-        n = end - len(self._readbuffer)
-        buf = self._readbuffer[self._offset:]
-        self._readbuffer = b''
-        self._offset = 0
-        if n > 0:
-            while not self._eof:
-                data = self._read1(n)
-                if n < len(data):
-                    self._readbuffer = data
-                    self._offset = n
-                    buf += data[:n]
-                    break
-                if data:
-                    buf += data
-                    break
-        return buf
-
-    def _read1(self, n):
-        # Read up to n compressed bytes with at most one read() system call,
-        # decrypt and decompress them.
-        if self._eof or n <= 0:
-            return b''
-
-        # Read from file.
-        if self._compress_type == ZIP_DEFLATED:
-            ## Handle unconsumed data.
-            data = self._decompressor.unconsumed_tail
-            if n > len(data):
-                data += self._read2(n - len(data))
-        else:
-            data = self._read2(n)
-
-        if self._compress_type == ZIP_STORED:
-            self._eof = self._compress_left <= 0
-        elif self._compress_type == ZIP_DEFLATED:
-            n = max(n, self.MIN_READ_SIZE)
-            data = self._decompressor.decompress(data, n)
-            self._eof = (self._decompressor.eof or
-                         self._compress_left <= 0 and
-                         not self._decompressor.unconsumed_tail)
-            if self._eof:
-                data += self._decompressor.flush()
-        else:
-            data = self._decompressor.decompress(data)
-            self._eof = self._decompressor.eof or self._compress_left <= 0
-
-        data = data[:self._left]
-        self._left -= len(data)
-        if self._left <= 0:
-            self._eof = True
-        self._update_crc(data)
-        return data
-
-    def _read2(self, n):
-        if self._compress_left <= 0:
-            return b''
-
-        n = max(n, self.MIN_READ_SIZE)
-        n = min(n, self._compress_left)
-
-        data = self._fileobj.read(n)
-        self._compress_left -= len(data)
-        if not data:
-            raise EOFError
-
-        if self._decrypter is not None:
-            data = self._decrypter(data)
-        return data
-
-    def close(self):
-        try:
-            if self._close_fileobj:
-                self._fileobj.close()
-        finally:
-            super().close()
-
-    def seekable(self):
-        return self._seekable
-
-    def seek(self, offset, whence=0):
-        if not self._seekable:
-            raise io.UnsupportedOperation("underlying stream is not seekable")
-        curr_pos = self.tell()
-        if whence == 0: # Seek from start of file
-            new_pos = offset
-        elif whence == 1: # Seek from current position
-            new_pos = curr_pos + offset
-        elif whence == 2: # Seek from EOF
-            new_pos = self._orig_file_size + offset
-        else:
-            raise ValueError("whence must be os.SEEK_SET (0), "
-                             "os.SEEK_CUR (1), or os.SEEK_END (2)")
-
-        if new_pos > self._orig_file_size:
-            new_pos = self._orig_file_size
-
-        if new_pos < 0:
-            new_pos = 0
-
-        read_offset = new_pos - curr_pos
-        buff_offset = read_offset + self._offset
-
-        if buff_offset >= 0 and buff_offset < len(self._readbuffer):
-            # Just move the _offset index if the new position is in the _readbuffer
-            self._offset = buff_offset
-            read_offset = 0
-        elif read_offset < 0:
-            # Position is before the current position. Reset the ZipExtFile
-            self._fileobj.seek(self._orig_compress_start)
-            self._running_crc = self._orig_start_crc
-            self._compress_left = self._orig_compress_size
-            self._left = self._orig_file_size
-            self._readbuffer = b''
-            self._offset = 0
-            self._decompressor = _get_decompressor(self._compress_type)
-            self._eof = False
-            read_offset = new_pos
-            if self._decrypter is not None:
-                self._init_decrypter()
-
-        while read_offset > 0:
-            read_len = min(self.MAX_SEEK_READ, read_offset)
-            self.read(read_len)
-            read_offset -= read_len
-
-        return self.tell()
-
-    def tell(self):
-        if not self._seekable:
-            raise io.UnsupportedOperation("underlying stream is not seekable")
-        filepos = self._orig_file_size - self._left - len(self._readbuffer) + self._offset
-        return filepos
-
-
-class _ZipWriteFile(io.BufferedIOBase):
-    def __init__(self, zf, zinfo, zip64):
-        self._zinfo = zinfo
-        self._zip64 = zip64
-        self._zipfile = zf
-        self._compressor = _get_compressor(zinfo.compress_type,
-                                           zinfo._compresslevel)
-        self._file_size = 0
-        self._compress_size = 0
-        self._crc = 0
-
-    @property
-    def _fileobj(self):
-        return self._zipfile.fp
-
-    def writable(self):
-        return True
-
-    def write(self, data):
-        if self.closed:
-            raise ValueError('I/O operation on closed file.')
-        nbytes = len(data)
-        self._file_size += nbytes
-        self._crc = crc32(data, self._crc)
-        if self._compressor:
-            data = self._compressor.compress(data)
-            self._compress_size += len(data)
-        self._fileobj.write(data)
-        return nbytes
-
-    def close(self):
-        if self.closed:
-            return
-        try:
-            super().close()
-            # Flush any data from the compressor, and update header info
-            if self._compressor:
-                buf = self._compressor.flush()
-                self._compress_size += len(buf)
-                self._fileobj.write(buf)
-                self._zinfo.compress_size = self._compress_size
-            else:
-                self._zinfo.compress_size = self._file_size
-            self._zinfo.CRC = self._crc
-            self._zinfo.file_size = self._file_size
-
-            # Write updated header info
-            if self._zinfo.flag_bits & 0x08:
-                # Write CRC and file sizes after the file data
-                fmt = '<LLQQ' if self._zip64 else '<LLLL'
-                self._fileobj.write(struct.pack(fmt, _DD_SIGNATURE, self._zinfo.CRC,
-                    self._zinfo.compress_size, self._zinfo.file_size))
-                self._zipfile.start_dir = self._fileobj.tell()
-            else:
-                if not self._zip64:
-                    if self._file_size > ZIP64_LIMIT:
-                        raise RuntimeError(
-                            'File size unexpectedly exceeded ZIP64 limit')
-                    if self._compress_size > ZIP64_LIMIT:
-                        raise RuntimeError(
-                            'Compressed size unexpectedly exceeded ZIP64 limit')
-                # Seek backwards and write file header (which will now include
-                # correct CRC and file sizes)
-
-                # Preserve current position in file
-                self._zipfile.start_dir = self._fileobj.tell()
-                self._fileobj.seek(self._zinfo.header_offset)
-                self._fileobj.write(self._zinfo.FileHeader(self._zip64))
-                self._fileobj.seek(self._zipfile.start_dir)
-
-            # Successfully written: Add file to our caches
-            self._zipfile.filelist.append(self._zinfo)
-            self._zipfile.NameToInfo[self._zinfo.filename] = self._zinfo
-        finally:
-            self._zipfile._writing = False
-
-
-
-class ZipFile:
-    """ Class with methods to open, read, write, close, list zip files.
-
-    z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
-                compresslevel=None)
-
-    file: Either the path to the file, or a file-like object.
-          If it is a path, the file will be opened and closed by ZipFile.
-    mode: The mode can be either read 'r', write 'w', exclusive create 'x',
-          or append 'a'.
-    compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
-                 ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
-    allowZip64: if True ZipFile will create files with ZIP64 extensions when
-                needed, otherwise it will raise an exception when this would
-                be necessary.
-    compresslevel: None (default for the given compression type) or an integer
-                   specifying the level to pass to the compressor.
-                   When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
-                   When using ZIP_DEFLATED integers 0 through 9 are accepted.
-                   When using ZIP_BZIP2 integers 1 through 9 are accepted.
-
-    """
-
-    fp = None                   # Set here since __del__ checks it
-    _windows_illegal_name_trans_table = None
-
-    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
-                 compresslevel=None):
-        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
-        or append 'a'."""
-        if mode not in ('r', 'w', 'x', 'a'):
-            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")
-
-        _check_compression(compression)
-
-        self._allowZip64 = allowZip64
-        self._didModify = False
-        self.debug = 0  # Level of printing: 0 through 3
-        self.NameToInfo = {}    # Find file info given name
-        self.filelist = []      # List of ZipInfo instances for archive
-        self.compression = compression  # Method of compression
-        self.compresslevel = compresslevel
-        self.mode = mode
-        self.pwd = None
-        self._comment = b''
-
-        # Check if we were passed a file-like object
-        if isinstance(file, os.PathLike):
-            file = os.fspath(file)
-        if isinstance(file, str):
-            # No, it's a filename
-            self._filePassed = 0
-            self.filename = file
-            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
-                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
-            filemode = modeDict[mode]
-            while True:
-                try:
-                    self.fp = io.open(file, filemode)
-                except OSError:
-                    if filemode in modeDict:
-                        filemode = modeDict[filemode]
-                        continue
-                    raise
-                break
-        else:
-            self._filePassed = 1
-            self.fp = file
-            self.filename = getattr(file, 'name', None)
-        self._fileRefCnt = 1
-        self._lock = threading.RLock()
-        self._seekable = True
-        self._writing = False
-
-        try:
-            if mode == 'r':
-                self._RealGetContents()
-            elif mode in ('w', 'x'):
-                # set the modified flag so central directory gets written
-                # even if no files are added to the archive
-                self._didModify = True
-                try:
-                    self.start_dir = self.fp.tell()
-                except (AttributeError, OSError):
-                    self.fp = _Tellable(self.fp)
-                    self.start_dir = 0
-                    self._seekable = False
-                else:
-                    # Some file-like objects can provide tell() but not seek()
-                    try:
-                        self.fp.seek(self.start_dir)
-                    except (AttributeError, OSError):
-                        self._seekable = False
-            elif mode == 'a':
-                try:
-                    # See if file is a zip file
-                    self._RealGetContents()
-                    # seek to start of directory and overwrite
-                    self.fp.seek(self.start_dir)
-                except BadZipFile:
-                    # file is not a zip file, just append
-                    self.fp.seek(0, 2)
-
-                    # set the modified flag so central directory gets written
-                    # even if no files are added to the archive
-                    self._didModify = True
-                    self.start_dir = self.fp.tell()
-            else:
-                raise ValueError("Mode must be 'r', 'w', 'x', or 'a'")
-        except:
-            fp = self.fp
-            self.fp = None
-            self._fpclose(fp)
-            raise
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, type, value, traceback):
-        self.close()
-
-    def __repr__(self):
-        result = ['<%s.%s' % (self.__class__.__module__,
-                              self.__class__.__qualname__)]
-        if self.fp is not None:
-            if self._filePassed:
-                result.append(' file=%r' % self.fp)
-            elif self.filename is not None:
-                result.append(' filename=%r' % self.filename)
-            result.append(' mode=%r' % self.mode)
-        else:
-            result.append(' [closed]')
-        result.append('>')
-        return ''.join(result)
-
-    def _RealGetContents(self):
-        """Read in the table of contents for the ZIP file."""
-        fp = self.fp
-        try:
-            endrec = _EndRecData(fp)
-        except OSError:
-            raise BadZipFile("File is not a zip file")
-        if not endrec:
-            raise BadZipFile("File is not a zip file")
-        if self.debug > 1:
-            print(endrec)
-        size_cd = endrec[_ECD_SIZE]             # bytes in central directory
-        offset_cd = endrec[_ECD_OFFSET]         # offset of central directory
-        self._comment = endrec[_ECD_COMMENT]    # archive comment
-
-        # "concat" is zero, unless zip was concatenated to another file
-        concat = endrec[_ECD_LOCATION] - size_cd - offset_cd
-        if endrec[_ECD_SIGNATURE] == stringEndArchive64:
-            # If Zip64 extension structures are present, account for them
-            concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)
-
-        if self.debug > 2:
-            inferred = concat + offset_cd
-            print("given, inferred, offset", offset_cd, inferred, concat)
-        # self.start_dir:  Position of start of central directory
-        self.start_dir = offset_cd + concat
-        fp.seek(self.start_dir, 0)
-        data = fp.read(size_cd)
-        fp = io.BytesIO(data)
-        total = 0
-        while total < size_cd:
-            centdir = fp.read(sizeCentralDir)
-            if len(centdir) != sizeCentralDir:
-                raise BadZipFile("Truncated central directory")
-            centdir = struct.unpack(structCentralDir, centdir)
-            if centdir[_CD_SIGNATURE] != stringCentralDir:
-                raise BadZipFile("Bad magic number for central directory")
-            if self.debug > 2:
-                print(centdir)
-            filename = fp.read(centdir[_CD_FILENAME_LENGTH])
-            flags = centdir[5]
-            if flags & 0x800:
-                # UTF-8 file names extension
-                filename = filename.decode('utf-8')
-            else:
-                # Historical ZIP filename encoding
-                # filename = filename.decode('cp437')
-                filename = filename.decode('gbk')
-            # Create ZipInfo instance to store file information
-            x = ZipInfo(filename)
-            x.extra = fp.read(centdir[_CD_EXTRA_FIELD_LENGTH])
-            x.comment = fp.read(centdir[_CD_COMMENT_LENGTH])
-            x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]
-            (x.create_version, x.create_system, x.extract_version, x.reserved,
-             x.flag_bits, x.compress_type, t, d,
-             x.CRC, x.compress_size, x.file_size) = centdir[1:12]
-            if x.extract_version > MAX_EXTRACT_VERSION:
-                raise NotImplementedError("zip file version %.1f" %
-                                          (x.extract_version / 10))
-            x.volume, x.internal_attr, x.external_attr = centdir[15:18]
-            # Convert date/time code to (year, month, day, hour, min, sec)
-            x._raw_time = t
-            x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,
-                            t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )
-
-            x._decodeExtra()
-            x.header_offset = x.header_offset + concat
-            self.filelist.append(x)
-            self.NameToInfo[x.filename] = x
-
-            # update total bytes read from central directory
-            total = (total + sizeCentralDir + centdir[_CD_FILENAME_LENGTH]
-                     + centdir[_CD_EXTRA_FIELD_LENGTH]
-                     + centdir[_CD_COMMENT_LENGTH])
-
-            if self.debug > 2:
-                print("total", total)
-
-
-    def namelist(self):
-        """Return a list of file names in the archive."""
-        return [data.filename for data in self.filelist]
-
-    def infolist(self):
-        """Return a list of class ZipInfo instances for files in the
-        archive."""
-        return self.filelist
-
-    def printdir(self, file=None):
-        """Print a table of contents for the zip file."""
-        print("%-46s %19s %12s" % ("File Name", "Modified    ", "Size"),
-              file=file)
-        for zinfo in self.filelist:
-            date = "%d-%02d-%02d %02d:%02d:%02d" % zinfo.date_time[:6]
-            print("%-46s %s %12d" % (zinfo.filename, date, zinfo.file_size),
-                  file=file)
-
-    def testzip(self):
-        """Read all the files and check the CRC."""
-        chunk_size = 2 ** 20
-        for zinfo in self.filelist:
-            try:
-                # Read by chunks, to avoid an OverflowError or a
-                # MemoryError with very large embedded files.
-                with self.open(zinfo.filename, "r") as f:
-                    while f.read(chunk_size):     # Check CRC-32
-                        pass
-            except BadZipFile:
-                return zinfo.filename
-
-    def getinfo(self, name):
-        """Return the instance of ZipInfo given 'name'."""
-        info = self.NameToInfo.get(name)
-        if info is None:
-            raise KeyError(
-                'There is no item named %r in the archive' % name)
-
-        return info
-
-    def setpassword(self, pwd):
-        """Set default password for encrypted files."""
-        if pwd and not isinstance(pwd, bytes):
-            raise TypeError("pwd: expected bytes, got %s" % type(pwd).__name__)
-        if pwd:
-            self.pwd = pwd
-        else:
-            self.pwd = None
-
-    @property
-    def comment(self):
-        """The comment text associated with the ZIP file."""
-        return self._comment
-
-    @comment.setter
-    def comment(self, comment):
-        if not isinstance(comment, bytes):
-            raise TypeError("comment: expected bytes, got %s" % type(comment).__name__)
-        # check for valid comment length
-        if len(comment) > ZIP_MAX_COMMENT:
-            import warnings
-            warnings.warn('Archive comment is too long; truncating to %d bytes'
-                          % ZIP_MAX_COMMENT, stacklevel=2)
-            comment = comment[:ZIP_MAX_COMMENT]
-        self._comment = comment
-        self._didModify = True
-
-    def read(self, name, pwd=None):
-        """Return file bytes for name."""
-        with self.open(name, "r", pwd) as fp:
-            return fp.read()
-
-    def open(self, name, mode="r", pwd=None, *, force_zip64=False):
-        """Return file-like object for 'name'.
-
-        name is a string for the file name within the ZIP file, or a ZipInfo
-        object.
-
-        mode should be 'r' to read a file already in the ZIP file, or 'w' to
-        write to a file newly added to the archive.
-
-        pwd is the password to decrypt files (only used for reading).
-
-        When writing, if the file size is not known in advance but may exceed
-        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
-        files.  If the size is known in advance, it is best to pass a ZipInfo
-        instance for name, with zinfo.file_size set.
-        """
-        if mode not in {"r", "w"}:
-            raise ValueError('open() requires mode "r" or "w"')
-        if pwd and not isinstance(pwd, bytes):
-            raise TypeError("pwd: expected bytes, got %s" % type(pwd).__name__)
-        if pwd and (mode == "w"):
-            raise ValueError("pwd is only supported for reading files")
-        if not self.fp:
-            raise ValueError(
-                "Attempt to use ZIP archive that was already closed")
-
-        # Make sure we have an info object
-        if isinstance(name, ZipInfo):
-            # 'name' is already an info object
-            zinfo = name
-        elif mode == 'w':
-            zinfo = ZipInfo(name)
-            zinfo.compress_type = self.compression
-            zinfo._compresslevel = self.compresslevel
-        else:
-            # Get info object for name
-            zinfo = self.getinfo(name)
-
-        if mode == 'w':
-            return self._open_to_write(zinfo, force_zip64=force_zip64)
-
-        if self._writing:
-            raise ValueError("Can't read from the ZIP file while there "
-                    "is an open writing handle on it. "
-                    "Close the writing handle before trying to read.")
-
-        # Open for reading:
-        self._fileRefCnt += 1
-        zef_file = _SharedFile(self.fp, zinfo.header_offset,
-                               self._fpclose, self._lock, lambda: self._writing)
-        try:
-            # Skip the file header:
-            fheader = zef_file.read(sizeFileHeader)
-            if len(fheader) != sizeFileHeader:
-                raise BadZipFile("Truncated file header")
-            fheader = struct.unpack(structFileHeader, fheader)
-            if fheader[_FH_SIGNATURE] != stringFileHeader:
-                raise BadZipFile("Bad magic number for file header")
-
-            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])
-            if fheader[_FH_EXTRA_FIELD_LENGTH]:
-                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])
-
-            if zinfo.flag_bits & 0x20:
-                # Zip 2.7: compressed patched data
-                raise NotImplementedError("compressed patched data (flag bit 5)")
-
-            if zinfo.flag_bits & 0x40:
-                # strong encryption
-                raise NotImplementedError("strong encryption (flag bit 6)")
-
-            if zinfo.flag_bits & 0x800:
-                # UTF-8 filename
-                fname_str = fname.decode("utf-8")
-            else:
-                # fname_str = fname.decode("cp437")
-                fname_str = fname.decode("gbk")
-
-            if fname_str != zinfo.orig_filename:
-                raise BadZipFile(
-                    'File name in directory %r and header %r differ.'
-                    % (zinfo.orig_filename, fname))
-
-            # check for encrypted flag & handle password
-            is_encrypted = zinfo.flag_bits & 0x1
-            if is_encrypted:
-                if not pwd:
-                    pwd = self.pwd
-                if not pwd:
-                    raise RuntimeError("File %r is encrypted, password "
-                                       "required for extraction" % name)
-            else:
-                pwd = None
-
-            return ZipExtFile(zef_file, mode, zinfo, pwd, True)
-        except:
-            zef_file.close()
-            raise
-
-    def _open_to_write(self, zinfo, force_zip64=False):
-        if force_zip64 and not self._allowZip64:
-            raise ValueError(
-                "force_zip64 is True, but allowZip64 was False when opening "
-                "the ZIP file."
-            )
-        if self._writing:
-            raise ValueError("Can't write to the ZIP file while there is "
-                             "another write handle open on it. "
-                             "Close the first handle before opening another.")
-
-        # Sizes and CRC are overwritten with correct data after processing the file
-        if not hasattr(zinfo, 'file_size'):
-            zinfo.file_size = 0
-        zinfo.compress_size = 0
-        zinfo.CRC = 0
-
-        zinfo.flag_bits = 0x00
-        if zinfo.compress_type == ZIP_LZMA:
-            # Compressed data includes an end-of-stream (EOS) marker
-            zinfo.flag_bits |= 0x02
-        if not self._seekable:
-            zinfo.flag_bits |= 0x08
-
-        if not zinfo.external_attr:
-            zinfo.external_attr = 0o600 << 16  # permissions: ?rw-------
-
-        # Compressed size can be larger than uncompressed size
-        zip64 = self._allowZip64 and \
-                (force_zip64 or zinfo.file_size * 1.05 > ZIP64_LIMIT)
-
-        if self._seekable:
-            self.fp.seek(self.start_dir)
-        zinfo.header_offset = self.fp.tell()
-
-        self._writecheck(zinfo)
-        self._didModify = True
-
-        self.fp.write(zinfo.FileHeader(zip64))
-
-        self._writing = True
-        return _ZipWriteFile(self, zinfo, zip64)
-
-    def extract(self, member, path=None, pwd=None):
-        """Extract a member from the archive to the current working directory,
-           using its full name. Its file information is extracted as accurately
-           as possible. `member' may be a filename or a ZipInfo object. You can
-           specify a different directory using `path'.
-        """
-        if path is None:
-            path = os.getcwd()
-        else:
-            path = os.fspath(path)
-
-        return self._extract_member(member, path, pwd)
-
-    def extractall(self, path=None, members=None, pwd=None):
-        """Extract all members from the archive to the current working
-           directory. `path' specifies a different directory to extract to.
-           `members' is optional and must be a subset of the list returned
-           by namelist().
-        """
-        if members is None:
-            members = self.namelist()
-
-        if path is None:
-            path = os.getcwd()
-        else:
-            path = os.fspath(path)
-
-        for zipinfo in members:
-            self._extract_member(zipinfo, path, pwd)
-
-    @classmethod
-    def _sanitize_windows_name(cls, arcname, pathsep):
-        """Replace bad characters and remove trailing dots from parts."""
-        table = cls._windows_illegal_name_trans_table
-        if not table:
-            illegal = ':<>|"?*'
-            table = str.maketrans(illegal, '_' * len(illegal))
-            cls._windows_illegal_name_trans_table = table
-        arcname = arcname.translate(table)
-        # remove trailing dots
-        arcname = (x.rstrip('.') for x in arcname.split(pathsep))
-        # rejoin, removing empty parts.
-        arcname = pathsep.join(x for x in arcname if x)
-        return arcname
-
-    def _extract_member(self, member, targetpath, pwd):
-        """Extract the ZipInfo object 'member' to a physical
-           file on the path targetpath.
-        """
-        if not isinstance(member, ZipInfo):
-            member = self.getinfo(member)
-
-        # build the destination pathname, replacing
-        # forward slashes to platform specific separators.
-        arcname = member.filename.replace('/', os.path.sep)
-
-        if os.path.altsep:
-            arcname = arcname.replace(os.path.altsep, os.path.sep)
-        # interpret absolute pathname as relative, remove drive letter or
-        # UNC path, redundant separators, "." and ".." components.
-        arcname = os.path.splitdrive(arcname)[1]
-        invalid_path_parts = ('', os.path.curdir, os.path.pardir)
-        arcname = os.path.sep.join(x for x in arcname.split(os.path.sep)
-                                   if x not in invalid_path_parts)
-        if os.path.sep == '\\':
-            # filter illegal characters on Windows
-            arcname = self._sanitize_windows_name(arcname, os.path.sep)
-
-        targetpath = os.path.join(targetpath, arcname)
-        targetpath = os.path.normpath(targetpath)
-
-        # Create all upper directories if necessary.
-        upperdirs = os.path.dirname(targetpath)
-        if upperdirs and not os.path.exists(upperdirs):
-            os.makedirs(upperdirs)
-
-        if member.is_dir():
-            if not os.path.isdir(targetpath):
-                os.mkdir(targetpath)
-            return targetpath
-
-        with self.open(member, pwd=pwd) as source, \
-             open(targetpath, "wb") as target:
-            shutil.copyfileobj(source, target)
-
-        return targetpath
-
-    def _writecheck(self, zinfo):
-        """Check for errors before writing a file to the archive."""
-        if zinfo.filename in self.NameToInfo:
-            import warnings
-            warnings.warn('Duplicate name: %r' % zinfo.filename, stacklevel=3)
-        if self.mode not in ('w', 'x', 'a'):
-            raise ValueError("write() requires mode 'w', 'x', or 'a'")
-        if not self.fp:
-            raise ValueError(
-                "Attempt to write ZIP archive that was already closed")
-        _check_compression(zinfo.compress_type)
-        if not self._allowZip64:
-            requires_zip64 = None
-            if len(self.filelist) >= ZIP_FILECOUNT_LIMIT:
-                requires_zip64 = "Files count"
-            elif zinfo.file_size > ZIP64_LIMIT:
-                requires_zip64 = "Filesize"
-            elif zinfo.header_offset > ZIP64_LIMIT:
-                requires_zip64 = "Zipfile size"
-            if requires_zip64:
-                raise LargeZipFile(requires_zip64 +
-                                   " would require ZIP64 extensions")
-
-    def write(self, filename, arcname=None,
-              compress_type=None, compresslevel=None):
-        """Put the bytes from filename into the archive under the name
-        arcname."""
-        if not self.fp:
-            raise ValueError(
-                "Attempt to write to ZIP archive that was already closed")
-        if self._writing:
-            raise ValueError(
-                "Can't write to ZIP archive while an open writing handle exists"
-            )
-
-        zinfo = ZipInfo.from_file(filename, arcname)
-
-        if zinfo.is_dir():
-            zinfo.compress_size = 0
-            zinfo.CRC = 0
-        else:
-            if compress_type is not None:
-                zinfo.compress_type = compress_type
-            else:
-                zinfo.compress_type = self.compression
-
-            if compresslevel is not None:
-                zinfo._compresslevel = compresslevel
-            else:
-                zinfo._compresslevel = self.compresslevel
-
-        if zinfo.is_dir():
-            with self._lock:
-                if self._seekable:
-                    self.fp.seek(self.start_dir)
-                zinfo.header_offset = self.fp.tell()  # Start of header bytes
-                if zinfo.compress_type == ZIP_LZMA:
-                # Compressed data includes an end-of-stream (EOS) marker
-                    zinfo.flag_bits |= 0x02
-
-                self._writecheck(zinfo)
-                self._didModify = True
-
-                self.filelist.append(zinfo)
-                self.NameToInfo[zinfo.filename] = zinfo
-                self.fp.write(zinfo.FileHeader(False))
-                self.start_dir = self.fp.tell()
-        else:
-            with open(filename, "rb") as src, self.open(zinfo, 'w') as dest:
-                shutil.copyfileobj(src, dest, 1024*8)
-
-    def writestr(self, zinfo_or_arcname, data,
-                 compress_type=None, compresslevel=None):
-        """Write a file into the archive.  The contents is 'data', which
-        may be either a 'str' or a 'bytes' instance; if it is a 'str',
-        it is encoded as UTF-8 first.
-        'zinfo_or_arcname' is either a ZipInfo instance or
-        the name of the file in the archive."""
-        if isinstance(data, str):
-            data = data.encode("utf-8")
-        if not isinstance(zinfo_or_arcname, ZipInfo):
-            zinfo = ZipInfo(filename=zinfo_or_arcname,
-                            date_time=time.localtime(time.time())[:6])
-            zinfo.compress_type = self.compression
-            zinfo._compresslevel = self.compresslevel
-            if zinfo.filename[-1] == '/':
-                zinfo.external_attr = 0o40775 << 16   # drwxrwxr-x
-                zinfo.external_attr |= 0x10           # MS-DOS directory flag
-            else:
-                zinfo.external_attr = 0o600 << 16     # ?rw-------
-        else:
-            zinfo = zinfo_or_arcname
-
-        if not self.fp:
-            raise ValueError(
-                "Attempt to write to ZIP archive that was already closed")
-        if self._writing:
-            raise ValueError(
-                "Can't write to ZIP archive while an open writing handle exists."
-            )
-
-        if compress_type is not None:
-            zinfo.compress_type = compress_type
-
-        if compresslevel is not None:
-            zinfo._compresslevel = compresslevel
-
-        zinfo.file_size = len(data)            # Uncompressed size
-        with self._lock:
-            with self.open(zinfo, mode='w') as dest:
-                dest.write(data)
-
-    def __del__(self):
-        """Call the "close()" method in case the user forgot."""
-        self.close()
-
-    def close(self):
-        """Close the file, and for mode 'w', 'x' and 'a' write the ending
-        records."""
-        if self.fp is None:
-            return
-
-        if self._writing:
-            raise ValueError("Can't close the ZIP file while there is "
-                             "an open writing handle on it. "
-                             "Close the writing handle before closing the zip.")
-
-        try:
-            if self.mode in ('w', 'x', 'a') and self._didModify: # write ending records
-                with self._lock:
-                    if self._seekable:
-                        self.fp.seek(self.start_dir)
-                    self._write_end_record()
-        finally:
-            fp = self.fp
-            self.fp = None
-            self._fpclose(fp)
-
-    def _write_end_record(self):
-        for zinfo in self.filelist:         # write central directory
-            dt = zinfo.date_time
-            dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
-            dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
-            extra = []
-            if zinfo.file_size > ZIP64_LIMIT \
-               or zinfo.compress_size > ZIP64_LIMIT:
-                extra.append(zinfo.file_size)
-                extra.append(zinfo.compress_size)
-                file_size = 0xffffffff
-                compress_size = 0xffffffff
-            else:
-                file_size = zinfo.file_size
-                compress_size = zinfo.compress_size
-
-            if zinfo.header_offset > ZIP64_LIMIT:
-                extra.append(zinfo.header_offset)
-                header_offset = 0xffffffff
-            else:
-                header_offset = zinfo.header_offset
-
-            extra_data = zinfo.extra
-            min_version = 0
-            if extra:
-                # Append a ZIP64 field to the extra's
-                extra_data = _strip_extra(extra_data, (1,))
-                extra_data = struct.pack(
-                    '<HH' + 'Q'*len(extra),
-                    1, 8*len(extra), *extra) + extra_data
-
-                min_version = ZIP64_VERSION
-
-            if zinfo.compress_type == ZIP_BZIP2:
-                min_version = max(BZIP2_VERSION, min_version)
-            elif zinfo.compress_type == ZIP_LZMA:
-                min_version = max(LZMA_VERSION, min_version)
-
-            extract_version = max(min_version, zinfo.extract_version)
-            create_version = max(min_version, zinfo.create_version)
-            try:
-                filename, flag_bits = zinfo._encodeFilenameFlags()
-                centdir = struct.pack(structCentralDir,
-                                      stringCentralDir, create_version,
-                                      zinfo.create_system, extract_version, zinfo.reserved,
-                                      flag_bits, zinfo.compress_type, dostime, dosdate,
-                                      zinfo.CRC, compress_size, file_size,
-                                      len(filename), len(extra_data), len(zinfo.comment),
-                                      0, zinfo.internal_attr, zinfo.external_attr,
-                                      header_offset)
-            except DeprecationWarning:
-                print((structCentralDir, stringCentralDir, create_version,
-                       zinfo.create_system, extract_version, zinfo.reserved,
-                       zinfo.flag_bits, zinfo.compress_type, dostime, dosdate,
-                       zinfo.CRC, compress_size, file_size,
-                       len(zinfo.filename), len(extra_data), len(zinfo.comment),
-                       0, zinfo.internal_attr, zinfo.external_attr,
-                       header_offset), file=sys.stderr)
-                raise
-            self.fp.write(centdir)
-            self.fp.write(filename)
-            self.fp.write(extra_data)
-            self.fp.write(zinfo.comment)
-
-        pos2 = self.fp.tell()
-        # Write end-of-zip-archive record
-        centDirCount = len(self.filelist)
-        centDirSize = pos2 - self.start_dir
-        centDirOffset = self.start_dir
-        requires_zip64 = None
-        if centDirCount > ZIP_FILECOUNT_LIMIT:
-            requires_zip64 = "Files count"
-        elif centDirOffset > ZIP64_LIMIT:
-            requires_zip64 = "Central directory offset"
-        elif centDirSize > ZIP64_LIMIT:
-            requires_zip64 = "Central directory size"
-        if requires_zip64:
-            # Need to write the ZIP64 end-of-archive records
-            if not self._allowZip64:
-                raise LargeZipFile(requires_zip64 +
-                                   " would require ZIP64 extensions")
-            zip64endrec = struct.pack(
-                structEndArchive64, stringEndArchive64,
-                44, 45, 45, 0, 0, centDirCount, centDirCount,
-                centDirSize, centDirOffset)
-            self.fp.write(zip64endrec)
-
-            zip64locrec = struct.pack(
-                structEndArchive64Locator,
-                stringEndArchive64Locator, 0, pos2, 1)
-            self.fp.write(zip64locrec)
-            centDirCount = min(centDirCount, 0xFFFF)
-            centDirSize = min(centDirSize, 0xFFFFFFFF)
-            centDirOffset = min(centDirOffset, 0xFFFFFFFF)
-
-        endrec = struct.pack(structEndArchive, stringEndArchive,
-                             0, 0, centDirCount, centDirCount,
-                             centDirSize, centDirOffset, len(self._comment))
-        self.fp.write(endrec)
-        self.fp.write(self._comment)
-        self.fp.flush()
-
-    def _fpclose(self, fp):
-        assert self._fileRefCnt > 0
-        self._fileRefCnt -= 1
-        if not self._fileRefCnt and not self._filePassed:
-            fp.close()
-
-
-class PyZipFile(ZipFile):
-    """Class to create ZIP archives with Python library files and packages."""
-
-    def __init__(self, file, mode="r", compression=ZIP_STORED,
-                 allowZip64=True, optimize=-1):
-        ZipFile.__init__(self, file, mode=mode, compression=compression,
-                         allowZip64=allowZip64)
-        self._optimize = optimize
-
-    def writepy(self, pathname, basename="", filterfunc=None):
-        """Add all files from "pathname" to the ZIP archive.
-
-        If pathname is a package directory, search the directory and
-        all package subdirectories recursively for all *.py and enter
-        the modules into the archive.  If pathname is a plain
-        directory, listdir *.py and enter all modules.  Else, pathname
-        must be a Python *.py file and the module will be put into the
-        archive.  Added modules are always module.pyc.
-        This method will compile the module.py into module.pyc if
-        necessary.
-        If filterfunc(pathname) is given, it is called with every argument.
-        When it is False, the file or directory is skipped.
-        """
-        pathname = os.fspath(pathname)
-        if filterfunc and not filterfunc(pathname):
-            if self.debug:
-                label = 'path' if os.path.isdir(pathname) else 'file'
-                print('%s %r skipped by filterfunc' % (label, pathname))
-            return
-        dir, name = os.path.split(pathname)
-        if os.path.isdir(pathname):
-            initname = os.path.join(pathname, "__init__.py")
-            if os.path.isfile(initname):
-                # This is a package directory, add it
-                if basename:
-                    basename = "%s/%s" % (basename, name)
-                else:
-                    basename = name
-                if self.debug:
-                    print("Adding package in", pathname, "as", basename)
-                fname, arcname = self._get_codename(initname[0:-3], basename)
-                if self.debug:
-                    print("Adding", arcname)
-                self.write(fname, arcname)
-                dirlist = sorted(os.listdir(pathname))
-                dirlist.remove("__init__.py")
-                # Add all *.py files and package subdirectories
-                for filename in dirlist:
-                    path = os.path.join(pathname, filename)
-                    root, ext = os.path.splitext(filename)
-                    if os.path.isdir(path):
-                        if os.path.isfile(os.path.join(path, "__init__.py")):
-                            # This is a package directory, add it
-                            self.writepy(path, basename,
-                                         filterfunc=filterfunc)  # Recursive call
-                    elif ext == ".py":
-                        if filterfunc and not filterfunc(path):
-                            if self.debug:
-                                print('file %r skipped by filterfunc' % path)
-                            continue
-                        fname, arcname = self._get_codename(path[0:-3],
-                                                            basename)
-                        if self.debug:
-                            print("Adding", arcname)
-                        self.write(fname, arcname)
-            else:
-                # This is NOT a package directory, add its files at top level
-                if self.debug:
-                    print("Adding files from directory", pathname)
-                for filename in sorted(os.listdir(pathname)):
-                    path = os.path.join(pathname, filename)
-                    root, ext = os.path.splitext(filename)
-                    if ext == ".py":
-                        if filterfunc and not filterfunc(path):
-                            if self.debug:
-                                print('file %r skipped by filterfunc' % path)
-                            continue
-                        fname, arcname = self._get_codename(path[0:-3],
-                                                            basename)
-                        if self.debug:
-                            print("Adding", arcname)
-                        self.write(fname, arcname)
-        else:
-            if pathname[-3:] != ".py":
-                raise RuntimeError(
-                    'Files added with writepy() must end with ".py"')
-            fname, arcname = self._get_codename(pathname[0:-3], basename)
-            if self.debug:
-                print("Adding file", arcname)
-            self.write(fname, arcname)
-
-    def _get_codename(self, pathname, basename):
-        """Return (filename, archivename) for the path.
-
-        Given a module name path, return the correct file path and
-        archive name, compiling if necessary.  For example, given
-        /python/lib/string, return (/python/lib/string.pyc, string).
-        """
-        def _compile(file, optimize=-1):
-            import py_compile
-            if self.debug:
-                print("Compiling", file)
-            try:
-                py_compile.compile(file, doraise=True, optimize=optimize)
-            except py_compile.PyCompileError as err:
-                print(err.msg)
-                return False
-            return True
-
-        file_py  = pathname + ".py"
-        file_pyc = pathname + ".pyc"
-        pycache_opt0 = importlib.util.cache_from_source(file_py, optimization='')
-        pycache_opt1 = importlib.util.cache_from_source(file_py, optimization=1)
-        pycache_opt2 = importlib.util.cache_from_source(file_py, optimization=2)
-        if self._optimize == -1:
-            # legacy mode: use whatever file is present
-            if (os.path.isfile(file_pyc) and
-                  os.stat(file_pyc).st_mtime >= os.stat(file_py).st_mtime):
-                # Use .pyc file.
-                arcname = fname = file_pyc
-            elif (os.path.isfile(pycache_opt0) and
-                  os.stat(pycache_opt0).st_mtime >= os.stat(file_py).st_mtime):
-                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
-                # file name in the archive.
-                fname = pycache_opt0
-                arcname = file_pyc
-            elif (os.path.isfile(pycache_opt1) and
-                  os.stat(pycache_opt1).st_mtime >= os.stat(file_py).st_mtime):
-                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
-                # file name in the archive.
-                fname = pycache_opt1
-                arcname = file_pyc
-            elif (os.path.isfile(pycache_opt2) and
-                  os.stat(pycache_opt2).st_mtime >= os.stat(file_py).st_mtime):
-                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
-                # file name in the archive.
-                fname = pycache_opt2
-                arcname = file_pyc
-            else:
-                # Compile py into PEP 3147 pyc file.
-                if _compile(file_py):
-                    if sys.flags.optimize == 0:
-                        fname = pycache_opt0
-                    elif sys.flags.optimize == 1:
-                        fname = pycache_opt1
-                    else:
-                        fname = pycache_opt2
-                    arcname = file_pyc
-                else:
-                    fname = arcname = file_py
-        else:
-            # new mode: use given optimization level
-            if self._optimize == 0:
-                fname = pycache_opt0
-                arcname = file_pyc
-            else:
-                arcname = file_pyc
-                if self._optimize == 1:
-                    fname = pycache_opt1
-                elif self._optimize == 2:
-                    fname = pycache_opt2
-                else:
-                    msg = "invalid value for 'optimize': {!r}".format(self._optimize)
-                    raise ValueError(msg)
-            if not (os.path.isfile(fname) and
-                    os.stat(fname).st_mtime >= os.stat(file_py).st_mtime):
-                if not _compile(file_py, optimize=self._optimize):
-                    fname = arcname = file_py
-        archivename = os.path.split(arcname)[1]
-        if basename:
-            archivename = "%s/%s" % (basename, archivename)
-        return (fname, archivename)
-
-
-def main(args=None):
-    import argparse
-
-    description = 'A simple command-line interface for zipfile module.'
-    parser = argparse.ArgumentParser(description=description)
-    group = parser.add_mutually_exclusive_group(required=True)
-    group.add_argument('-l', '--list', metavar='<zipfile>',
-                       help='Show listing of a zipfile')
-    group.add_argument('-e', '--extract', nargs=2,
-                       metavar=('<zipfile>', '<output_dir>'),
-                       help='Extract zipfile into target dir')
-    group.add_argument('-c', '--create', nargs='+',
-                       metavar=('<name>', '<file>'),
-                       help='Create zipfile from sources')
-    group.add_argument('-t', '--test', metavar='<zipfile>',
-                       help='Test if a zipfile is valid')
-    args = parser.parse_args(args)
-
-    if args.test is not None:
-        src = args.test
-        with ZipFile(src, 'r') as zf:
-            badfile = zf.testzip()
-        if badfile:
-            print("The following enclosed file is corrupted: {!r}".format(badfile))
-        print("Done testing")
-
-    elif args.list is not None:
-        src = args.list
-        with ZipFile(src, 'r') as zf:
-            zf.printdir()
-
-    elif args.extract is not None:
-        src, curdir = args.extract
-        with ZipFile(src, 'r') as zf:
-            zf.extractall(curdir)
-
-    elif args.create is not None:
-        zip_name = args.create.pop(0)
-        files = args.create
-
-        def addToZip(zf, path, zippath):
-            if os.path.isfile(path):
-                zf.write(path, zippath, ZIP_DEFLATED)
-            elif os.path.isdir(path):
-                if zippath:
-                    zf.write(path, zippath)
-                for nm in sorted(os.listdir(path)):
-                    addToZip(zf,
-                             os.path.join(path, nm), os.path.join(zippath, nm))
-            # else: ignore
-
-        with ZipFile(zip_name, 'w') as zf:
-            for path in files:
-                zippath = os.path.basename(path)
-                if not zippath:
-                    zippath = os.path.basename(os.path.dirname(path))
-                if zippath in ('', os.curdir, os.pardir):
-                    zippath = ''
-                addToZip(zf, path, zippath)
-
-if __name__ == "__main__":
-    main()
+"""
+Read and write ZIP files.
+
+XXX references to utf-8 need further investigation.
+"""
+import io
+import os
+import importlib.util
+import sys
+import time
+import stat
+import shutil
+import struct
+import binascii
+import threading
+
+try:
+    import zlib # We may need its compression method
+    crc32 = zlib.crc32
+except ImportError:
+    zlib = None
+    crc32 = binascii.crc32
+
+try:
+    import bz2 # We may need its compression method
+except ImportError:
+    bz2 = None
+
+try:
+    import lzma # We may need its compression method
+except ImportError:
+    lzma = None
+
+__all__ = ["BadZipFile", "BadZipfile", "error",
+           "ZIP_STORED", "ZIP_DEFLATED", "ZIP_BZIP2", "ZIP_LZMA",
+           "is_zipfile", "ZipInfo", "ZipFile", "PyZipFile", "LargeZipFile"]
+
+class BadZipFile(Exception):
+    pass
+
+
+class LargeZipFile(Exception):
+    """
+    Raised when writing a zipfile, the zipfile requires ZIP64 extensions
+    and those extensions are disabled.
+    """
+
+error = BadZipfile = BadZipFile      # Pre-3.2 compatibility names
+
+
+ZIP64_LIMIT = (1 << 31) - 1
+ZIP_FILECOUNT_LIMIT = (1 << 16) - 1
+ZIP_MAX_COMMENT = (1 << 16) - 1
+
+# constants for Zip file compression methods
+ZIP_STORED = 0
+ZIP_DEFLATED = 8
+ZIP_BZIP2 = 12
+ZIP_LZMA = 14
+# Other ZIP compression methods not supported
+
+DEFAULT_VERSION = 20
+ZIP64_VERSION = 45
+BZIP2_VERSION = 46
+LZMA_VERSION = 63
+# we recognize (but not necessarily support) all features up to that version
+MAX_EXTRACT_VERSION = 63
+
+# Below are some formats and associated data for reading/writing headers using
+# the struct module.  The names and structures of headers/records are those used
+# in the PKWARE description of the ZIP file format:
+#     http://www.pkware.com/documents/casestudies/APPNOTE.TXT
+# (URL valid as of January 2008)
+
+# The "end of central directory" structure, magic number, size, and indices
+# (section V.I in the format document)
+structEndArchive = b"<4s4H2LH"
+stringEndArchive = b"PK\005\006"
+sizeEndCentDir = struct.calcsize(structEndArchive)
+
+_ECD_SIGNATURE = 0
+_ECD_DISK_NUMBER = 1
+_ECD_DISK_START = 2
+_ECD_ENTRIES_THIS_DISK = 3
+_ECD_ENTRIES_TOTAL = 4
+_ECD_SIZE = 5
+_ECD_OFFSET = 6
+_ECD_COMMENT_SIZE = 7
+# These last two indices are not part of the structure as defined in the
+# spec, but they are used internally by this module as a convenience
+_ECD_COMMENT = 8
+_ECD_LOCATION = 9
+
+# The "central directory" structure, magic number, size, and indices
+# of entries in the structure (section V.F in the format document)
+structCentralDir = "<4s4B4HL2L5H2L"
+stringCentralDir = b"PK\001\002"
+sizeCentralDir = struct.calcsize(structCentralDir)
+
+# indexes of entries in the central directory structure
+_CD_SIGNATURE = 0
+_CD_CREATE_VERSION = 1
+_CD_CREATE_SYSTEM = 2
+_CD_EXTRACT_VERSION = 3
+_CD_EXTRACT_SYSTEM = 4
+_CD_FLAG_BITS = 5
+_CD_COMPRESS_TYPE = 6
+_CD_TIME = 7
+_CD_DATE = 8
+_CD_CRC = 9
+_CD_COMPRESSED_SIZE = 10
+_CD_UNCOMPRESSED_SIZE = 11
+_CD_FILENAME_LENGTH = 12
+_CD_EXTRA_FIELD_LENGTH = 13
+_CD_COMMENT_LENGTH = 14
+_CD_DISK_NUMBER_START = 15
+_CD_INTERNAL_FILE_ATTRIBUTES = 16
+_CD_EXTERNAL_FILE_ATTRIBUTES = 17
+_CD_LOCAL_HEADER_OFFSET = 18
+
+# The "local file header" structure, magic number, size, and indices
+# (section V.A in the format document)
+structFileHeader = "<4s2B4HL2L2H"
+stringFileHeader = b"PK\003\004"
+sizeFileHeader = struct.calcsize(structFileHeader)
+
+_FH_SIGNATURE = 0
+_FH_EXTRACT_VERSION = 1
+_FH_EXTRACT_SYSTEM = 2
+_FH_GENERAL_PURPOSE_FLAG_BITS = 3
+_FH_COMPRESSION_METHOD = 4
+_FH_LAST_MOD_TIME = 5
+_FH_LAST_MOD_DATE = 6
+_FH_CRC = 7
+_FH_COMPRESSED_SIZE = 8
+_FH_UNCOMPRESSED_SIZE = 9
+_FH_FILENAME_LENGTH = 10
+_FH_EXTRA_FIELD_LENGTH = 11
+
+# The "Zip64 end of central directory locator" structure, magic number, and size
+structEndArchive64Locator = "<4sLQL"
+stringEndArchive64Locator = b"PK\x06\x07"
+sizeEndCentDir64Locator = struct.calcsize(structEndArchive64Locator)
+
+# The "Zip64 end of central directory" record, magic number, size, and indices
+# (section V.G in the format document)
+structEndArchive64 = "<4sQ2H2L4Q"
+stringEndArchive64 = b"PK\x06\x06"
+sizeEndCentDir64 = struct.calcsize(structEndArchive64)
+
+_CD64_SIGNATURE = 0
+_CD64_DIRECTORY_RECSIZE = 1
+_CD64_CREATE_VERSION = 2
+_CD64_EXTRACT_VERSION = 3
+_CD64_DISK_NUMBER = 4
+_CD64_DISK_NUMBER_START = 5
+_CD64_NUMBER_ENTRIES_THIS_DISK = 6
+_CD64_NUMBER_ENTRIES_TOTAL = 7
+_CD64_DIRECTORY_SIZE = 8
+_CD64_OFFSET_START_CENTDIR = 9
+
+_DD_SIGNATURE = 0x08074b50
+
+_EXTRA_FIELD_STRUCT = struct.Struct('<HH')
+
+def _strip_extra(extra, xids):
+    # Remove Extra Fields with specified IDs.
+    unpack = _EXTRA_FIELD_STRUCT.unpack
+    modified = False
+    buffer = []
+    start = i = 0
+    while i + 4 <= len(extra):
+        xid, xlen = unpack(extra[i : i + 4])
+        j = i + 4 + xlen
+        if xid in xids:
+            if i != start:
+                buffer.append(extra[start : i])
+            start = j
+            modified = True
+        i = j
+    if not modified:
+        return extra
+    return b''.join(buffer)
+
+def _check_zipfile(fp):
+    try:
+        if _EndRecData(fp):
+            return True         # file has correct magic number
+    except OSError:
+        pass
+    return False
+
+def is_zipfile(filename):
+    """Quickly see if a file is a ZIP file by checking the magic number.
+
+    The filename argument may be a file or file-like object too.
+    """
+    result = False
+    try:
+        if hasattr(filename, "read"):
+            result = _check_zipfile(fp=filename)
+        else:
+            with open(filename, "rb") as fp:
+                result = _check_zipfile(fp)
+    except OSError:
+        pass
+    return result
+
+def _EndRecData64(fpin, offset, endrec):
+    """
+    Read the ZIP64 end-of-archive records and use that to update endrec
+    """
+    try:
+        fpin.seek(offset - sizeEndCentDir64Locator, 2)
+    except OSError:
+        # If the seek fails, the file is not large enough to contain a ZIP64
+        # end-of-archive record, so just return the end record we were given.
+        return endrec
+
+    data = fpin.read(sizeEndCentDir64Locator)
+    if len(data) != sizeEndCentDir64Locator:
+        return endrec
+    sig, diskno, reloff, disks = struct.unpack(structEndArchive64Locator, data)
+    if sig != stringEndArchive64Locator:
+        return endrec
+
+    if diskno != 0 or disks > 1:
+        raise BadZipFile("zipfiles that span multiple disks are not supported")
+
+    # Assume no 'zip64 extensible data'
+    fpin.seek(offset - sizeEndCentDir64Locator - sizeEndCentDir64, 2)
+    data = fpin.read(sizeEndCentDir64)
+    if len(data) != sizeEndCentDir64:
+        return endrec
+    sig, sz, create_version, read_version, disk_num, disk_dir, \
+        dircount, dircount2, dirsize, diroffset = \
+        struct.unpack(structEndArchive64, data)
+    if sig != stringEndArchive64:
+        return endrec
+
+    # Update the original endrec using data from the ZIP64 record
+    endrec[_ECD_SIGNATURE] = sig
+    endrec[_ECD_DISK_NUMBER] = disk_num
+    endrec[_ECD_DISK_START] = disk_dir
+    endrec[_ECD_ENTRIES_THIS_DISK] = dircount
+    endrec[_ECD_ENTRIES_TOTAL] = dircount2
+    endrec[_ECD_SIZE] = dirsize
+    endrec[_ECD_OFFSET] = diroffset
+    return endrec
+
+
+def _EndRecData(fpin):
+    """Return data from the "End of Central Directory" record, or None.
+
+    The data is a list of the nine items in the ZIP "End of central dir"
+    record followed by a tenth item, the file seek offset of this record."""
+
+    # Determine file size
+    fpin.seek(0, 2)
+    filesize = fpin.tell()
+
+    # Check to see if this is ZIP file with no archive comment (the
+    # "end of central directory" structure should be the last item in the
+    # file if this is the case).
+    try:
+        fpin.seek(-sizeEndCentDir, 2)
+    except OSError:
+        return None
+    data = fpin.read()
+    if (len(data) == sizeEndCentDir and
+        data[0:4] == stringEndArchive and
+        data[-2:] == b"\000\000"):
+        # the signature is correct and there's no comment, unpack structure
+        endrec = struct.unpack(structEndArchive, data)
+        endrec=list(endrec)
+
+        # Append a blank comment and record start offset
+        endrec.append(b"")
+        endrec.append(filesize - sizeEndCentDir)
+
+        # Try to read the "Zip64 end of central directory" structure
+        return _EndRecData64(fpin, -sizeEndCentDir, endrec)
+
+    # Either this is not a ZIP file, or it is a ZIP file with an archive
+    # comment.  Search the end of the file for the "end of central directory"
+    # record signature. The comment is the last item in the ZIP file and may be
+    # up to 64K long.  It is assumed that the "end of central directory" magic
+    # number does not appear in the comment.
+    maxCommentStart = max(filesize - (1 << 16) - sizeEndCentDir, 0)
+    fpin.seek(maxCommentStart, 0)
+    data = fpin.read()
+    start = data.rfind(stringEndArchive)
+    if start >= 0:
+        # found the magic number; attempt to unpack and interpret
+        recData = data[start:start+sizeEndCentDir]
+        if len(recData) != sizeEndCentDir:
+            # Zip file is corrupted.
+            return None
+        endrec = list(struct.unpack(structEndArchive, recData))
+        commentSize = endrec[_ECD_COMMENT_SIZE] #as claimed by the zip file
+        comment = data[start+sizeEndCentDir:start+sizeEndCentDir+commentSize]
+        endrec.append(comment)
+        endrec.append(maxCommentStart + start)
+
+        # Try to read the "Zip64 end of central directory" structure
+        return _EndRecData64(fpin, maxCommentStart + start - filesize,
+                             endrec)
+
+    # Unable to find a valid end of central directory structure
+    return None
+
+
+class ZipInfo (object):
+    """Class with attributes describing each file in the ZIP archive."""
+
+    __slots__ = (
+        'orig_filename',
+        'filename',
+        'date_time',
+        'compress_type',
+        '_compresslevel',
+        'comment',
+        'extra',
+        'create_system',
+        'create_version',
+        'extract_version',
+        'reserved',
+        'flag_bits',
+        'volume',
+        'internal_attr',
+        'external_attr',
+        'header_offset',
+        'CRC',
+        'compress_size',
+        'file_size',
+        '_raw_time',
+    )
+
+    def __init__(self, filename="NoName", date_time=(1980,1,1,0,0,0)):
+        self.orig_filename = filename   # Original file name in archive
+
+        # Terminate the file name at the first null byte.  Null bytes in file
+        # names are used as tricks by viruses in archives.
+        null_byte = filename.find(chr(0))
+        if null_byte >= 0:
+            filename = filename[0:null_byte]
+        # This is used to ensure paths in generated ZIP files always use
+        # forward slashes as the directory separator, as required by the
+        # ZIP format specification.
+        if os.sep != "/" and os.sep in filename:
+            filename = filename.replace(os.sep, "/")
+
+        self.filename = filename        # Normalized file name
+        self.date_time = date_time      # year, month, day, hour, min, sec
+
+        if date_time[0] < 1980:
+            raise ValueError('ZIP does not support timestamps before 1980')
+
+        # Standard values:
+        self.compress_type = ZIP_STORED # Type of compression for the file
+        self._compresslevel = None      # Level for the compressor
+        self.comment = b""              # Comment for each file
+        self.extra = b""                # ZIP extra data
+        if sys.platform == 'win32':
+            self.create_system = 0          # System which created ZIP archive
+        else:
+            # Assume everything else is unix-y
+            self.create_system = 3          # System which created ZIP archive
+        self.create_version = DEFAULT_VERSION  # Version which created ZIP archive
+        self.extract_version = DEFAULT_VERSION # Version needed to extract archive
+        self.reserved = 0               # Must be zero
+        self.flag_bits = 0              # ZIP flag bits
+        self.volume = 0                 # Volume number of file header
+        self.internal_attr = 0          # Internal attributes
+        self.external_attr = 0          # External file attributes
+        # Other attributes are set by class ZipFile:
+        # header_offset         Byte offset to the file header
+        # CRC                   CRC-32 of the uncompressed file
+        # compress_size         Size of the compressed file
+        # file_size             Size of the uncompressed file
+
+    def __repr__(self):
+        result = ['<%s filename=%r' % (self.__class__.__name__, self.filename)]
+        if self.compress_type != ZIP_STORED:
+            result.append(' compress_type=%s' %
+                          compressor_names.get(self.compress_type,
+                                               self.compress_type))
+        hi = self.external_attr >> 16
+        lo = self.external_attr & 0xFFFF
+        if hi:
+            result.append(' filemode=%r' % stat.filemode(hi))
+        if lo:
+            result.append(' external_attr=%#x' % lo)
+        isdir = self.is_dir()
+        if not isdir or self.file_size:
+            result.append(' file_size=%r' % self.file_size)
+        if ((not isdir or self.compress_size) and
+            (self.compress_type != ZIP_STORED or
+             self.file_size != self.compress_size)):
+            result.append(' compress_size=%r' % self.compress_size)
+        result.append('>')
+        return ''.join(result)
+
+    def FileHeader(self, zip64=None):
+        """Return the per-file header as a bytes object."""
+        dt = self.date_time
+        dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
+        dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
+        if self.flag_bits & 0x08:
+            # Set these to zero because we write them after the file data
+            CRC = compress_size = file_size = 0
+        else:
+            CRC = self.CRC
+            compress_size = self.compress_size
+            file_size = self.file_size
+
+        extra = self.extra
+
+        min_version = 0
+        if zip64 is None:
+            zip64 = file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT
+        if zip64:
+            fmt = '<HHQQ'
+            extra = extra + struct.pack(fmt,
+                                        1, struct.calcsize(fmt)-4, file_size, compress_size)
+        if file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT:
+            if not zip64:
+                raise LargeZipFile("Filesize would require ZIP64 extensions")
+            # File is larger than what fits into a 4 byte integer,
+            # fall back to the ZIP64 extension
+            file_size = 0xffffffff
+            compress_size = 0xffffffff
+            min_version = ZIP64_VERSION
+
+        if self.compress_type == ZIP_BZIP2:
+            min_version = max(BZIP2_VERSION, min_version)
+        elif self.compress_type == ZIP_LZMA:
+            min_version = max(LZMA_VERSION, min_version)
+
+        self.extract_version = max(min_version, self.extract_version)
+        self.create_version = max(min_version, self.create_version)
+        filename, flag_bits = self._encodeFilenameFlags()
+        header = struct.pack(structFileHeader, stringFileHeader,
+                             self.extract_version, self.reserved, flag_bits,
+                             self.compress_type, dostime, dosdate, CRC,
+                             compress_size, file_size,
+                             len(filename), len(extra))
+        return header + filename + extra
+
+    def _encodeFilenameFlags(self):
+        try:
+            return self.filename.encode('ascii'), self.flag_bits
+        except UnicodeEncodeError:
+            return self.filename.encode('utf-8'), self.flag_bits | 0x800
+
+    def _decodeExtra(self):
+        # Try to decode the extra field.
+        extra = self.extra
+        unpack = struct.unpack
+        while len(extra) >= 4:
+            tp, ln = unpack('<HH', extra[:4])
+            if ln+4 > len(extra):
+                raise BadZipFile("Corrupt extra field %04x (size=%d)" % (tp, ln))
+            if tp == 0x0001:
+                if ln >= 24:
+                    counts = unpack('<QQQ', extra[4:28])
+                elif ln == 16:
+                    counts = unpack('<QQ', extra[4:20])
+                elif ln == 8:
+                    counts = unpack('<Q', extra[4:12])
+                elif ln == 0:
+                    counts = ()
+                else:
+                    raise BadZipFile("Corrupt extra field %04x (size=%d)" % (tp, ln))
+
+                idx = 0
+
+                # ZIP64 extension (large files and/or large archives)
+                if self.file_size in (0xffffffffffffffff, 0xffffffff):
+                    if len(counts) <= idx:
+                        raise BadZipFile(
+                            "Corrupt zip64 extra field. File size not found."
+                        )
+                    self.file_size = counts[idx]
+                    idx += 1
+
+                if self.compress_size == 0xFFFFFFFF:
+                    if len(counts) <= idx:
+                        raise BadZipFile(
+                            "Corrupt zip64 extra field. Compress size not found."
+                        )
+                    self.compress_size = counts[idx]
+                    idx += 1
+
+                if self.header_offset == 0xffffffff:
+                    if len(counts) <= idx:
+                        raise BadZipFile(
+                            "Corrupt zip64 extra field. Header offset not found."
+                        )
+                    old = self.header_offset
+                    self.header_offset = counts[idx]
+                    idx+=1
+
+            extra = extra[ln+4:]
+
+    @classmethod
+    def from_file(cls, filename, arcname=None):
+        """Construct an appropriate ZipInfo for a file on the filesystem.
+
+        filename should be the path to a file or directory on the filesystem.
+
+        arcname is the name which it will have within the archive (by default,
+        this will be the same as filename, but without a drive letter and with
+        leading path separators removed).
+        """
+        if isinstance(filename, os.PathLike):
+            filename = os.fspath(filename)
+        st = os.stat(filename)
+        isdir = stat.S_ISDIR(st.st_mode)
+        mtime = time.localtime(st.st_mtime)
+        date_time = mtime[0:6]
+        # Create ZipInfo instance to store file information
+        if arcname is None:
+            arcname = filename
+        arcname = os.path.normpath(os.path.splitdrive(arcname)[1])
+        while arcname[0] in (os.sep, os.altsep):
+            arcname = arcname[1:]
+        if isdir:
+            arcname += '/'
+        zinfo = cls(arcname, date_time)
+        zinfo.external_attr = (st.st_mode & 0xFFFF) << 16  # Unix attributes
+        if isdir:
+            zinfo.file_size = 0
+            zinfo.external_attr |= 0x10  # MS-DOS directory flag
+        else:
+            zinfo.file_size = st.st_size
+
+        return zinfo
+
+    def is_dir(self):
+        """Return True if this archive member is a directory."""
+        return self.filename[-1] == '/'
+
+
+# ZIP encryption uses the CRC32 one-byte primitive for scrambling some
+# internal keys. We noticed that a direct implementation is faster than
+# relying on binascii.crc32().
+
+_crctable = None
+def _gen_crc(crc):
+    for j in range(8):
+        if crc & 1:
+            crc = (crc >> 1) ^ 0xEDB88320
+        else:
+            crc >>= 1
+    return crc
+
+# ZIP supports a password-based form of encryption. Even though known
+# plaintext attacks have been found against it, it is still useful
+# to be able to get data out of such a file.
+#
+# Usage:
+#     zd = _ZipDecrypter(mypwd)
+#     plain_bytes = zd(cypher_bytes)
+
+def _ZipDecrypter(pwd):
+    key0 = 305419896
+    key1 = 591751049
+    key2 = 878082192
+
+    global _crctable
+    if _crctable is None:
+        _crctable = list(map(_gen_crc, range(256)))
+    crctable = _crctable
+
+    def crc32(ch, crc):
+        """Compute the CRC32 primitive on one byte."""
+        return (crc >> 8) ^ crctable[(crc ^ ch) & 0xFF]
+
+    def update_keys(c):
+        nonlocal key0, key1, key2
+        key0 = crc32(c, key0)
+        key1 = (key1 + (key0 & 0xFF)) & 0xFFFFFFFF
+        key1 = (key1 * 134775813 + 1) & 0xFFFFFFFF
+        key2 = crc32(key1 >> 24, key2)
+
+    for p in pwd:
+        update_keys(p)
+
+    def decrypter(data):
+        """Decrypt a bytes object."""
+        result = bytearray()
+        append = result.append
+        for c in data:
+            k = key2 | 2
+            c ^= ((k * (k^1)) >> 8) & 0xFF
+            update_keys(c)
+            append(c)
+        return bytes(result)
+
+    return decrypter
+
+
+class LZMACompressor:
+
+    def __init__(self):
+        self._comp = None
+
+    def _init(self):
+        props = lzma._encode_filter_properties({'id': lzma.FILTER_LZMA1})
+        self._comp = lzma.LZMACompressor(lzma.FORMAT_RAW, filters=[
+            lzma._decode_filter_properties(lzma.FILTER_LZMA1, props)
+        ])
+        return struct.pack('<BBH', 9, 4, len(props)) + props
+
+    def compress(self, data):
+        if self._comp is None:
+            return self._init() + self._comp.compress(data)
+        return self._comp.compress(data)
+
+    def flush(self):
+        if self._comp is None:
+            return self._init() + self._comp.flush()
+        return self._comp.flush()
+
+
+class LZMADecompressor:
+
+    def __init__(self):
+        self._decomp = None
+        self._unconsumed = b''
+        self.eof = False
+
+    def decompress(self, data):
+        if self._decomp is None:
+            self._unconsumed += data
+            if len(self._unconsumed) <= 4:
+                return b''
+            psize, = struct.unpack('<H', self._unconsumed[2:4])
+            if len(self._unconsumed) <= 4 + psize:
+                return b''
+
+            self._decomp = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[
+                lzma._decode_filter_properties(lzma.FILTER_LZMA1,
+                                               self._unconsumed[4:4 + psize])
+            ])
+            data = self._unconsumed[4 + psize:]
+            del self._unconsumed
+
+        result = self._decomp.decompress(data)
+        self.eof = self._decomp.eof
+        return result
+
+
+compressor_names = {
+    0: 'store',
+    1: 'shrink',
+    2: 'reduce',
+    3: 'reduce',
+    4: 'reduce',
+    5: 'reduce',
+    6: 'implode',
+    7: 'tokenize',
+    8: 'deflate',
+    9: 'deflate64',
+    10: 'implode',
+    12: 'bzip2',
+    14: 'lzma',
+    18: 'terse',
+    19: 'lz77',
+    97: 'wavpack',
+    98: 'ppmd',
+}
+
+def _check_compression(compression):
+    if compression == ZIP_STORED:
+        pass
+    elif compression == ZIP_DEFLATED:
+        if not zlib:
+            raise RuntimeError(
+                "Compression requires the (missing) zlib module")
+    elif compression == ZIP_BZIP2:
+        if not bz2:
+            raise RuntimeError(
+                "Compression requires the (missing) bz2 module")
+    elif compression == ZIP_LZMA:
+        if not lzma:
+            raise RuntimeError(
+                "Compression requires the (missing) lzma module")
+    else:
+        raise NotImplementedError("That compression method is not supported")
+
+
+def _get_compressor(compress_type, compresslevel=None):
+    if compress_type == ZIP_DEFLATED:
+        if compresslevel is not None:
+            return zlib.compressobj(compresslevel, zlib.DEFLATED, -15)
+        return zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION, zlib.DEFLATED, -15)
+    elif compress_type == ZIP_BZIP2:
+        if compresslevel is not None:
+            return bz2.BZ2Compressor(compresslevel)
+        return bz2.BZ2Compressor()
+    # compresslevel is ignored for ZIP_LZMA
+    elif compress_type == ZIP_LZMA:
+        return LZMACompressor()
+    else:
+        return None
+
+
+def _get_decompressor(compress_type):
+    if compress_type == ZIP_STORED:
+        return None
+    elif compress_type == ZIP_DEFLATED:
+        return zlib.decompressobj(-15)
+    elif compress_type == ZIP_BZIP2:
+        return bz2.BZ2Decompressor()
+    elif compress_type == ZIP_LZMA:
+        return LZMADecompressor()
+    else:
+        descr = compressor_names.get(compress_type)
+        if descr:
+            raise NotImplementedError("compression type %d (%s)" % (compress_type, descr))
+        else:
+            raise NotImplementedError("compression type %d" % (compress_type,))
+
+
+class _SharedFile:
+    def __init__(self, file, pos, close, lock, writing):
+        self._file = file
+        self._pos = pos
+        self._close = close
+        self._lock = lock
+        self._writing = writing
+        self.seekable = file.seekable
+        self.tell = file.tell
+
+    def seek(self, offset, whence=0):
+        with self._lock:
+            if self._writing():
+                raise ValueError("Can't reposition in the ZIP file while "
+                        "there is an open writing handle on it. "
+                        "Close the writing handle before trying to read.")
+            self._file.seek(offset, whence)
+            self._pos = self._file.tell()
+            return self._pos
+
+    def read(self, n=-1):
+        with self._lock:
+            if self._writing():
+                raise ValueError("Can't read from the ZIP file while there "
+                        "is an open writing handle on it. "
+                        "Close the writing handle before trying to read.")
+            self._file.seek(self._pos)
+            data = self._file.read(n)
+            self._pos = self._file.tell()
+            return data
+
+    def close(self):
+        if self._file is not None:
+            fileobj = self._file
+            self._file = None
+            self._close(fileobj)
+
+# Provide the tell method for unseekable stream
+class _Tellable:
+    def __init__(self, fp):
+        self.fp = fp
+        self.offset = 0
+
+    def write(self, data):
+        n = self.fp.write(data)
+        self.offset += n
+        return n
+
+    def tell(self):
+        return self.offset
+
+    def flush(self):
+        self.fp.flush()
+
+    def close(self):
+        self.fp.close()
+
+
+class ZipExtFile(io.BufferedIOBase):
+    """File-like object for reading an archive member.
+       Is returned by ZipFile.open().
+    """
+
+    # Max size supported by decompressor.
+    MAX_N = 1 << 31 - 1
+
+    # Read from compressed files in 4k blocks.
+    MIN_READ_SIZE = 4096
+
+    # Chunk size to read during seek
+    MAX_SEEK_READ = 1 << 24
+
+    def __init__(self, fileobj, mode, zipinfo, pwd=None,
+                 close_fileobj=False):
+        self._fileobj = fileobj
+        self._pwd = pwd
+        self._close_fileobj = close_fileobj
+
+        self._compress_type = zipinfo.compress_type
+        self._compress_left = zipinfo.compress_size
+        self._left = zipinfo.file_size
+
+        self._decompressor = _get_decompressor(self._compress_type)
+
+        self._eof = False
+        self._readbuffer = b''
+        self._offset = 0
+
+        self.newlines = None
+
+        self.mode = mode
+        self.name = zipinfo.filename
+
+        if hasattr(zipinfo, 'CRC'):
+            self._expected_crc = zipinfo.CRC
+            self._running_crc = crc32(b'')
+        else:
+            self._expected_crc = None
+
+        self._seekable = False
+        try:
+            if fileobj.seekable():
+                self._orig_compress_start = fileobj.tell()
+                self._orig_compress_size = zipinfo.compress_size
+                self._orig_file_size = zipinfo.file_size
+                self._orig_start_crc = self._running_crc
+                self._seekable = True
+        except AttributeError:
+            pass
+
+        self._decrypter = None
+        if pwd:
+            if zipinfo.flag_bits & 0x8:
+                # compare against the file type from extended local headers
+                check_byte = (zipinfo._raw_time >> 8) & 0xff
+            else:
+                # compare against the CRC otherwise
+                check_byte = (zipinfo.CRC >> 24) & 0xff
+            h = self._init_decrypter()
+            if h != check_byte:
+                raise RuntimeError("Bad password for file %r" % zipinfo.orig_filename)
+
+
+    def _init_decrypter(self):
+        self._decrypter = _ZipDecrypter(self._pwd)
+        # The first 12 bytes in the cypher stream is an encryption header
+        #  used to strengthen the algorithm. The first 11 bytes are
+        #  completely random, while the 12th contains the MSB of the CRC,
+        #  or the MSB of the file time depending on the header type
+        #  and is used to check the correctness of the password.
+        header = self._fileobj.read(12)
+        self._compress_left -= 12
+        return self._decrypter(header)[11]
+
+    def __repr__(self):
+        result = ['<%s.%s' % (self.__class__.__module__,
+                              self.__class__.__qualname__)]
+        if not self.closed:
+            result.append(' name=%r mode=%r' % (self.name, self.mode))
+            if self._compress_type != ZIP_STORED:
+                result.append(' compress_type=%s' %
+                              compressor_names.get(self._compress_type,
+                                                   self._compress_type))
+        else:
+            result.append(' [closed]')
+        result.append('>')
+        return ''.join(result)
+
+    def readline(self, limit=-1):
+        """Read and return a line from the stream.
+
+        If limit is specified, at most limit bytes will be read.
+        """
+
+        if limit < 0:
+            # Shortcut common case - newline found in buffer.
+            i = self._readbuffer.find(b'\n', self._offset) + 1
+            if i > 0:
+                line = self._readbuffer[self._offset: i]
+                self._offset = i
+                return line
+
+        return io.BufferedIOBase.readline(self, limit)
+
+    def peek(self, n=1):
+        """Returns buffered bytes without advancing the position."""
+        if n > len(self._readbuffer) - self._offset:
+            chunk = self.read(n)
+            if len(chunk) > self._offset:
+                self._readbuffer = chunk + self._readbuffer[self._offset:]
+                self._offset = 0
+            else:
+                self._offset -= len(chunk)
+
+        # Return up to 512 bytes to reduce allocation overhead for tight loops.
+        return self._readbuffer[self._offset: self._offset + 512]
+
+    def readable(self):
+        return True
+
+    def read(self, n=-1):
+        """Read and return up to n bytes.
+        If the argument is omitted, None, or negative, data is read and returned until EOF is reached.
+        """
+        if n is None or n < 0:
+            buf = self._readbuffer[self._offset:]
+            self._readbuffer = b''
+            self._offset = 0
+            while not self._eof:
+                buf += self._read1(self.MAX_N)
+            return buf
+
+        end = n + self._offset
+        if end < len(self._readbuffer):
+            buf = self._readbuffer[self._offset:end]
+            self._offset = end
+            return buf
+
+        n = end - len(self._readbuffer)
+        buf = self._readbuffer[self._offset:]
+        self._readbuffer = b''
+        self._offset = 0
+        while n > 0 and not self._eof:
+            data = self._read1(n)
+            if n < len(data):
+                self._readbuffer = data
+                self._offset = n
+                buf += data[:n]
+                break
+            buf += data
+            n -= len(data)
+        return buf
+
+    def _update_crc(self, newdata):
+        # Update the CRC using the given data.
+        if self._expected_crc is None:
+            # No need to compute the CRC if we don't have a reference value
+            return
+        self._running_crc = crc32(newdata, self._running_crc)
+        # Check the CRC if we're at the end of the file
+        if self._eof and self._running_crc != self._expected_crc:
+            raise BadZipFile("Bad CRC-32 for file %r" % self.name)
+
+    def read1(self, n):
+        """Read up to n bytes with at most one read() system call."""
+
+        if n is None or n < 0:
+            buf = self._readbuffer[self._offset:]
+            self._readbuffer = b''
+            self._offset = 0
+            while not self._eof:
+                data = self._read1(self.MAX_N)
+                if data:
+                    buf += data
+                    break
+            return buf
+
+        end = n + self._offset
+        if end < len(self._readbuffer):
+            buf = self._readbuffer[self._offset:end]
+            self._offset = end
+            return buf
+
+        n = end - len(self._readbuffer)
+        buf = self._readbuffer[self._offset:]
+        self._readbuffer = b''
+        self._offset = 0
+        if n > 0:
+            while not self._eof:
+                data = self._read1(n)
+                if n < len(data):
+                    self._readbuffer = data
+                    self._offset = n
+                    buf += data[:n]
+                    break
+                if data:
+                    buf += data
+                    break
+        return buf
+
+    def _read1(self, n):
+        # Read up to n compressed bytes with at most one read() system call,
+        # decrypt and decompress them.
+        if self._eof or n <= 0:
+            return b''
+
+        # Read from file.
+        if self._compress_type == ZIP_DEFLATED:
+            ## Handle unconsumed data.
+            data = self._decompressor.unconsumed_tail
+            if n > len(data):
+                data += self._read2(n - len(data))
+        else:
+            data = self._read2(n)
+
+        if self._compress_type == ZIP_STORED:
+            self._eof = self._compress_left <= 0
+        elif self._compress_type == ZIP_DEFLATED:
+            n = max(n, self.MIN_READ_SIZE)
+            data = self._decompressor.decompress(data, n)
+            self._eof = (self._decompressor.eof or
+                         self._compress_left <= 0 and
+                         not self._decompressor.unconsumed_tail)
+            if self._eof:
+                data += self._decompressor.flush()
+        else:
+            data = self._decompressor.decompress(data)
+            self._eof = self._decompressor.eof or self._compress_left <= 0
+
+        data = data[:self._left]
+        self._left -= len(data)
+        if self._left <= 0:
+            self._eof = True
+        self._update_crc(data)
+        return data
+
+    def _read2(self, n):
+        if self._compress_left <= 0:
+            return b''
+
+        n = max(n, self.MIN_READ_SIZE)
+        n = min(n, self._compress_left)
+
+        data = self._fileobj.read(n)
+        self._compress_left -= len(data)
+        if not data:
+            raise EOFError
+
+        if self._decrypter is not None:
+            data = self._decrypter(data)
+        return data
+
+    def close(self):
+        try:
+            if self._close_fileobj:
+                self._fileobj.close()
+        finally:
+            super().close()
+
+    def seekable(self):
+        return self._seekable
+
+    def seek(self, offset, whence=0):
+        if not self._seekable:
+            raise io.UnsupportedOperation("underlying stream is not seekable")
+        curr_pos = self.tell()
+        if whence == 0: # Seek from start of file
+            new_pos = offset
+        elif whence == 1: # Seek from current position
+            new_pos = curr_pos + offset
+        elif whence == 2: # Seek from EOF
+            new_pos = self._orig_file_size + offset
+        else:
+            raise ValueError("whence must be os.SEEK_SET (0), "
+                             "os.SEEK_CUR (1), or os.SEEK_END (2)")
+
+        if new_pos > self._orig_file_size:
+            new_pos = self._orig_file_size
+
+        if new_pos < 0:
+            new_pos = 0
+
+        read_offset = new_pos - curr_pos
+        buff_offset = read_offset + self._offset
+
+        if buff_offset >= 0 and buff_offset < len(self._readbuffer):
+            # Just move the _offset index if the new position is in the _readbuffer
+            self._offset = buff_offset
+            read_offset = 0
+        elif read_offset < 0:
+            # Position is before the current position. Reset the ZipExtFile
+            self._fileobj.seek(self._orig_compress_start)
+            self._running_crc = self._orig_start_crc
+            self._compress_left = self._orig_compress_size
+            self._left = self._orig_file_size
+            self._readbuffer = b''
+            self._offset = 0
+            self._decompressor = _get_decompressor(self._compress_type)
+            self._eof = False
+            read_offset = new_pos
+            if self._decrypter is not None:
+                self._init_decrypter()
+
+        while read_offset > 0:
+            read_len = min(self.MAX_SEEK_READ, read_offset)
+            self.read(read_len)
+            read_offset -= read_len
+
+        return self.tell()
+
+    def tell(self):
+        if not self._seekable:
+            raise io.UnsupportedOperation("underlying stream is not seekable")
+        filepos = self._orig_file_size - self._left - len(self._readbuffer) + self._offset
+        return filepos
+
+
+class _ZipWriteFile(io.BufferedIOBase):
+    def __init__(self, zf, zinfo, zip64):
+        self._zinfo = zinfo
+        self._zip64 = zip64
+        self._zipfile = zf
+        self._compressor = _get_compressor(zinfo.compress_type,
+                                           zinfo._compresslevel)
+        self._file_size = 0
+        self._compress_size = 0
+        self._crc = 0
+
+    @property
+    def _fileobj(self):
+        return self._zipfile.fp
+
+    def writable(self):
+        return True
+
+    def write(self, data):
+        if self.closed:
+            raise ValueError('I/O operation on closed file.')
+        nbytes = len(data)
+        self._file_size += nbytes
+        self._crc = crc32(data, self._crc)
+        if self._compressor:
+            data = self._compressor.compress(data)
+            self._compress_size += len(data)
+        self._fileobj.write(data)
+        return nbytes
+
+    def close(self):
+        if self.closed:
+            return
+        try:
+            super().close()
+            # Flush any data from the compressor, and update header info
+            if self._compressor:
+                buf = self._compressor.flush()
+                self._compress_size += len(buf)
+                self._fileobj.write(buf)
+                self._zinfo.compress_size = self._compress_size
+            else:
+                self._zinfo.compress_size = self._file_size
+            self._zinfo.CRC = self._crc
+            self._zinfo.file_size = self._file_size
+
+            # Write updated header info
+            if self._zinfo.flag_bits & 0x08:
+                # Write CRC and file sizes after the file data
+                fmt = '<LLQQ' if self._zip64 else '<LLLL'
+                self._fileobj.write(struct.pack(fmt, _DD_SIGNATURE, self._zinfo.CRC,
+                    self._zinfo.compress_size, self._zinfo.file_size))
+                self._zipfile.start_dir = self._fileobj.tell()
+            else:
+                if not self._zip64:
+                    if self._file_size > ZIP64_LIMIT:
+                        raise RuntimeError(
+                            'File size unexpectedly exceeded ZIP64 limit')
+                    if self._compress_size > ZIP64_LIMIT:
+                        raise RuntimeError(
+                            'Compressed size unexpectedly exceeded ZIP64 limit')
+                # Seek backwards and write file header (which will now include
+                # correct CRC and file sizes)
+
+                # Preserve current position in file
+                self._zipfile.start_dir = self._fileobj.tell()
+                self._fileobj.seek(self._zinfo.header_offset)
+                self._fileobj.write(self._zinfo.FileHeader(self._zip64))
+                self._fileobj.seek(self._zipfile.start_dir)
+
+            # Successfully written: Add file to our caches
+            self._zipfile.filelist.append(self._zinfo)
+            self._zipfile.NameToInfo[self._zinfo.filename] = self._zinfo
+        finally:
+            self._zipfile._writing = False
+
+
+
+class ZipFile:
+    """ Class with methods to open, read, write, close, list zip files.
+
+    z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
+                compresslevel=None)
+
+    file: Either the path to the file, or a file-like object.
+          If it is a path, the file will be opened and closed by ZipFile.
+    mode: The mode can be either read 'r', write 'w', exclusive create 'x',
+          or append 'a'.
+    compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
+                 ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
+    allowZip64: if True ZipFile will create files with ZIP64 extensions when
+                needed, otherwise it will raise an exception when this would
+                be necessary.
+    compresslevel: None (default for the given compression type) or an integer
+                   specifying the level to pass to the compressor.
+                   When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
+                   When using ZIP_DEFLATED integers 0 through 9 are accepted.
+                   When using ZIP_BZIP2 integers 1 through 9 are accepted.
+
+    """
+
+    fp = None                   # Set here since __del__ checks it
+    _windows_illegal_name_trans_table = None
+
+    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
+                 compresslevel=None):
+        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
+        or append 'a'."""
+        if mode not in ('r', 'w', 'x', 'a'):
+            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")
+
+        _check_compression(compression)
+
+        self._allowZip64 = allowZip64
+        self._didModify = False
+        self.debug = 0  # Level of printing: 0 through 3
+        self.NameToInfo = {}    # Find file info given name
+        self.filelist = []      # List of ZipInfo instances for archive
+        self.compression = compression  # Method of compression
+        self.compresslevel = compresslevel
+        self.mode = mode
+        self.pwd = None
+        self._comment = b''
+
+        # Check if we were passed a file-like object
+        if isinstance(file, os.PathLike):
+            file = os.fspath(file)
+        if isinstance(file, str):
+            # No, it's a filename
+            self._filePassed = 0
+            self.filename = file
+            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
+                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
+            filemode = modeDict[mode]
+            while True:
+                try:
+                    self.fp = io.open(file, filemode)
+                except OSError:
+                    if filemode in modeDict:
+                        filemode = modeDict[filemode]
+                        continue
+                    raise
+                break
+        else:
+            self._filePassed = 1
+            self.fp = file
+            self.filename = getattr(file, 'name', None)
+        self._fileRefCnt = 1
+        self._lock = threading.RLock()
+        self._seekable = True
+        self._writing = False
+
+        try:
+            if mode == 'r':
+                self._RealGetContents()
+            elif mode in ('w', 'x'):
+                # set the modified flag so central directory gets written
+                # even if no files are added to the archive
+                self._didModify = True
+                try:
+                    self.start_dir = self.fp.tell()
+                except (AttributeError, OSError):
+                    self.fp = _Tellable(self.fp)
+                    self.start_dir = 0
+                    self._seekable = False
+                else:
+                    # Some file-like objects can provide tell() but not seek()
+                    try:
+                        self.fp.seek(self.start_dir)
+                    except (AttributeError, OSError):
+                        self._seekable = False
+            elif mode == 'a':
+                try:
+                    # See if file is a zip file
+                    self._RealGetContents()
+                    # seek to start of directory and overwrite
+                    self.fp.seek(self.start_dir)
+                except BadZipFile:
+                    # file is not a zip file, just append
+                    self.fp.seek(0, 2)
+
+                    # set the modified flag so central directory gets written
+                    # even if no files are added to the archive
+                    self._didModify = True
+                    self.start_dir = self.fp.tell()
+            else:
+                raise ValueError("Mode must be 'r', 'w', 'x', or 'a'")
+        except:
+            fp = self.fp
+            self.fp = None
+            self._fpclose(fp)
+            raise
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, type, value, traceback):
+        self.close()
+
+    def __repr__(self):
+        result = ['<%s.%s' % (self.__class__.__module__,
+                              self.__class__.__qualname__)]
+        if self.fp is not None:
+            if self._filePassed:
+                result.append(' file=%r' % self.fp)
+            elif self.filename is not None:
+                result.append(' filename=%r' % self.filename)
+            result.append(' mode=%r' % self.mode)
+        else:
+            result.append(' [closed]')
+        result.append('>')
+        return ''.join(result)
+
+    def _RealGetContents(self):
+        """Read in the table of contents for the ZIP file."""
+        fp = self.fp
+        try:
+            endrec = _EndRecData(fp)
+        except OSError:
+            raise BadZipFile("File is not a zip file")
+        if not endrec:
+            raise BadZipFile("File is not a zip file")
+        if self.debug > 1:
+            print(endrec)
+        size_cd = endrec[_ECD_SIZE]             # bytes in central directory
+        offset_cd = endrec[_ECD_OFFSET]         # offset of central directory
+        self._comment = endrec[_ECD_COMMENT]    # archive comment
+
+        # "concat" is zero, unless zip was concatenated to another file
+        concat = endrec[_ECD_LOCATION] - size_cd - offset_cd
+        if endrec[_ECD_SIGNATURE] == stringEndArchive64:
+            # If Zip64 extension structures are present, account for them
+            concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)
+
+        if self.debug > 2:
+            inferred = concat + offset_cd
+            print("given, inferred, offset", offset_cd, inferred, concat)
+        # self.start_dir:  Position of start of central directory
+        self.start_dir = offset_cd + concat
+        fp.seek(self.start_dir, 0)
+        data = fp.read(size_cd)
+        fp = io.BytesIO(data)
+        total = 0
+        while total < size_cd:
+            centdir = fp.read(sizeCentralDir)
+            if len(centdir) != sizeCentralDir:
+                raise BadZipFile("Truncated central directory")
+            centdir = struct.unpack(structCentralDir, centdir)
+            if centdir[_CD_SIGNATURE] != stringCentralDir:
+                raise BadZipFile("Bad magic number for central directory")
+            if self.debug > 2:
+                print(centdir)
+            filename = fp.read(centdir[_CD_FILENAME_LENGTH])
+            flags = centdir[5]
+            if flags & 0x800:
+                # UTF-8 file names extension
+                filename = filename.decode('utf-8')
+            else:
+                # Historical ZIP filename encoding
+                # filename = filename.decode('cp437')
+                filename = filename.decode('gbk')
+            # Create ZipInfo instance to store file information
+            x = ZipInfo(filename)
+            x.extra = fp.read(centdir[_CD_EXTRA_FIELD_LENGTH])
+            x.comment = fp.read(centdir[_CD_COMMENT_LENGTH])
+            x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]
+            (x.create_version, x.create_system, x.extract_version, x.reserved,
+             x.flag_bits, x.compress_type, t, d,
+             x.CRC, x.compress_size, x.file_size) = centdir[1:12]
+            if x.extract_version > MAX_EXTRACT_VERSION:
+                raise NotImplementedError("zip file version %.1f" %
+                                          (x.extract_version / 10))
+            x.volume, x.internal_attr, x.external_attr = centdir[15:18]
+            # Convert date/time code to (year, month, day, hour, min, sec)
+            x._raw_time = t
+            x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,
+                            t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )
+
+            x._decodeExtra()
+            x.header_offset = x.header_offset + concat
+            self.filelist.append(x)
+            self.NameToInfo[x.filename] = x
+
+            # update total bytes read from central directory
+            total = (total + sizeCentralDir + centdir[_CD_FILENAME_LENGTH]
+                     + centdir[_CD_EXTRA_FIELD_LENGTH]
+                     + centdir[_CD_COMMENT_LENGTH])
+
+            if self.debug > 2:
+                print("total", total)
+
+
+    def namelist(self):
+        """Return a list of file names in the archive."""
+        return [data.filename for data in self.filelist]
+
+    def infolist(self):
+        """Return a list of class ZipInfo instances for files in the
+        archive."""
+        return self.filelist
+
+    def printdir(self, file=None):
+        """Print a table of contents for the zip file."""
+        print("%-46s %19s %12s" % ("File Name", "Modified    ", "Size"),
+              file=file)
+        for zinfo in self.filelist:
+            date = "%d-%02d-%02d %02d:%02d:%02d" % zinfo.date_time[:6]
+            print("%-46s %s %12d" % (zinfo.filename, date, zinfo.file_size),
+                  file=file)
+
+    def testzip(self):
+        """Read all the files and check the CRC."""
+        chunk_size = 2 ** 20
+        for zinfo in self.filelist:
+            try:
+                # Read by chunks, to avoid an OverflowError or a
+                # MemoryError with very large embedded files.
+                with self.open(zinfo.filename, "r") as f:
+                    while f.read(chunk_size):     # Check CRC-32
+                        pass
+            except BadZipFile:
+                return zinfo.filename
+
+    def getinfo(self, name):
+        """Return the instance of ZipInfo given 'name'."""
+        info = self.NameToInfo.get(name)
+        if info is None:
+            raise KeyError(
+                'There is no item named %r in the archive' % name)
+
+        return info
+
+    def setpassword(self, pwd):
+        """Set default password for encrypted files."""
+        if pwd and not isinstance(pwd, bytes):
+            raise TypeError("pwd: expected bytes, got %s" % type(pwd).__name__)
+        if pwd:
+            self.pwd = pwd
+        else:
+            self.pwd = None
+
+    @property
+    def comment(self):
+        """The comment text associated with the ZIP file."""
+        return self._comment
+
+    @comment.setter
+    def comment(self, comment):
+        if not isinstance(comment, bytes):
+            raise TypeError("comment: expected bytes, got %s" % type(comment).__name__)
+        # check for valid comment length
+        if len(comment) > ZIP_MAX_COMMENT:
+            import warnings
+            warnings.warn('Archive comment is too long; truncating to %d bytes'
+                          % ZIP_MAX_COMMENT, stacklevel=2)
+            comment = comment[:ZIP_MAX_COMMENT]
+        self._comment = comment
+        self._didModify = True
+
+    def read(self, name, pwd=None):
+        """Return file bytes for name."""
+        with self.open(name, "r", pwd) as fp:
+            return fp.read()
+
+    def open(self, name, mode="r", pwd=None, *, force_zip64=False):
+        """Return file-like object for 'name'.
+
+        name is a string for the file name within the ZIP file, or a ZipInfo
+        object.
+
+        mode should be 'r' to read a file already in the ZIP file, or 'w' to
+        write to a file newly added to the archive.
+
+        pwd is the password to decrypt files (only used for reading).
+
+        When writing, if the file size is not known in advance but may exceed
+        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
+        files.  If the size is known in advance, it is best to pass a ZipInfo
+        instance for name, with zinfo.file_size set.
+        """
+        if mode not in {"r", "w"}:
+            raise ValueError('open() requires mode "r" or "w"')
+        if pwd and not isinstance(pwd, bytes):
+            raise TypeError("pwd: expected bytes, got %s" % type(pwd).__name__)
+        if pwd and (mode == "w"):
+            raise ValueError("pwd is only supported for reading files")
+        if not self.fp:
+            raise ValueError(
+                "Attempt to use ZIP archive that was already closed")
+
+        # Make sure we have an info object
+        if isinstance(name, ZipInfo):
+            # 'name' is already an info object
+            zinfo = name
+        elif mode == 'w':
+            zinfo = ZipInfo(name)
+            zinfo.compress_type = self.compression
+            zinfo._compresslevel = self.compresslevel
+        else:
+            # Get info object for name
+            zinfo = self.getinfo(name)
+
+        if mode == 'w':
+            return self._open_to_write(zinfo, force_zip64=force_zip64)
+
+        if self._writing:
+            raise ValueError("Can't read from the ZIP file while there "
+                    "is an open writing handle on it. "
+                    "Close the writing handle before trying to read.")
+
+        # Open for reading:
+        self._fileRefCnt += 1
+        zef_file = _SharedFile(self.fp, zinfo.header_offset,
+                               self._fpclose, self._lock, lambda: self._writing)
+        try:
+            # Skip the file header:
+            fheader = zef_file.read(sizeFileHeader)
+            if len(fheader) != sizeFileHeader:
+                raise BadZipFile("Truncated file header")
+            fheader = struct.unpack(structFileHeader, fheader)
+            if fheader[_FH_SIGNATURE] != stringFileHeader:
+                raise BadZipFile("Bad magic number for file header")
+
+            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])
+            if fheader[_FH_EXTRA_FIELD_LENGTH]:
+                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])
+
+            if zinfo.flag_bits & 0x20:
+                # Zip 2.7: compressed patched data
+                raise NotImplementedError("compressed patched data (flag bit 5)")
+
+            if zinfo.flag_bits & 0x40:
+                # strong encryption
+                raise NotImplementedError("strong encryption (flag bit 6)")
+
+            if zinfo.flag_bits & 0x800:
+                # UTF-8 filename
+                fname_str = fname.decode("utf-8")
+            else:
+                # fname_str = fname.decode("cp437")
+                fname_str = fname.decode("gbk")
+
+            if fname_str != zinfo.orig_filename:
+                raise BadZipFile(
+                    'File name in directory %r and header %r differ.'
+                    % (zinfo.orig_filename, fname))
+
+            # check for encrypted flag & handle password
+            is_encrypted = zinfo.flag_bits & 0x1
+            if is_encrypted:
+                if not pwd:
+                    pwd = self.pwd
+                if not pwd:
+                    raise RuntimeError("File %r is encrypted, password "
+                                       "required for extraction" % name)
+            else:
+                pwd = None
+
+            return ZipExtFile(zef_file, mode, zinfo, pwd, True)
+        except:
+            zef_file.close()
+            raise
+
+    def _open_to_write(self, zinfo, force_zip64=False):
+        if force_zip64 and not self._allowZip64:
+            raise ValueError(
+                "force_zip64 is True, but allowZip64 was False when opening "
+                "the ZIP file."
+            )
+        if self._writing:
+            raise ValueError("Can't write to the ZIP file while there is "
+                             "another write handle open on it. "
+                             "Close the first handle before opening another.")
+
+        # Sizes and CRC are overwritten with correct data after processing the file
+        if not hasattr(zinfo, 'file_size'):
+            zinfo.file_size = 0
+        zinfo.compress_size = 0
+        zinfo.CRC = 0
+
+        zinfo.flag_bits = 0x00
+        if zinfo.compress_type == ZIP_LZMA:
+            # Compressed data includes an end-of-stream (EOS) marker
+            zinfo.flag_bits |= 0x02
+        if not self._seekable:
+            zinfo.flag_bits |= 0x08
+
+        if not zinfo.external_attr:
+            zinfo.external_attr = 0o600 << 16  # permissions: ?rw-------
+
+        # Compressed size can be larger than uncompressed size
+        zip64 = self._allowZip64 and \
+                (force_zip64 or zinfo.file_size * 1.05 > ZIP64_LIMIT)
+
+        if self._seekable:
+            self.fp.seek(self.start_dir)
+        zinfo.header_offset = self.fp.tell()
+
+        self._writecheck(zinfo)
+        self._didModify = True
+
+        self.fp.write(zinfo.FileHeader(zip64))
+
+        self._writing = True
+        return _ZipWriteFile(self, zinfo, zip64)
+
+    def extract(self, member, path=None, pwd=None):
+        """Extract a member from the archive to the current working directory,
+           using its full name. Its file information is extracted as accurately
+           as possible. `member' may be a filename or a ZipInfo object. You can
+           specify a different directory using `path'.
+        """
+        if path is None:
+            path = os.getcwd()
+        else:
+            path = os.fspath(path)
+
+        return self._extract_member(member, path, pwd)
+
+    def extractall(self, path=None, members=None, pwd=None):
+        """Extract all members from the archive to the current working
+           directory. `path' specifies a different directory to extract to.
+           `members' is optional and must be a subset of the list returned
+           by namelist().
+        """
+        if members is None:
+            members = self.namelist()
+
+        if path is None:
+            path = os.getcwd()
+        else:
+            path = os.fspath(path)
+
+        for zipinfo in members:
+            self._extract_member(zipinfo, path, pwd)
+
+    @classmethod
+    def _sanitize_windows_name(cls, arcname, pathsep):
+        """Replace bad characters and remove trailing dots from parts."""
+        table = cls._windows_illegal_name_trans_table
+        if not table:
+            illegal = ':<>|"?*'
+            table = str.maketrans(illegal, '_' * len(illegal))
+            cls._windows_illegal_name_trans_table = table
+        arcname = arcname.translate(table)
+        # remove trailing dots
+        arcname = (x.rstrip('.') for x in arcname.split(pathsep))
+        # rejoin, removing empty parts.
+        arcname = pathsep.join(x for x in arcname if x)
+        return arcname
+
+    def _extract_member(self, member, targetpath, pwd):
+        """Extract the ZipInfo object 'member' to a physical
+           file on the path targetpath.
+        """
+        if not isinstance(member, ZipInfo):
+            member = self.getinfo(member)
+
+        # build the destination pathname, replacing
+        # forward slashes to platform specific separators.
+        arcname = member.filename.replace('/', os.path.sep)
+
+        if os.path.altsep:
+            arcname = arcname.replace(os.path.altsep, os.path.sep)
+        # interpret absolute pathname as relative, remove drive letter or
+        # UNC path, redundant separators, "." and ".." components.
+        arcname = os.path.splitdrive(arcname)[1]
+        invalid_path_parts = ('', os.path.curdir, os.path.pardir)
+        arcname = os.path.sep.join(x for x in arcname.split(os.path.sep)
+                                   if x not in invalid_path_parts)
+        if os.path.sep == '\\':
+            # filter illegal characters on Windows
+            arcname = self._sanitize_windows_name(arcname, os.path.sep)
+
+        targetpath = os.path.join(targetpath, arcname)
+        targetpath = os.path.normpath(targetpath)
+
+        # Create all upper directories if necessary.
+        upperdirs = os.path.dirname(targetpath)
+        if upperdirs and not os.path.exists(upperdirs):
+            os.makedirs(upperdirs)
+
+        if member.is_dir():
+            if not os.path.isdir(targetpath):
+                os.mkdir(targetpath)
+            return targetpath
+
+        with self.open(member, pwd=pwd) as source, \
+             open(targetpath, "wb") as target:
+            shutil.copyfileobj(source, target)
+
+        return targetpath
+
+    def _writecheck(self, zinfo):
+        """Check for errors before writing a file to the archive."""
+        if zinfo.filename in self.NameToInfo:
+            import warnings
+            warnings.warn('Duplicate name: %r' % zinfo.filename, stacklevel=3)
+        if self.mode not in ('w', 'x', 'a'):
+            raise ValueError("write() requires mode 'w', 'x', or 'a'")
+        if not self.fp:
+            raise ValueError(
+                "Attempt to write ZIP archive that was already closed")
+        _check_compression(zinfo.compress_type)
+        if not self._allowZip64:
+            requires_zip64 = None
+            if len(self.filelist) >= ZIP_FILECOUNT_LIMIT:
+                requires_zip64 = "Files count"
+            elif zinfo.file_size > ZIP64_LIMIT:
+                requires_zip64 = "Filesize"
+            elif zinfo.header_offset > ZIP64_LIMIT:
+                requires_zip64 = "Zipfile size"
+            if requires_zip64:
+                raise LargeZipFile(requires_zip64 +
+                                   " would require ZIP64 extensions")
+
+    def write(self, filename, arcname=None,
+              compress_type=None, compresslevel=None):
+        """Put the bytes from filename into the archive under the name
+        arcname."""
+        if not self.fp:
+            raise ValueError(
+                "Attempt to write to ZIP archive that was already closed")
+        if self._writing:
+            raise ValueError(
+                "Can't write to ZIP archive while an open writing handle exists"
+            )
+
+        zinfo = ZipInfo.from_file(filename, arcname)
+
+        if zinfo.is_dir():
+            zinfo.compress_size = 0
+            zinfo.CRC = 0
+        else:
+            if compress_type is not None:
+                zinfo.compress_type = compress_type
+            else:
+                zinfo.compress_type = self.compression
+
+            if compresslevel is not None:
+                zinfo._compresslevel = compresslevel
+            else:
+                zinfo._compresslevel = self.compresslevel
+
+        if zinfo.is_dir():
+            with self._lock:
+                if self._seekable:
+                    self.fp.seek(self.start_dir)
+                zinfo.header_offset = self.fp.tell()  # Start of header bytes
+                if zinfo.compress_type == ZIP_LZMA:
+                # Compressed data includes an end-of-stream (EOS) marker
+                    zinfo.flag_bits |= 0x02
+
+                self._writecheck(zinfo)
+                self._didModify = True
+
+                self.filelist.append(zinfo)
+                self.NameToInfo[zinfo.filename] = zinfo
+                self.fp.write(zinfo.FileHeader(False))
+                self.start_dir = self.fp.tell()
+        else:
+            with open(filename, "rb") as src, self.open(zinfo, 'w') as dest:
+                shutil.copyfileobj(src, dest, 1024*8)
+
+    def writestr(self, zinfo_or_arcname, data,
+                 compress_type=None, compresslevel=None):
+        """Write a file into the archive.  The contents is 'data', which
+        may be either a 'str' or a 'bytes' instance; if it is a 'str',
+        it is encoded as UTF-8 first.
+        'zinfo_or_arcname' is either a ZipInfo instance or
+        the name of the file in the archive."""
+        if isinstance(data, str):
+            data = data.encode("utf-8")
+        if not isinstance(zinfo_or_arcname, ZipInfo):
+            zinfo = ZipInfo(filename=zinfo_or_arcname,
+                            date_time=time.localtime(time.time())[:6])
+            zinfo.compress_type = self.compression
+            zinfo._compresslevel = self.compresslevel
+            if zinfo.filename[-1] == '/':
+                zinfo.external_attr = 0o40775 << 16   # drwxrwxr-x
+                zinfo.external_attr |= 0x10           # MS-DOS directory flag
+            else:
+                zinfo.external_attr = 0o600 << 16     # ?rw-------
+        else:
+            zinfo = zinfo_or_arcname
+
+        if not self.fp:
+            raise ValueError(
+                "Attempt to write to ZIP archive that was already closed")
+        if self._writing:
+            raise ValueError(
+                "Can't write to ZIP archive while an open writing handle exists."
+            )
+
+        if compress_type is not None:
+            zinfo.compress_type = compress_type
+
+        if compresslevel is not None:
+            zinfo._compresslevel = compresslevel
+
+        zinfo.file_size = len(data)            # Uncompressed size
+        with self._lock:
+            with self.open(zinfo, mode='w') as dest:
+                dest.write(data)
+
+    def __del__(self):
+        """Call the "close()" method in case the user forgot."""
+        self.close()
+
+    def close(self):
+        """Close the file, and for mode 'w', 'x' and 'a' write the ending
+        records."""
+        if self.fp is None:
+            return
+
+        if self._writing:
+            raise ValueError("Can't close the ZIP file while there is "
+                             "an open writing handle on it. "
+                             "Close the writing handle before closing the zip.")
+
+        try:
+            if self.mode in ('w', 'x', 'a') and self._didModify: # write ending records
+                with self._lock:
+                    if self._seekable:
+                        self.fp.seek(self.start_dir)
+                    self._write_end_record()
+        finally:
+            fp = self.fp
+            self.fp = None
+            self._fpclose(fp)
+
+    def _write_end_record(self):
+        for zinfo in self.filelist:         # write central directory
+            dt = zinfo.date_time
+            dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
+            dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
+            extra = []
+            if zinfo.file_size > ZIP64_LIMIT \
+               or zinfo.compress_size > ZIP64_LIMIT:
+                extra.append(zinfo.file_size)
+                extra.append(zinfo.compress_size)
+                file_size = 0xffffffff
+                compress_size = 0xffffffff
+            else:
+                file_size = zinfo.file_size
+                compress_size = zinfo.compress_size
+
+            if zinfo.header_offset > ZIP64_LIMIT:
+                extra.append(zinfo.header_offset)
+                header_offset = 0xffffffff
+            else:
+                header_offset = zinfo.header_offset
+
+            extra_data = zinfo.extra
+            min_version = 0
+            if extra:
+                # Append a ZIP64 field to the extra's
+                extra_data = _strip_extra(extra_data, (1,))
+                extra_data = struct.pack(
+                    '<HH' + 'Q'*len(extra),
+                    1, 8*len(extra), *extra) + extra_data
+
+                min_version = ZIP64_VERSION
+
+            if zinfo.compress_type == ZIP_BZIP2:
+                min_version = max(BZIP2_VERSION, min_version)
+            elif zinfo.compress_type == ZIP_LZMA:
+                min_version = max(LZMA_VERSION, min_version)
+
+            extract_version = max(min_version, zinfo.extract_version)
+            create_version = max(min_version, zinfo.create_version)
+            try:
+                filename, flag_bits = zinfo._encodeFilenameFlags()
+                centdir = struct.pack(structCentralDir,
+                                      stringCentralDir, create_version,
+                                      zinfo.create_system, extract_version, zinfo.reserved,
+                                      flag_bits, zinfo.compress_type, dostime, dosdate,
+                                      zinfo.CRC, compress_size, file_size,
+                                      len(filename), len(extra_data), len(zinfo.comment),
+                                      0, zinfo.internal_attr, zinfo.external_attr,
+                                      header_offset)
+            except DeprecationWarning:
+                print((structCentralDir, stringCentralDir, create_version,
+                       zinfo.create_system, extract_version, zinfo.reserved,
+                       zinfo.flag_bits, zinfo.compress_type, dostime, dosdate,
+                       zinfo.CRC, compress_size, file_size,
+                       len(zinfo.filename), len(extra_data), len(zinfo.comment),
+                       0, zinfo.internal_attr, zinfo.external_attr,
+                       header_offset), file=sys.stderr)
+                raise
+            self.fp.write(centdir)
+            self.fp.write(filename)
+            self.fp.write(extra_data)
+            self.fp.write(zinfo.comment)
+
+        pos2 = self.fp.tell()
+        # Write end-of-zip-archive record
+        centDirCount = len(self.filelist)
+        centDirSize = pos2 - self.start_dir
+        centDirOffset = self.start_dir
+        requires_zip64 = None
+        if centDirCount > ZIP_FILECOUNT_LIMIT:
+            requires_zip64 = "Files count"
+        elif centDirOffset > ZIP64_LIMIT:
+            requires_zip64 = "Central directory offset"
+        elif centDirSize > ZIP64_LIMIT:
+            requires_zip64 = "Central directory size"
+        if requires_zip64:
+            # Need to write the ZIP64 end-of-archive records
+            if not self._allowZip64:
+                raise LargeZipFile(requires_zip64 +
+                                   " would require ZIP64 extensions")
+            zip64endrec = struct.pack(
+                structEndArchive64, stringEndArchive64,
+                44, 45, 45, 0, 0, centDirCount, centDirCount,
+                centDirSize, centDirOffset)
+            self.fp.write(zip64endrec)
+
+            zip64locrec = struct.pack(
+                structEndArchive64Locator,
+                stringEndArchive64Locator, 0, pos2, 1)
+            self.fp.write(zip64locrec)
+            centDirCount = min(centDirCount, 0xFFFF)
+            centDirSize = min(centDirSize, 0xFFFFFFFF)
+            centDirOffset = min(centDirOffset, 0xFFFFFFFF)
+
+        endrec = struct.pack(structEndArchive, stringEndArchive,
+                             0, 0, centDirCount, centDirCount,
+                             centDirSize, centDirOffset, len(self._comment))
+        self.fp.write(endrec)
+        self.fp.write(self._comment)
+        self.fp.flush()
+
+    def _fpclose(self, fp):
+        assert self._fileRefCnt > 0
+        self._fileRefCnt -= 1
+        if not self._fileRefCnt and not self._filePassed:
+            fp.close()
+
+
+class PyZipFile(ZipFile):
+    """Class to create ZIP archives with Python library files and packages."""
+
+    def __init__(self, file, mode="r", compression=ZIP_STORED,
+                 allowZip64=True, optimize=-1):
+        ZipFile.__init__(self, file, mode=mode, compression=compression,
+                         allowZip64=allowZip64)
+        self._optimize = optimize
+
+    def writepy(self, pathname, basename="", filterfunc=None):
+        """Add all files from "pathname" to the ZIP archive.
+
+        If pathname is a package directory, search the directory and
+        all package subdirectories recursively for all *.py and enter
+        the modules into the archive.  If pathname is a plain
+        directory, listdir *.py and enter all modules.  Else, pathname
+        must be a Python *.py file and the module will be put into the
+        archive.  Added modules are always module.pyc.
+        This method will compile the module.py into module.pyc if
+        necessary.
+        If filterfunc(pathname) is given, it is called with every argument.
+        When it is False, the file or directory is skipped.
+        """
+        pathname = os.fspath(pathname)
+        if filterfunc and not filterfunc(pathname):
+            if self.debug:
+                label = 'path' if os.path.isdir(pathname) else 'file'
+                print('%s %r skipped by filterfunc' % (label, pathname))
+            return
+        dir, name = os.path.split(pathname)
+        if os.path.isdir(pathname):
+            initname = os.path.join(pathname, "__init__.py")
+            if os.path.isfile(initname):
+                # This is a package directory, add it
+                if basename:
+                    basename = "%s/%s" % (basename, name)
+                else:
+                    basename = name
+                if self.debug:
+                    print("Adding package in", pathname, "as", basename)
+                fname, arcname = self._get_codename(initname[0:-3], basename)
+                if self.debug:
+                    print("Adding", arcname)
+                self.write(fname, arcname)
+                dirlist = sorted(os.listdir(pathname))
+                dirlist.remove("__init__.py")
+                # Add all *.py files and package subdirectories
+                for filename in dirlist:
+                    path = os.path.join(pathname, filename)
+                    root, ext = os.path.splitext(filename)
+                    if os.path.isdir(path):
+                        if os.path.isfile(os.path.join(path, "__init__.py")):
+                            # This is a package directory, add it
+                            self.writepy(path, basename,
+                                         filterfunc=filterfunc)  # Recursive call
+                    elif ext == ".py":
+                        if filterfunc and not filterfunc(path):
+                            if self.debug:
+                                print('file %r skipped by filterfunc' % path)
+                            continue
+                        fname, arcname = self._get_codename(path[0:-3],
+                                                            basename)
+                        if self.debug:
+                            print("Adding", arcname)
+                        self.write(fname, arcname)
+            else:
+                # This is NOT a package directory, add its files at top level
+                if self.debug:
+                    print("Adding files from directory", pathname)
+                for filename in sorted(os.listdir(pathname)):
+                    path = os.path.join(pathname, filename)
+                    root, ext = os.path.splitext(filename)
+                    if ext == ".py":
+                        if filterfunc and not filterfunc(path):
+                            if self.debug:
+                                print('file %r skipped by filterfunc' % path)
+                            continue
+                        fname, arcname = self._get_codename(path[0:-3],
+                                                            basename)
+                        if self.debug:
+                            print("Adding", arcname)
+                        self.write(fname, arcname)
+        else:
+            if pathname[-3:] != ".py":
+                raise RuntimeError(
+                    'Files added with writepy() must end with ".py"')
+            fname, arcname = self._get_codename(pathname[0:-3], basename)
+            if self.debug:
+                print("Adding file", arcname)
+            self.write(fname, arcname)
+
+    def _get_codename(self, pathname, basename):
+        """Return (filename, archivename) for the path.
+
+        Given a module name path, return the correct file path and
+        archive name, compiling if necessary.  For example, given
+        /python/lib/string, return (/python/lib/string.pyc, string).
+        """
+        def _compile(file, optimize=-1):
+            import py_compile
+            if self.debug:
+                print("Compiling", file)
+            try:
+                py_compile.compile(file, doraise=True, optimize=optimize)
+            except py_compile.PyCompileError as err:
+                print(err.msg)
+                return False
+            return True
+
+        file_py  = pathname + ".py"
+        file_pyc = pathname + ".pyc"
+        pycache_opt0 = importlib.util.cache_from_source(file_py, optimization='')
+        pycache_opt1 = importlib.util.cache_from_source(file_py, optimization=1)
+        pycache_opt2 = importlib.util.cache_from_source(file_py, optimization=2)
+        if self._optimize == -1:
+            # legacy mode: use whatever file is present
+            if (os.path.isfile(file_pyc) and
+                  os.stat(file_pyc).st_mtime >= os.stat(file_py).st_mtime):
+                # Use .pyc file.
+                arcname = fname = file_pyc
+            elif (os.path.isfile(pycache_opt0) and
+                  os.stat(pycache_opt0).st_mtime >= os.stat(file_py).st_mtime):
+                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
+                # file name in the archive.
+                fname = pycache_opt0
+                arcname = file_pyc
+            elif (os.path.isfile(pycache_opt1) and
+                  os.stat(pycache_opt1).st_mtime >= os.stat(file_py).st_mtime):
+                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
+                # file name in the archive.
+                fname = pycache_opt1
+                arcname = file_pyc
+            elif (os.path.isfile(pycache_opt2) and
+                  os.stat(pycache_opt2).st_mtime >= os.stat(file_py).st_mtime):
+                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
+                # file name in the archive.
+                fname = pycache_opt2
+                arcname = file_pyc
+            else:
+                # Compile py into PEP 3147 pyc file.
+                if _compile(file_py):
+                    if sys.flags.optimize == 0:
+                        fname = pycache_opt0
+                    elif sys.flags.optimize == 1:
+                        fname = pycache_opt1
+                    else:
+                        fname = pycache_opt2
+                    arcname = file_pyc
+                else:
+                    fname = arcname = file_py
+        else:
+            # new mode: use given optimization level
+            if self._optimize == 0:
+                fname = pycache_opt0
+                arcname = file_pyc
+            else:
+                arcname = file_pyc
+                if self._optimize == 1:
+                    fname = pycache_opt1
+                elif self._optimize == 2:
+                    fname = pycache_opt2
+                else:
+                    msg = "invalid value for 'optimize': {!r}".format(self._optimize)
+                    raise ValueError(msg)
+            if not (os.path.isfile(fname) and
+                    os.stat(fname).st_mtime >= os.stat(file_py).st_mtime):
+                if not _compile(file_py, optimize=self._optimize):
+                    fname = arcname = file_py
+        archivename = os.path.split(arcname)[1]
+        if basename:
+            archivename = "%s/%s" % (basename, archivename)
+        return (fname, archivename)
+
+
+def main(args=None):
+    import argparse
+
+    description = 'A simple command-line interface for zipfile module.'
+    parser = argparse.ArgumentParser(description=description)
+    group = parser.add_mutually_exclusive_group(required=True)
+    group.add_argument('-l', '--list', metavar='<zipfile>',
+                       help='Show listing of a zipfile')
+    group.add_argument('-e', '--extract', nargs=2,
+                       metavar=('<zipfile>', '<output_dir>'),
+                       help='Extract zipfile into target dir')
+    group.add_argument('-c', '--create', nargs='+',
+                       metavar=('<name>', '<file>'),
+                       help='Create zipfile from sources')
+    group.add_argument('-t', '--test', metavar='<zipfile>',
+                       help='Test if a zipfile is valid')
+    args = parser.parse_args(args)
+
+    if args.test is not None:
+        src = args.test
+        with ZipFile(src, 'r') as zf:
+            badfile = zf.testzip()
+        if badfile:
+            print("The following enclosed file is corrupted: {!r}".format(badfile))
+        print("Done testing")
+
+    elif args.list is not None:
+        src = args.list
+        with ZipFile(src, 'r') as zf:
+            zf.printdir()
+
+    elif args.extract is not None:
+        src, curdir = args.extract
+        with ZipFile(src, 'r') as zf:
+            zf.extractall(curdir)
+
+    elif args.create is not None:
+        zip_name = args.create.pop(0)
+        files = args.create
+
+        def addToZip(zf, path, zippath):
+            if os.path.isfile(path):
+                zf.write(path, zippath, ZIP_DEFLATED)
+            elif os.path.isdir(path):
+                if zippath:
+                    zf.write(path, zippath)
+                for nm in sorted(os.listdir(path)):
+                    addToZip(zf,
+                             os.path.join(path, nm), os.path.join(zippath, nm))
+            # else: ignore
+
+        with ZipFile(zip_name, 'w') as zf:
+            for path in files:
+                zippath = os.path.basename(path)
+                if not zippath:
+                    zippath = os.path.basename(os.path.dirname(path))
+                if zippath in ('', os.curdir, os.pardir):
+                    zippath = ''
+                addToZip(zf, path, zippath)
+
+if __name__ == "__main__":
+    main()
```

## toollib/common/__pycache__/__init__.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 104 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 6800 0000  U.........ech...
+00000000: 550d 0d0a 0000 0000 4442 4664 6000 0000  U.......DBFd`...
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0001 0000 0040 0000 0073 0800 0000 6400  .....@...s....d.
 00000030: 5a00 6401 5300 2902 7a59 0a40 6175 7468  Z.d.S.).zY.@auth
 00000040: 6f72 2061 7869 6e65 720a 4076 6572 7369  or axiner.@versi
 00000050: 6f6e 2076 312e 302e 300a 4063 7265 6174  on v1.0.0.@creat
 00000060: 6564 2032 3032 322f 312f 3131 2032 323a  ed 2022/1/11 22:
 00000070: 3131 0a40 6162 7374 7261 6374 0a40 6465  11.@abstract.@de
```

## toollib/common/__pycache__/constor.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Thu Apr 20 09:52:09 2023 UTC, .py size: 1217 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 490b 4164 c104 0000  U.......I.Ad....
+00000000: 550d 0d0a 0000 0000 4442 4664 ae04 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0004 0000 0040 0000 0073 2200 0000 6400  .....@...s"...d.
 00000030: 5a00 6401 5a01 6402 5a02 6403 5a03 6404  Z.d.Z.d.Z.d.Z.d.
 00000040: 6405 6406 6407 6703 6901 5a04 6408 5300  d.d.d.g.i.Z.d.S.
 00000050: 2909 7a59 0a40 6175 7468 6f72 2061 7869  ).zY.@author axi
 00000060: 6e65 720a 4076 6572 7369 6f6e 2076 312e  ner.@version v1.
 00000070: 302e 300a 4063 7265 6174 6564 2032 3032  0.0.@created 202
```

## toollib/common/__pycache__/error.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 492 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 ec01 0000  U.........ec....
+00000000: 550d 0d0a 0000 0000 4442 4664 d001 0000  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0004 0000 0040 0000 0073 3800 0000 6400  .....@...s8...d.
 00000030: 5a00 4700 6401 6402 8400 6402 6501 8303  Z.G.d.d...d.e...
 00000040: 5a02 4700 6403 6404 8400 6404 6502 8303  Z.G.d.d...d.e...
 00000050: 5a03 4700 6405 6406 8400 6406 6502 8303  Z.G.d.d...d.e...
 00000060: 5a04 6407 5300 2908 7a58 0a40 6175 7468  Z.d.S.).zX.@auth
 00000070: 6f72 2061 7869 6e65 720a 4076 6572 7369  or axiner.@versi
```

## toollib/common/__pycache__/rarfile.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 103206 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 2693 0100  U.........ec&...
+00000000: 550d 0d0a 0000 0000 4442 4664 0186 0100  U.......DBFd....
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0010 0000 0040 0000 0073 7c08 0000 6400  .....@...s|...d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a03 6401 6402 6c04  Z.d.d.l.Z.d.d.l.
 00000050: 5a04 6401 6402 6c05 5a05 6401 6402 6c06  Z.d.d.l.Z.d.d.l.
 00000060: 5a06 6401 6402 6c07 5a07 6401 6402 6c08  Z.d.d.l.Z.d.d.l.
 00000070: 5a08 6401 6403 6c09 6d0a 5a0a 6d0b 5a0b  Z.d.d.l.m.Z.m.Z.
```

## toollib/common/__pycache__/zipfile.cpython-38.pyc

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.8, timestamp-based, .py timestamp: Fri Nov  4 14:21:30 2022 UTC, .py size: 83375 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

```diff
@@ -1,8 +1,8 @@
-00000000: 550d 0d0a 0000 0000 ea1f 6563 af45 0100  U.........ec.E..
+00000000: 550d 0d0a 0000 0000 4442 4664 2c3d 0100  U.......DBFd,=..
 00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
 00000020: 0012 0000 0040 0000 0073 a003 0000 6400  .....@...s....d.
 00000030: 5a00 6401 6402 6c01 5a01 6401 6402 6c02  Z.d.d.l.Z.d.d.l.
 00000040: 5a02 6401 6402 6c03 5a04 6401 6402 6c05  Z.d.d.l.Z.d.d.l.
 00000050: 5a05 6401 6402 6c06 5a06 6401 6402 6c07  Z.d.d.l.Z.d.d.l.
 00000060: 5a07 6401 6402 6c08 5a08 6401 6402 6c09  Z.d.d.l.Z.d.d.l.
 00000070: 5a09 6401 6402 6c0a 5a0a 6401 6402 6c0b  Z.d.d.l.Z.d.d.l.
@@ -2070,15 +2070,15 @@
 00008150: 6f77 6e20 696e 2061 6476 616e 6365 2c20  own in advance, 
 00008160: 6974 2069 7320 6265 7374 2074 6f20 7061  it is best to pa
 00008170: 7373 2061 205a 6970 496e 666f 0a20 2020  ss a ZipInfo.   
 00008180: 2020 2020 2069 6e73 7461 6e63 6520 666f       instance fo
 00008190: 7220 6e61 6d65 2c20 7769 7468 207a 696e  r name, with zin
 000081a0: 666f 2e66 696c 655f 7369 7a65 2073 6574  fo.file_size set
 000081b0: 2e0a 2020 2020 2020 2020 3e02 0000 0072  ..        >....r
-000081c0: 6901 0000 7268 0100 007a 1f6f 7065 6e28  i...rh...z.open(
+000081c0: 6801 0000 7269 0100 007a 1f6f 7065 6e28  h...ri...z.open(
 000081d0: 2920 7265 7175 6972 6573 206d 6f64 6520  ) requires mode 
 000081e0: 2272 2220 6f72 2022 7722 72a7 0100 0072  "r" or "w"r....r
 000081f0: 6901 0000 7a27 7077 6420 6973 206f 6e6c  i...z'pwd is onl
 00008200: 7920 7375 7070 6f72 7465 6420 666f 7220  y supported for 
 00008210: 7265 6164 696e 6720 6669 6c65 737a 3241  reading filesz2A
 00008220: 7474 656d 7074 2074 6f20 7573 6520 5a49  ttempt to use ZI
 00008230: 5020 6172 6368 6976 6520 7468 6174 2077  P archive that w
```

## toollib/tcli/__init__.py

 * *Ordering differences only*

```diff
@@ -1,11 +1,11 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:15
-@abstract
-@description
-@history
-"""
-from pathlib import Path
-
-here = Path(__file__).absolute().parent
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:15
+@abstract
+@description
+@history
+"""
+from pathlib import Path
+
+here = Path(__file__).absolute().parent
```

## toollib/tcli/__main__.py

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:20
-@abstract
-@description
-@history
-"""
-from toollib.tcli.cmder import run
-
-
-def main():
-    run()
-
-
-if __name__ == '__main__':
-    main()
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:20
+@abstract
+@description
+@history
+"""
+from toollib.tcli.cmder import run
+
+
+def main():
+    run()
+
+
+if __name__ == '__main__':
+    main()
```

## toollib/tcli/base.py

 * *Ordering differences only*

```diff
@@ -1,91 +1,91 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:20
-@abstract
-@description
-@history
-"""
-import sys
-from argparse import ArgumentParser, Namespace
-
-import typing as t
-
-from toollib.tcli import helper
-from toollib.tcli.option import Options
-
-
-class BaseCmd:
-
-    argv: list
-    options: Options
-    parse_args: Namespace
-    usage: str
-    curr_usage: str
-
-    def add_options(self) -> Options:
-        raise NotImplementedError('subclasses of BaseCmd must provide a add_options() method')
-
-    def load_options(self):
-        options = self.add_options()
-        if not isinstance(options, Options):
-            raise TypeError('"add_options()" return type only supported: Options')
-        self.options = options
-
-    @property
-    def load_callcmd(self) -> t.Callable:
-        self.load_options()
-        # check
-        curr_cmd = self.argv[0]
-        self.curr_usage = getattr(helper, curr_cmd, helper.usage)
-        subcmds = self.options.subcmds
-        posargs = ['command']
-        curr_option = self.argv[1] if self.argv[1:] else None
-        if len(subcmds) > 1:
-            self._check_option(curr_option, mode=1)
-            posargs.append('option')
-        else:
-            if curr_option:
-                self._check_option(curr_option, mode=2)
-            curr_option = curr_cmd
-        curr_optional = subcmds.get(curr_option.replace('-', '_'))
-        if not curr_optional:
-            self._check_option(curr_option, mode=3)
-        # add args
-        curr_subcmd, curr_args = curr_optional
-        parser = ArgumentParser(
-            prog=f'[{helper.prog}]',
-            usage=self.curr_usage.replace('usage:', ''),
-            description=helper.description,
-        )
-        _ = [parser.add_argument(pos) for pos in posargs]
-        if curr_args:
-            for arg in curr_args:
-                name_or_flags, kwargs = arg.parse_arg
-                parser.add_argument(*name_or_flags, **kwargs)
-        self.parse_args = parser.parse_args(self.argv)
-        return curr_subcmd
-
-    def _check_option(self, option, mode):
-        if mode == 1:
-            if not option:
-                sys.stderr.write('ERROR: Option is required\n')
-                sys.stderr.write(self.curr_usage)
-                sys.exit(1)
-        else:
-            if option in ['-h', '--help']:
-                sys.stdout.write(self.curr_usage)
-                sys.exit()
-            if mode == 3:
-                sys.stderr.write('ERROR: Unknown option "%s"\n' % option)
-                sys.stderr.write(self.curr_usage)
-                sys.exit(1)
-
-    def execute(self):
-        self.load_callcmd()
-        sys.exit()
-
-    def run_cmd(self, argv, usage: str):
-        self.argv = argv
-        self.usage = usage
-        self.execute()
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:20
+@abstract
+@description
+@history
+"""
+import sys
+from argparse import ArgumentParser, Namespace
+
+import typing as t
+
+from toollib.tcli import helper
+from toollib.tcli.option import Options
+
+
+class BaseCmd:
+
+    argv: list
+    options: Options
+    parse_args: Namespace
+    usage: str
+    curr_usage: str
+
+    def add_options(self) -> Options:
+        raise NotImplementedError('subclasses of BaseCmd must provide a add_options() method')
+
+    def load_options(self):
+        options = self.add_options()
+        if not isinstance(options, Options):
+            raise TypeError('"add_options()" return type only supported: Options')
+        self.options = options
+
+    @property
+    def load_callcmd(self) -> t.Callable:
+        self.load_options()
+        # check
+        curr_cmd = self.argv[0]
+        self.curr_usage = getattr(helper, curr_cmd, helper.usage)
+        subcmds = self.options.subcmds
+        posargs = ['command']
+        curr_option = self.argv[1] if self.argv[1:] else None
+        if len(subcmds) > 1:
+            self._check_option(curr_option, mode=1)
+            posargs.append('option')
+        else:
+            if curr_option:
+                self._check_option(curr_option, mode=2)
+            curr_option = curr_cmd
+        curr_optional = subcmds.get(curr_option.replace('-', '_'))
+        if not curr_optional:
+            self._check_option(curr_option, mode=3)
+        # add args
+        curr_subcmd, curr_args = curr_optional
+        parser = ArgumentParser(
+            prog=f'[{helper.prog}]',
+            usage=self.curr_usage.replace('usage:', ''),
+            description=helper.description,
+        )
+        _ = [parser.add_argument(pos) for pos in posargs]
+        if curr_args:
+            for arg in curr_args:
+                name_or_flags, kwargs = arg.parse_arg
+                parser.add_argument(*name_or_flags, **kwargs)
+        self.parse_args = parser.parse_args(self.argv)
+        return curr_subcmd
+
+    def _check_option(self, option, mode):
+        if mode == 1:
+            if not option:
+                sys.stderr.write('ERROR: Option is required\n')
+                sys.stderr.write(self.curr_usage)
+                sys.exit(1)
+        else:
+            if option in ['-h', '--help']:
+                sys.stdout.write(self.curr_usage)
+                sys.exit()
+            if mode == 3:
+                sys.stderr.write('ERROR: Unknown option "%s"\n' % option)
+                sys.stderr.write(self.curr_usage)
+                sys.exit(1)
+
+    def execute(self):
+        self.load_callcmd()
+        sys.exit()
+
+    def run_cmd(self, argv, usage: str):
+        self.argv = argv
+        self.usage = usage
+        self.execute()
```

## toollib/tcli/cmder.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:20
-@abstract
-@description
-@history
-"""
-import importlib
-import sys
-
-from toollib import here
-from toollib.tcli import helper
-
-
-class Cmd:
-
-    def __init__(self, argv=None):
-        self.argv = argv or sys.argv[1:]
-        self.commands = self.find_commands()
-        self.usage = helper.usage
-        if not self.argv:
-            sys.stdout.write(self.usage)
-            sys.exit()
-        curr_command = self.argv[0]
-        self._check_command(curr_command)
-        self.argv[0] = curr_command.replace('-', '_')
-
-    def _check_command(self, command):
-        if command not in self.commands:
-            if command in ['-h', '--help']:
-                sys.stdout.write(self.usage)
-                sys.exit()
-            sys.stderr.write('ERROR: Unknown command "%s"\n' % command)
-            sys.stderr.write(self.usage)
-            sys.exit(1)
-
-    @staticmethod
-    def find_commands():
-        commands_dir = here.joinpath('tcli/commands')
-        commands = [cmd.stem[1:].replace('_', '-') for cmd in commands_dir.rglob('_*.py')
-                    if cmd.stem != '__init__']
-        return commands
-
-    def load_command_class(self):
-        cmdmod = importlib.import_module('toollib.tcli.commands._%s' % self.argv[0])
-        return cmdmod.Cmd()
-
-    def execute(self):
-        cmdcls = self.load_command_class()
-        cmdcls.run_cmd(self.argv, self.usage)
-
-
-def run(argv=None):
-    cmd = Cmd(argv)
-    cmd.execute()
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:20
+@abstract
+@description
+@history
+"""
+import importlib
+import sys
+
+from toollib import here
+from toollib.tcli import helper
+
+
+class Cmd:
+
+    def __init__(self, argv=None):
+        self.argv = argv or sys.argv[1:]
+        self.commands = self.find_commands()
+        self.usage = helper.usage
+        if not self.argv:
+            sys.stdout.write(self.usage)
+            sys.exit()
+        curr_command = self.argv[0]
+        self._check_command(curr_command)
+        self.argv[0] = curr_command.replace('-', '_')
+
+    def _check_command(self, command):
+        if command not in self.commands:
+            if command in ['-h', '--help']:
+                sys.stdout.write(self.usage)
+                sys.exit()
+            sys.stderr.write('ERROR: Unknown command "%s"\n' % command)
+            sys.stderr.write(self.usage)
+            sys.exit(1)
+
+    @staticmethod
+    def find_commands():
+        commands_dir = here.joinpath('tcli/commands')
+        commands = [cmd.stem[1:].replace('_', '-') for cmd in commands_dir.rglob('_*.py')
+                    if cmd.stem != '__init__']
+        return commands
+
+    def load_command_class(self):
+        cmdmod = importlib.import_module('toollib.tcli.commands._%s' % self.argv[0])
+        return cmdmod.Cmd()
+
+    def execute(self):
+        cmdcls = self.load_command_class()
+        cmdcls.run_cmd(self.argv, self.usage)
+
+
+def run(argv=None):
+    cmd = Cmd(argv)
+    cmd.execute()
```

## toollib/tcli/helper.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/6/26 15:51
-@abstract
-@description
-@history
-"""
-prog = 'pytcli'
-description = 'A command line for python toollib package'
-usage = """Usage:
-  pytcli <command> [options]
-Commands:
-  -h/--help         帮助
-  set-pip           设置pip源
-  set-conda         设置conda源
-  set-mirrors       设置镜像源
-  set-sshkey        设置ssh免密
-  docker            docker操作
-  py2pyd            py转pyd
-"""
-
-set_pip = """usage:
-  pytcli set-pip
-options:
-  -h/--help     帮助
-"""
-
-set_conda = """usage:
-  pytcli set-conda
-options:
-  -h/--help     帮助
-"""
-
-set_mirrors = """usage:
-  pytcli set-mirrors
-options:
-  -h/--help     帮助
-"""
-
-set_sshkey = """usage:
-  pytcli set-sshkey
-options:
-  -h/--help     帮助
-  -i/--infos    主机信息（"ip1,user1,pass1,port1 ip2,user2,pass2,port2 ..."|也可指定文件:一行一个） 
-"""
-
-docker = """usage:
-  pytcli docker [options]
-options:
-  -h/--help     帮助
-  install       安装
-  set-mirrors   设置镜像源
-  compose       容器组合
-    -n/--name       镜像名称（多个用逗号隔开）
-    -o/--outdir     输出目录
-    -f/--filename   文件名称
-  compose-list  容器组合列表
-"""
-
-py2pyd = """usage:
-  pytcli py2pyd [options]
-options:
-  -h/--help         帮助
-  -s/--src          源（py目录或文件）
-  -p/--postfix      后缀（默认为Pyd）
-  -e/--exclude      排除编译（适用正则，使用管道等注意加引号）
-  -i/--ignore       忽略复制（多个逗号隔开）
-  -c/--clean        清理临时
-"""
+"""
+@author axiner
+@version v1.0.0
+@created 2022/6/26 15:51
+@abstract
+@description
+@history
+"""
+prog = 'pytcli'
+description = 'A command line for python toollib package'
+usage = """Usage:
+  pytcli <command> [options]
+Commands:
+  -h/--help         帮助
+  set-pip           设置pip源
+  set-conda         设置conda源
+  set-mirrors       设置镜像源
+  set-sshkey        设置ssh免密
+  docker            docker操作
+  py2pyd            py转pyd
+"""
+
+set_pip = """usage:
+  pytcli set-pip
+options:
+  -h/--help     帮助
+"""
+
+set_conda = """usage:
+  pytcli set-conda
+options:
+  -h/--help     帮助
+"""
+
+set_mirrors = """usage:
+  pytcli set-mirrors
+options:
+  -h/--help     帮助
+"""
+
+set_sshkey = """usage:
+  pytcli set-sshkey
+options:
+  -h/--help     帮助
+  -i/--infos    主机信息（"ip1,user1,pass1,port1 ip2,user2,pass2,port2 ..."|也可指定文件:一行一个） 
+"""
+
+docker = """usage:
+  pytcli docker [options]
+options:
+  -h/--help     帮助
+  install       安装
+  set-mirrors   设置镜像源
+  compose       容器组合
+    -n/--name       镜像名称（多个用逗号隔开）
+    -o/--outdir     输出目录
+    -f/--filename   文件名称
+  compose-list  容器组合列表
+"""
+
+py2pyd = """usage:
+  pytcli py2pyd [options]
+options:
+  -h/--help         帮助
+  -s/--src          源（py目录或文件）
+  -p/--postfix      后缀（默认为Pyd）
+  -e/--exclude      排除编译（适用正则，使用管道等注意加引号）
+  -i/--ignore       忽略复制（多个逗号隔开）
+  -c/--clean        清理临时
+"""
```

## toollib/tcli/option.py

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:20
-@abstract
-@description
-@history
-"""
-import typing as t
-from toollib.validator import Attr
-
-
-class Arg:
-
-    def __init__(self,
-                 *name_or_flags: str,
-                 action: str = None,
-                 nargs: t.Union[int, str] = None,
-                 const: t.Any = None,
-                 default: t.Any = None,
-                 type: type = None,
-                 choices: t.Iterable = None,
-                 required: bool = False,
-                 help: str = None,
-                 metavar: t.Union[str, t.Tuple[str]] = None,
-                 dest: str = None,
-                 version: str = None,
-                 **kwargs: t.Any):
-        self.name_or_flags = name_or_flags
-        self.action = action
-        self.nargs = nargs
-        self.const = const
-        self.default = default
-        self.type = type
-        self.choices = choices
-        self.required = required
-        self.help = help
-        self.metavar = metavar
-        self.dest = dest
-        self.version = version
-        for k, v in kwargs.items():
-            self.k = v
-
-    @property
-    def parse_arg(self):
-        arg = {k: v for k, v in self.__dict__.items() if v}
-        return arg.pop('name_or_flags'), arg
-
-
-def check_optional(optional):
-    for subcmd, args in optional.items():
-        if callable(subcmd) is False:
-            raise TypeError('"subcmd" only supported: Callable')
-        errmsg = '"optional" only supported: Union[List[Arg], None]'
-        if not isinstance(args, (list, type(None))):
-            raise TypeError(errmsg)
-        if args:
-            for arg in args:
-                if not isinstance(arg, Arg):
-                    raise TypeError(errmsg)
-
-
-class Options:
-
-    name: str = Attr('name', str, required=True)
-    desc: str = Attr('desc', str, required=True)
-    optional: t.Dict[t.Callable, t.Union[t.List[Arg], None]] = Attr(
-        'optional', dict, required=True, callback=check_optional)
-
-    def __init__(self, name, desc, optional):
-        self.name = name
-        self.desc = desc
-        self.optional = optional
-
-    @property
-    def subcmds(self) -> dict:
-        return {item[0].__name__: item for item in self.optional.items()}
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:20
+@abstract
+@description
+@history
+"""
+import typing as t
+from toollib.validator import Attr
+
+
+class Arg:
+
+    def __init__(self,
+                 *name_or_flags: str,
+                 action: str = None,
+                 nargs: t.Union[int, str] = None,
+                 const: t.Any = None,
+                 default: t.Any = None,
+                 type: type = None,
+                 choices: t.Iterable = None,
+                 required: bool = False,
+                 help: str = None,
+                 metavar: t.Union[str, t.Tuple[str]] = None,
+                 dest: str = None,
+                 version: str = None,
+                 **kwargs: t.Any):
+        self.name_or_flags = name_or_flags
+        self.action = action
+        self.nargs = nargs
+        self.const = const
+        self.default = default
+        self.type = type
+        self.choices = choices
+        self.required = required
+        self.help = help
+        self.metavar = metavar
+        self.dest = dest
+        self.version = version
+        for k, v in kwargs.items():
+            self.k = v
+
+    @property
+    def parse_arg(self):
+        arg = {k: v for k, v in self.__dict__.items() if v}
+        return arg.pop('name_or_flags'), arg
+
+
+def check_optional(optional):
+    for subcmd, args in optional.items():
+        if callable(subcmd) is False:
+            raise TypeError('"subcmd" only supported: Callable')
+        errmsg = '"optional" only supported: Union[List[Arg], None]'
+        if not isinstance(args, (list, type(None))):
+            raise TypeError(errmsg)
+        if args:
+            for arg in args:
+                if not isinstance(arg, Arg):
+                    raise TypeError(errmsg)
+
+
+class Options:
+
+    name: str = Attr('name', str, required=True)
+    desc: str = Attr('desc', str, required=True)
+    optional: t.Dict[t.Callable, t.Union[t.List[Arg], None]] = Attr(
+        'optional', dict, required=True, callback=check_optional)
+
+    def __init__(self, name, desc, optional):
+        self.name = name
+        self.desc = desc
+        self.optional = optional
+
+    @property
+    def subcmds(self) -> dict:
+        return {item[0].__name__: item for item in self.optional.items()}
```

## toollib/tcli/commands/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:20
-@abstract
-@description
-@history
-"""
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:20
+@abstract
+@description
+@history
+"""
```

## toollib/tcli/commands/_docker.py

 * *Ordering differences only*

```diff
@@ -1,123 +1,123 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/5/11 21:44
-@abstract
-@description
-@history
-"""
-import json
-import os
-import re
-import subprocess
-import sys
-
-from toollib.common import constor
-from toollib.decorator import sys_required
-from toollib.tcli import here
-from toollib.tcli.base import BaseCmd
-from toollib.tcli.option import Options, Arg
-
-
-class Cmd(BaseCmd):
-
-    def __init__(self):
-        super().__init__()
-        self.dkcmps_path = here.joinpath('commands', 'plugins', 'docker-compose.yml').as_posix()
-
-    def add_options(self):
-        options = Options(
-            name='docker操作',
-            desc='docker操作',
-            optional={
-                self.install: None,
-                self.set_mirrors: None,
-                self.compose: [
-                    Arg('-n', '--names', required=True, type=str, help='镜像名称（多个用逗号隔开）'),
-                    Arg('-o', '--outdir', type=str, help='输出目录'),
-                    Arg('-f', '--filename', type=str, help='文件名称'),
-                ],
-                self.compose_list: None,
-            }
-        )
-        return options
-
-    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
-    def install(self):
-        try:
-            subprocess.run(['docker', '-v'], stderr=subprocess.DEVNULL, encoding='utf8')
-            print('WARNING: Docker already exist')
-        except Exception:
-            cmd = 'curl -sSL https://get.daocloud.io/docker | sh'
-            subprocess.run(cmd, shell=True)
-
-    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
-    def set_mirrors(self):
-        print('设置镜像源.....')
-        subprocess.run(['systemctl', 'stop', 'docker'])
-        docker_conf_dir = '/etc/docker'
-        if not os.path.isdir(docker_conf_dir):
-            os.mkdir(docker_conf_dir)
-        docker_conf_file = os.path.join(docker_conf_dir, 'daemon.json')
-        with open(docker_conf_file, 'w') as fp:
-            fp.write(json.dumps(constor.docker_mirrors, indent=2))
-            print(f'to Path >>> {docker_conf_file}')
-            print('设置完成')
-        subprocess.run(['systemctl', 'start', 'docker'])
-
-    def compose(self):
-        names = self.parse_args.names
-        if not names or names == "''":
-            sys.stderr.write('ERROR: -n/--names: 不能为空\n')
-            sys.exit(1)
-        outdir = self.parse_args.outdir
-        if outdir:
-            if not os.path.isdir(outdir):
-                sys.stderr.write(f'ERROR: {outdir}: 目录不存在\n')
-                sys.exit(1)
-        else:
-            outdir = os.getcwd()
-        filename = self.parse_args.filename or 'docker-compose.yml'
-        dkcmps_path = os.path.join(outdir, filename)
-        wc = 0
-        for name, dkcmps_conf in self._search_dkcmps_conf(names):
-            if not dkcmps_conf:
-                print(f'{name}: 抱歉暂未收录')
-            else:
-                if os.path.isfile(dkcmps_path) and os.path.getsize(dkcmps_path):
-                    with open(dkcmps_path, 'r') as fp:
-                        if re.search(rf"\s\s{name}:\s*\r?\n", fp.read()):
-                            print(f'{name}: `{dkcmps_path}`已经存在')
-                            continue
-                    mode = 'a'
-                    dkcmps_conf = '\n\n' + dkcmps_conf
-                else:
-                    mode = 'w'
-                    dkcmps_conf = 'version: "3"\nservices:\n\n' + dkcmps_conf
-                with open(dkcmps_path, mode) as fp:
-                    fp.write(dkcmps_conf)
-                    print(f'{name}: `{dkcmps_path}`写入成功')
-                    wc += 1
-        if wc:
-            print('后续可通过`docker-compose`命令管理容器（也可自行修改配置）')
-
-    def _search_dkcmps_conf(self, names: str):
-        with open(self.dkcmps_path, 'r') as fp:
-            dkcmps_text = fp.read()
-            if names == 'all':
-                namelist = re.findall(r"^\s{2}(\w+):\s*\r?\n", dkcmps_text, re.MULTILINE)
-            else:
-                namelist = names.split(',')
-            for n in namelist:
-                regex = r'(\s{2}' + n + r':\s*.*?)(?=\r?\n\s*\r?\n|$)'
-                matches = re.search(regex, dkcmps_text, re.DOTALL)
-                if matches:
-                    yield n, matches.group(0).rstrip()
-                else:
-                    yield n, None
-
-    def compose_list(self):
-        with open(self.dkcmps_path, 'r') as fp:
-            namelist = re.findall(r"^(\s{2}\w+):\s*\r?\n", fp.read(), re.MULTILINE) or ['  正在努力收录中...']
-            resp_text = '已收录的容器：\n' + '\n'.join(namelist)
-            print(resp_text)
+"""
+@author axiner
+@version v1.0.0
+@created 2022/5/11 21:44
+@abstract
+@description
+@history
+"""
+import json
+import os
+import re
+import subprocess
+import sys
+
+from toollib.common import constor
+from toollib.decorator import sys_required
+from toollib.tcli import here
+from toollib.tcli.base import BaseCmd
+from toollib.tcli.option import Options, Arg
+
+
+class Cmd(BaseCmd):
+
+    def __init__(self):
+        super().__init__()
+        self.dkcmps_path = here.joinpath('commands', 'plugins', 'docker-compose.yml').as_posix()
+
+    def add_options(self):
+        options = Options(
+            name='docker操作',
+            desc='docker操作',
+            optional={
+                self.install: None,
+                self.set_mirrors: None,
+                self.compose: [
+                    Arg('-n', '--names', required=True, type=str, help='镜像名称（多个用逗号隔开）'),
+                    Arg('-o', '--outdir', type=str, help='输出目录'),
+                    Arg('-f', '--filename', type=str, help='文件名称'),
+                ],
+                self.compose_list: None,
+            }
+        )
+        return options
+
+    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
+    def install(self):
+        try:
+            subprocess.run(['docker', '-v'], stderr=subprocess.DEVNULL, encoding='utf8')
+            print('WARNING: Docker already exist')
+        except Exception:
+            cmd = 'curl -sSL https://get.daocloud.io/docker | sh'
+            subprocess.run(cmd, shell=True)
+
+    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
+    def set_mirrors(self):
+        print('设置镜像源.....')
+        subprocess.run(['systemctl', 'stop', 'docker'])
+        docker_conf_dir = '/etc/docker'
+        if not os.path.isdir(docker_conf_dir):
+            os.mkdir(docker_conf_dir)
+        docker_conf_file = os.path.join(docker_conf_dir, 'daemon.json')
+        with open(docker_conf_file, 'w') as fp:
+            fp.write(json.dumps(constor.docker_mirrors, indent=2))
+            print(f'to Path >>> {docker_conf_file}')
+            print('设置完成')
+        subprocess.run(['systemctl', 'start', 'docker'])
+
+    def compose(self):
+        names = self.parse_args.names
+        if not names or names == "''":
+            sys.stderr.write('ERROR: -n/--names: 不能为空\n')
+            sys.exit(1)
+        outdir = self.parse_args.outdir
+        if outdir:
+            if not os.path.isdir(outdir):
+                sys.stderr.write(f'ERROR: {outdir}: 目录不存在\n')
+                sys.exit(1)
+        else:
+            outdir = os.getcwd()
+        filename = self.parse_args.filename or 'docker-compose.yml'
+        dkcmps_path = os.path.join(outdir, filename)
+        wc = 0
+        for name, dkcmps_conf in self._search_dkcmps_conf(names):
+            if not dkcmps_conf:
+                print(f'{name}: 抱歉暂未收录')
+            else:
+                if os.path.isfile(dkcmps_path) and os.path.getsize(dkcmps_path):
+                    with open(dkcmps_path, 'r') as fp:
+                        if re.search(rf"\s\s{name}:\s*\r?\n", fp.read()):
+                            print(f'{name}: `{dkcmps_path}`已经存在')
+                            continue
+                    mode = 'a'
+                    dkcmps_conf = '\n\n' + dkcmps_conf
+                else:
+                    mode = 'w'
+                    dkcmps_conf = 'version: "3"\nservices:\n\n' + dkcmps_conf
+                with open(dkcmps_path, mode) as fp:
+                    fp.write(dkcmps_conf)
+                    print(f'{name}: `{dkcmps_path}`写入成功')
+                    wc += 1
+        if wc:
+            print('后续可通过`docker-compose`命令管理容器（也可自行修改配置）')
+
+    def _search_dkcmps_conf(self, names: str):
+        with open(self.dkcmps_path, 'r') as fp:
+            dkcmps_text = fp.read()
+            if names == 'all':
+                namelist = re.findall(r"^\s{2}(\w+):\s*\r?\n", dkcmps_text, re.MULTILINE)
+            else:
+                namelist = names.split(',')
+            for n in namelist:
+                regex = r'(\s{2}' + n + r':\s*.*?)(?=\r?\n\s*\r?\n|$)'
+                matches = re.search(regex, dkcmps_text, re.DOTALL)
+                if matches:
+                    yield n, matches.group(0).rstrip()
+                else:
+                    yield n, None
+
+    def compose_list(self):
+        with open(self.dkcmps_path, 'r') as fp:
+            namelist = re.findall(r"^(\s{2}\w+):\s*\r?\n", fp.read(), re.MULTILINE) or ['  正在努力收录中...']
+            resp_text = '已收录的容器：\n' + '\n'.join(namelist)
+            print(resp_text)
```

## toollib/tcli/commands/_py2pyd.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2023/4/7 16:12
-@abstract
-@description
-@history
-"""
-import sys
-
-from toollib.py2pyder import Py2Pyder
-from toollib.tcli.base import BaseCmd
-from toollib.tcli.option import Options, Arg
-
-
-class Cmd(BaseCmd):
-
-    def __init__(self):
-        super().__init__()
-
-    def add_options(self):
-        options = Options(
-            name='py2pyd',
-            desc='py转pyd',
-            optional={self.py2pyd: [
-                Arg('-s', '--src', required=True, type=str, help='源（py目录或文件）'),
-                Arg('-p', '--postfix', type=str, help='后缀（默认为Pyd）'),
-                Arg('-e', '--exclude', type=str, help='排除编译（适用正则，使用管道等注意加引号）'),
-                Arg('-i', '--ignore', type=str, default='.git,.idea,__pycache__', help='忽略复制（多个逗号隔开）'),
-                Arg('-c', '--clean', action='store_true', help='清理临时'),
-            ]}
-        )
-        return options
-
-    def py2pyd(self):
-        src = self.parse_args.src
-        if not src or src == "''":
-            sys.stderr.write('ERROR: -s/--src: 不能为空\n')
-            sys.exit(1)
-        postfix = self.parse_args.postfix
-        exclude = self.parse_args.exclude
-        ignore = self.parse_args.ignore
-        clean = self.parse_args.clean
-        py2pyder = Py2Pyder(src, postfix, exclude, ignore, clean)
-        py2pyder.run()
+"""
+@author axiner
+@version v1.0.0
+@created 2023/4/7 16:12
+@abstract
+@description
+@history
+"""
+import sys
+
+from toollib.py2pyder import Py2Pyder
+from toollib.tcli.base import BaseCmd
+from toollib.tcli.option import Options, Arg
+
+
+class Cmd(BaseCmd):
+
+    def __init__(self):
+        super().__init__()
+
+    def add_options(self):
+        options = Options(
+            name='py2pyd',
+            desc='py转pyd',
+            optional={self.py2pyd: [
+                Arg('-s', '--src', required=True, type=str, help='源（py目录或文件）'),
+                Arg('-p', '--postfix', type=str, help='后缀（默认为Pyd）'),
+                Arg('-e', '--exclude', type=str, help='排除编译（适用正则，使用管道等注意加引号）'),
+                Arg('-i', '--ignore', type=str, default='.git,.idea,__pycache__', help='忽略复制（多个逗号隔开）'),
+                Arg('-c', '--clean', action='store_true', help='清理临时'),
+            ]}
+        )
+        return options
+
+    def py2pyd(self):
+        src = self.parse_args.src
+        if not src or src == "''":
+            sys.stderr.write('ERROR: -s/--src: 不能为空\n')
+            sys.exit(1)
+        postfix = self.parse_args.postfix
+        exclude = self.parse_args.exclude
+        ignore = self.parse_args.ignore
+        clean = self.parse_args.clean
+        py2pyder = Py2Pyder(src, postfix, exclude, ignore, clean)
+        py2pyder.run()
```

## toollib/tcli/commands/_set_conda.py

 * *Ordering differences only*

```diff
@@ -1,37 +1,37 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/4/30 13:20
-@abstract
-@description
-@history
-"""
-import os
-
-from toollib import utils
-from toollib.tcli.base import BaseCmd
-from toollib.common import constor
-from toollib.tcli.option import Options
-
-
-class Cmd(BaseCmd):
-
-    def __init__(self):
-        super().__init__()
-
-    def add_options(self):
-        options = Options(
-            name='set-conda',
-            desc='设置conda源',
-            optional={self.set_conda: None}
-        )
-        return options
-
-    def set_conda(self):
-        print('设置镜像源.....')
-        _home = utils.home()
-        conf_file = os.path.join(_home, '.condarc')
-        with open(conf_file, mode='wb') as fp:
-            fp.write(constor.conda_conf)
-            print(f'to Path >>> {conf_file}')
-            print('设置完成')
+"""
+@author axiner
+@version v1.0.0
+@created 2022/4/30 13:20
+@abstract
+@description
+@history
+"""
+import os
+
+from toollib import utils
+from toollib.tcli.base import BaseCmd
+from toollib.common import constor
+from toollib.tcli.option import Options
+
+
+class Cmd(BaseCmd):
+
+    def __init__(self):
+        super().__init__()
+
+    def add_options(self):
+        options = Options(
+            name='set-conda',
+            desc='设置conda源',
+            optional={self.set_conda: None}
+        )
+        return options
+
+    def set_conda(self):
+        print('设置镜像源.....')
+        _home = utils.home()
+        conf_file = os.path.join(_home, '.condarc')
+        with open(conf_file, mode='wb') as fp:
+            fp.write(constor.conda_conf)
+            print(f'to Path >>> {conf_file}')
+            print('设置完成')
```

## toollib/tcli/commands/_set_mirrors.py

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/5/11 21:44
-@abstract
-@description
-@history
-"""
-import os
-import stat
-import subprocess
-
-from toollib.decorator import sys_required
-from toollib.tcli import here
-from toollib.tcli.base import BaseCmd
-from toollib.tcli.option import Options
-
-
-class Cmd(BaseCmd):
-
-    def __init__(self):
-        super().__init__()
-
-    def add_options(self):
-        options = Options(
-            name='set-mirrors',
-            desc='设置镜像源',
-            optional={self.set_mirrors: None}
-        )
-        return options
-
-    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
-    def set_mirrors(self):
-        shpath = here.joinpath('commands/plugins/set_mirrors.sh').as_posix()
-        if not os.access(shpath, os.X_OK):
-            os.chmod(shpath, os.stat(shpath).st_mode | stat.S_IEXEC)
-        cmd = ['/bin/bash', shpath]
-        subprocess.run(cmd)
+"""
+@author axiner
+@version v1.0.0
+@created 2022/5/11 21:44
+@abstract
+@description
+@history
+"""
+import os
+import stat
+import subprocess
+
+from toollib.decorator import sys_required
+from toollib.tcli import here
+from toollib.tcli.base import BaseCmd
+from toollib.tcli.option import Options
+
+
+class Cmd(BaseCmd):
+
+    def __init__(self):
+        super().__init__()
+
+    def add_options(self):
+        options = Options(
+            name='set-mirrors',
+            desc='设置镜像源',
+            optional={self.set_mirrors: None}
+        )
+        return options
+
+    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
+    def set_mirrors(self):
+        shpath = here.joinpath('commands/plugins/set_mirrors.sh').as_posix()
+        if not os.access(shpath, os.X_OK):
+            os.chmod(shpath, os.stat(shpath).st_mode | stat.S_IEXEC)
+        cmd = ['/bin/bash', shpath]
+        subprocess.run(cmd)
```

## toollib/tcli/commands/_set_pip.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/2/27 11:31
-@abstract
-@description
-@history
-"""
-from pathlib import Path
-from platform import platform
-
-from toollib import utils
-from toollib.tcli.base import BaseCmd
-from toollib.common import constor
-from toollib.tcli.option import Options
-
-
-class Cmd(BaseCmd):
-
-    def __init__(self):
-        super().__init__()
-
-    def add_options(self):
-        options = Options(
-            name='set-pip',
-            desc='设置pip源',
-            optional={self.set_pip: None}
-        )
-        return options
-
-    def set_pip(self):
-        print('设置镜像源.....')
-        _home = utils.home()
-        if platform().find('Windows') != -1:
-            conf_file = Path(_home, 'pip', 'pip.ini')
-        else:
-            conf_file = Path(_home, '.pip', 'pip.conf')
-        conf_file.parent.mkdir(parents=True, exist_ok=True)
-        with open(conf_file, mode='wb') as fp:
-            fp.write(constor.pip_conf)
-            print(f'to Path >>> {conf_file.as_posix()}')
-            print('设置完成')
+"""
+@author axiner
+@version v1.0.0
+@created 2022/2/27 11:31
+@abstract
+@description
+@history
+"""
+from pathlib import Path
+from platform import platform
+
+from toollib import utils
+from toollib.tcli.base import BaseCmd
+from toollib.common import constor
+from toollib.tcli.option import Options
+
+
+class Cmd(BaseCmd):
+
+    def __init__(self):
+        super().__init__()
+
+    def add_options(self):
+        options = Options(
+            name='set-pip',
+            desc='设置pip源',
+            optional={self.set_pip: None}
+        )
+        return options
+
+    def set_pip(self):
+        print('设置镜像源.....')
+        _home = utils.home()
+        if platform().find('Windows') != -1:
+            conf_file = Path(_home, 'pip', 'pip.ini')
+        else:
+            conf_file = Path(_home, '.pip', 'pip.conf')
+        conf_file.parent.mkdir(parents=True, exist_ok=True)
+        with open(conf_file, mode='wb') as fp:
+            fp.write(constor.pip_conf)
+            print(f'to Path >>> {conf_file.as_posix()}')
+            print('设置完成')
```

## toollib/tcli/commands/_set_sshkey.py

 * *Ordering differences only*

```diff
@@ -1,46 +1,46 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/5/4 9:17
-@abstract
-@description
-@history
-"""
-import os
-import stat
-import subprocess
-import sys
-
-from toollib.decorator import sys_required
-from toollib.tcli import here
-from toollib.tcli.base import BaseCmd
-from toollib.tcli.option import Options, Arg
-
-
-class Cmd(BaseCmd):
-
-    def __init__(self):
-        super().__init__()
-
-    def add_options(self):
-        options = Options(
-            name='set-sshkey',
-            desc='设置ssh免密',
-            optional={
-                self.set_sshkey: [
-                    Arg('-i', '--infos', required=True, type=str, help='"ip1,user1,pass1,port1 ip2,user2,pass2,port2 ..."|也可指定文件:一行一个'),
-                ]}
-        )
-        return options
-
-    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
-    def set_sshkey(self):
-        infos = self.parse_args.infos
-        if not infos or infos == "''":
-            sys.stderr.write('ERROR: -i/--infos: 不能为空\n')
-            sys.exit(1)
-        shpath = here.joinpath('commands/plugins/set_sshkey.sh').as_posix()
-        if not os.access(shpath, os.X_OK):
-            os.chmod(shpath, os.stat(shpath).st_mode | stat.S_IEXEC)
-        cmd = ['/bin/bash', shpath, infos]
-        subprocess.run(cmd)
+"""
+@author axiner
+@version v1.0.0
+@created 2022/5/4 9:17
+@abstract
+@description
+@history
+"""
+import os
+import stat
+import subprocess
+import sys
+
+from toollib.decorator import sys_required
+from toollib.tcli import here
+from toollib.tcli.base import BaseCmd
+from toollib.tcli.option import Options, Arg
+
+
+class Cmd(BaseCmd):
+
+    def __init__(self):
+        super().__init__()
+
+    def add_options(self):
+        options = Options(
+            name='set-sshkey',
+            desc='设置ssh免密',
+            optional={
+                self.set_sshkey: [
+                    Arg('-i', '--infos', required=True, type=str, help='"ip1,user1,pass1,port1 ip2,user2,pass2,port2 ..."|也可指定文件:一行一个'),
+                ]}
+        )
+        return options
+
+    @sys_required(r'Ubuntu|CentOS|RedHat|Rocky')
+    def set_sshkey(self):
+        infos = self.parse_args.infos
+        if not infos or infos == "''":
+            sys.stderr.write('ERROR: -i/--infos: 不能为空\n')
+            sys.exit(1)
+        shpath = here.joinpath('commands/plugins/set_sshkey.sh').as_posix()
+        if not os.access(shpath, os.X_OK):
+            os.chmod(shpath, os.stat(shpath).st_mode | stat.S_IEXEC)
+        cmd = ['/bin/bash', shpath, infos]
+        subprocess.run(cmd)
```

## toollib/tcli/commands/plugins/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-"""
-@author axiner
-@version v1.0.0
-@created 2022/5/2 9:33
-@abstract
-@description
-@history
-"""
+"""
+@author axiner
+@version v1.0.0
+@created 2022/5/2 9:33
+@abstract
+@description
+@history
+"""
```

## toollib/tcli/commands/plugins/set_sshkey.sh

 * *Ordering differences only*

```diff
@@ -1,102 +1,102 @@
-#!/bin/bash
-:<<EOF
-@author axiner
-@version v1.0.0
-@created 2023/4/19 11:52
-@abstract 设置ssh免密
-@description
-@history
-EOF
-
-function set_pkg_manager() {
-  if [[ "$(uname)" == "Linux" ]]; then
-    if [[ -n "$(command -v apt-get)" ]]; then
-      pkg_manager="apt-get"
-    elif [[ -n "$(command -v yum)" ]]; then
-      pkg_manager="yum"
-    else
-      echo -e "apt-get|yum: \033[31m包管理器无法识别\033[0m"
-      exit 1
-    fi
-  else
-    echo -e "System only supported: \033[31mLinux\033[0m"
-    exit 1
-  fi
-}
-
-function install_pkgs() {
-  pkg_array=($1)
-  failed_pkgs=()
-  for pkg_string in "${pkg_array[@]}"
-  do
-    IFS=':' read -ra item <<< "$pkg_string"
-    pkg=${item[1]}
-    if [[ -z "$(command -v "${item[0]}")" ]]; then
-      if ! "$pkg_manager" install -y "$pkg"; then
-        echo "Failed to install $pkg"
-        failed_pkgs+=("$pkg")
-      fi
-    fi
-  done
-  if [ ${#failed_pkgs[@]} -gt 0 ]; then
-    echo "Trying to install failed packages: ${failed_pkgs[@]}"
-    "$pkg_manager" update
-    for pkg in "${failed_pkgs[@]}"; do
-      if ! "$pkg_manager" install -y "$pkg"; then
-        echo "Failed to install $pkg"
-        exit 1
-      fi
-    done
-  fi
-}
-
-function gen_key() {
-  if ! [ -f "$HOME/.ssh/id_rsa.pub" ]; then
-    ssh-keygen -t rsa -P '' -f $HOME/.ssh/id_rsa <<< y
-  fi
-}
-
-function distribute_key {
-  IFS=',' read -ra INFO <<< "$1"
-  if [ "${#INFO[@]}" -ne 4 ]; then
-    echo -e ""$1"：\033[31mFailed（请检查配置是否正确）\033[0m"
-  else
-    IP=${INFO[0]}
-    USER=${INFO[1]}
-    PASS=${INFO[2]}
-    PORT=${INFO[3]}
-    # set key
-    echo -e "\x1dclose\x0d" |timeout 2 telnet "$IP" "$PORT" > /dev/null 2>&1
-    if [ $? -ne 0 ]; then
-      echo -e "\x1dclose\x0d" |timeout 5 telnet "$IP" "$PORT" > /dev/null 2>&1
-    fi
-    if [ $? -eq 0 ]; then
-      sshpass -p "$PASS" ssh-copy-id -o StrictHostKeyChecking=no -p "$PORT" "$USER@$IP" &>/dev/null
-      if [ $? -eq 0 ]; then
-        echo -e "$USER@$IP：\033[32mSucceeded\033[0m"
-      else
-        echo -e "$USER@$IP：\033[31mFailed（请检查配置是否正确）\033[0m"
-      fi
-    else
-      echo -e "$USER@$IP：\033[31mFailed（请检查连接是否畅通）\033[0m"
-    fi
-  fi
-}
-
-
-pkgs="telnet:telnet sshpass:sshpass timeout:coreutils"
-set_pkg_manager
-install_pkgs "$pkgs"
-gen_key
-# Check is a file or a string
-if [[ -f $1 ]]; then
-  # file
-  while read line; do
-    distribute_key "$line"
-  done < "$1"
-else
-  # string
-  for line in $1; do
-    distribute_key "$line"
-  done
-fi
+#!/bin/bash
+:<<EOF
+@author axiner
+@version v1.0.0
+@created 2023/4/19 11:52
+@abstract 设置ssh免密
+@description
+@history
+EOF
+
+function set_pkg_manager() {
+  if [[ "$(uname)" == "Linux" ]]; then
+    if [[ -n "$(command -v apt-get)" ]]; then
+      pkg_manager="apt-get"
+    elif [[ -n "$(command -v yum)" ]]; then
+      pkg_manager="yum"
+    else
+      echo -e "apt-get|yum: \033[31m包管理器无法识别\033[0m"
+      exit 1
+    fi
+  else
+    echo -e "System only supported: \033[31mLinux\033[0m"
+    exit 1
+  fi
+}
+
+function install_pkgs() {
+  pkg_array=($1)
+  failed_pkgs=()
+  for pkg_string in "${pkg_array[@]}"
+  do
+    IFS=':' read -ra item <<< "$pkg_string"
+    pkg=${item[1]}
+    if [[ -z "$(command -v "${item[0]}")" ]]; then
+      if ! "$pkg_manager" install -y "$pkg"; then
+        echo "Failed to install $pkg"
+        failed_pkgs+=("$pkg")
+      fi
+    fi
+  done
+  if [ ${#failed_pkgs[@]} -gt 0 ]; then
+    echo "Trying to install failed packages: ${failed_pkgs[@]}"
+    "$pkg_manager" update
+    for pkg in "${failed_pkgs[@]}"; do
+      if ! "$pkg_manager" install -y "$pkg"; then
+        echo "Failed to install $pkg"
+        exit 1
+      fi
+    done
+  fi
+}
+
+function gen_key() {
+  if ! [ -f "$HOME/.ssh/id_rsa.pub" ]; then
+    ssh-keygen -t rsa -P '' -f $HOME/.ssh/id_rsa <<< y
+  fi
+}
+
+function distribute_key {
+  IFS=',' read -ra INFO <<< "$1"
+  if [ "${#INFO[@]}" -ne 4 ]; then
+    echo -e ""$1"：\033[31mFailed（请检查配置是否正确）\033[0m"
+  else
+    IP=${INFO[0]}
+    USER=${INFO[1]}
+    PASS=${INFO[2]}
+    PORT=${INFO[3]}
+    # set key
+    echo -e "\x1dclose\x0d" |timeout 2 telnet "$IP" "$PORT" > /dev/null 2>&1
+    if [ $? -ne 0 ]; then
+      echo -e "\x1dclose\x0d" |timeout 5 telnet "$IP" "$PORT" > /dev/null 2>&1
+    fi
+    if [ $? -eq 0 ]; then
+      sshpass -p "$PASS" ssh-copy-id -o StrictHostKeyChecking=no -p "$PORT" "$USER@$IP" &>/dev/null
+      if [ $? -eq 0 ]; then
+        echo -e "$USER@$IP：\033[32mSucceeded\033[0m"
+      else
+        echo -e "$USER@$IP：\033[31mFailed（请检查配置是否正确）\033[0m"
+      fi
+    else
+      echo -e "$USER@$IP：\033[31mFailed（请检查连接是否畅通）\033[0m"
+    fi
+  fi
+}
+
+
+pkgs="telnet:telnet sshpass:sshpass timeout:coreutils"
+set_pkg_manager
+install_pkgs "$pkgs"
+gen_key
+# Check is a file or a string
+if [[ -f $1 ]]; then
+  # file
+  while read line; do
+    distribute_key "$line"
+  done < "$1"
+else
+  # string
+  for line in $1; do
+    distribute_key "$line"
+  done
+fi
```

## Comparing `toollib-1.3.5.dist-info/LICENSE` & `toollib-1.3.6.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-Copyright (c) 2021-2022 axiner
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+Copyright (c) 2021-2022 axiner
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

## Comparing `toollib-1.3.5.dist-info/METADATA` & `toollib-1.3.6.dist-info/METADATA`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: toollib
-Version: 1.3.5
+Version: 1.3.6
 Summary: This is a tool library.
 Home-page: https://github.com/atpuxiner/toollib
 Author: axiner
 Author-email: atpuxiner@163.com
 License: MIT
 Platform: any
 Classifier: License :: OSI Approved :: MIT License
```

## Comparing `toollib-1.3.5.dist-info/RECORD` & `toollib-1.3.6.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,82 +1,82 @@
-toollib/__debug__.py,sha256=eHDL-LlSz7DJzhfphqhmu_MgJuk3Qu1RNcmYJp9RJx4,239
-toollib/__init__.py,sha256=xxrMISBqlXevyiWDwoU4x7_Rjm7H3Aqgqg79DF0vh8U,223
-toollib/autodriver.py,sha256=OuLfaTTH4URu9CWI1vZbDwUT9XBbm50QFxvWE3oKZI4,5333
-toollib/crypto.py,sha256=zZVChb0ReG8KmIpSHXwhfLJOM5cbqUfVMI6ZVsQ-BbI,5568
-toollib/decorator.py,sha256=4jCwvUHZeKFC6iOjt_5leaQsUiEQrevMTW7cGh8n8TQ,3140
-toollib/guid.py,sha256=bu5ekoHtTbSH_71GgHRD2daYdvunKRrxaE1b3IomuGU,7768
-toollib/kvalue.py,sha256=EQeOx6BWDVaACIdyNZFYvhn0wBzgDp9-UUUNSzHtGFY,6762
-toollib/locker.py,sha256=x-cH-Nx9UdGJNbaiP5jzQe9tiezluiMupSXe8LOFPBw,3471
-toollib/py2pyder.py,sha256=G91LAVjGwV3nCT8J_Lc9cDtCVZ3rI-8kW3MV6jzhnqo,5112
-toollib/redis_cli.py,sha256=uHMWwQl3S7n26B1yvskKmHOHEu37T4DxxIYoNjHk7uw,2040
-toollib/regexp.py,sha256=fMt0TBla6oCMgmKCV4LyHLmsYNykIwlXr723EKkjC6g,1592
-toollib/useragent.py,sha256=Rj6lUrOY7ltZFROSh6Y8txd0gNdGnsjbrAp56bOlci4,127411
-toollib/utils.py,sha256=hyqbV9SnDC2s2RZEVAgUBo4_AQdzcr7XzteWSUGToEk,10691
-toollib/validator.py,sha256=k5-Sa-9MNI7u3Lgw5dvk_G7Nfs-YVKzlJgTOJJF8_F0,3635
-toollib/xlsx.py,sha256=tmHZtUKPeX0qUSg7GAA1cnTH4j6sA2IFdJDa_uUFLaY,7534
+toollib/__debug__.py,sha256=Zufc3IPjo7CXX8yHwjgEATgQTCnWQONQf7kUZVCa7rE,222
+toollib/__init__.py,sha256=X8iwZvbyjhcQ2V39OtiF08jgnOhVtavQNSh1ZDNs4hg,223
+toollib/autodriver.py,sha256=nAdgBIcGgNanlzrBWxqwxCyD2YkFY_xCPIKEycr8u_E,5194
+toollib/crypto.py,sha256=4ShtA3lsJ8hiQnEpb4U00PCAL7xIRxpbHttF6q81w28,5393
+toollib/decorator.py,sha256=ab1oZjLx0KVUtktjZGdzlYDUjwhvhwUNuaRvTw-xW2o,3017
+toollib/guid.py,sha256=8F_mlCgkzT-zEvipqlO5UR-7qu8__w5zth1tZv5UEEI,7560
+toollib/kvalue.py,sha256=ovP155curlFodwQII-hhU-J7Ij1IL9vbm66RMmnYHaY,6558
+toollib/locker.py,sha256=4v_QSMM2GscBMqCfbtbil3L0CmVeDw3Px5h1kuFpAoY,3355
+toollib/py2pyder.py,sha256=-LOXfEoAaj6UfYXYMBlpN5yyhT483o4Q03ZR_usCZEE,4976
+toollib/redis_cli.py,sha256=cpG7xWmwMQ6aZ-ixczo-C-dUJ8rYZL_NLl_eu9KM2g4,1960
+toollib/regexp.py,sha256=6hlj0vlyUu_R_noRngZnrh-rI7GuzVqDZJNfDH_rP4w,1545
+toollib/useragent.py,sha256=RxuMKUxqS2s252r1FhxN5sYN-pM5MgbBPH1xL9DjuZQ,126354
+toollib/utils.py,sha256=KDk1JBxtUuqSaJDmqalARxmfVtwtQKlTZSws7oS7FJ4,10327
+toollib/validator.py,sha256=_7AM5nVV1Bw-adr8JQCEEif8BWlYaF47bJB4zv9qdV8,3522
+toollib/xlsx.py,sha256=NS_ttTA4Ab-iTcm-fiNyx2wSa-9hFoxaN9QTb45f70s,7320
 toollib/__pycache__/__init__.cpython-37.pyc,sha256=Vu7AOI93bA1auV8dUnTeSknroiP2qpkWA0bzOC1GQ5U,379
-toollib/__pycache__/__init__.cpython-38.pyc,sha256=exXkrMoktIT7G-FvdLUlrzp1nrK20TVQn-eddA5qhq0,383
+toollib/__pycache__/__init__.cpython-38.pyc,sha256=ppS9o-Y8Vp2WNrZ4DmDQGUV5ycsSaN6057zs5yabTlg,383
 toollib/__pycache__/autodriver.cpython-37.pyc,sha256=7IVsYpRufeHFBtUqZCboIjTwc2TWAfbf0ob84imr_M0,4695
-toollib/__pycache__/autodriver.cpython-38.pyc,sha256=WlWMeB8RWo86geJX_i2TumjC_8DioAXheqJzFodnP5Y,4669
+toollib/__pycache__/autodriver.cpython-38.pyc,sha256=vgmJYox5lTxlxUceH4Wejf_nZKr1fVEq3ay8DIhfWoQ,4669
 toollib/__pycache__/crypto.cpython-37.pyc,sha256=nSkJ3NuQ-d8a21Y4aSoLOMKPAyMbrIojXPaB8Fb1G7E,4952
-toollib/__pycache__/crypto.cpython-38.pyc,sha256=OcocjFn2eHkij9AqsjkclBemjHBRB86M-KP-wn2GgPk,4953
+toollib/__pycache__/crypto.cpython-38.pyc,sha256=Jy-ndsgH-IR2bCf805Z4ajaD58BDUEh1ly4CTnSSyaY,4953
 toollib/__pycache__/decorator.cpython-37.pyc,sha256=cHlZ6D4Pw8bh2C-cvksphmfuO4Pyj5ic2OOfv-qG86Q,3373
-toollib/__pycache__/decorator.cpython-38.pyc,sha256=-b6eVxYM6RRF6vkpB1jy_5r28UmSalNTkswh43qctMs,3578
+toollib/__pycache__/decorator.cpython-38.pyc,sha256=OIM0iALjTV1mfiiycdMVke95xv1U5YOiizziO1yHRvk,3578
 toollib/__pycache__/guid.cpython-37.pyc,sha256=SCof9UYOyCgcQAbfIMA1xgEnFpToDeRIV3u9g6KJlYM,6572
-toollib/__pycache__/guid.cpython-38.pyc,sha256=KkRIiK1jYAw8W3dXiKkpLnKqkofHsjICFC2eX9fIidQ,6676
+toollib/__pycache__/guid.cpython-38.pyc,sha256=mZ7iiTZUcC4E69V8ZUmIDeclfL44TF8nG6YMEzqZiW4,6676
 toollib/__pycache__/kvalue.cpython-37.pyc,sha256=Se5iULHTO2oEvdt3t0S1aAf1o61JF5n6l2y0mwrz954,6615
-toollib/__pycache__/kvalue.cpython-38.pyc,sha256=TgEW4YeqFkncsmtL75osrL1hrCEXw9cxu8X2bJnjPpA,6635
+toollib/__pycache__/kvalue.cpython-38.pyc,sha256=e1nqYf8tHXwKqho60Yh4GKkGZe7Ju7ecgcxdABuTqFc,6635
 toollib/__pycache__/locker.cpython-37.pyc,sha256=sjSOG2-OaYRExRTGjRFbuGV4LCe3NAK9BbC_emWOvrc,3163
-toollib/__pycache__/locker.cpython-38.pyc,sha256=knebhCLVHjdS8qzT-DXwS1jUmep_w5ar9ZpRDM2_jHU,3193
+toollib/__pycache__/locker.cpython-38.pyc,sha256=ejJm39DlSCjuf4BTsdevjO6ni0EbTplB-vi-cDE25RY,3193
 toollib/__pycache__/py2pyder.cpython-37.pyc,sha256=SkmX7Sf-DB-HoPZmjtY-CMZKgAaboFQzjnCsg3oqlIE,2620
-toollib/__pycache__/py2pyder.cpython-38.pyc,sha256=_E24cVb0FTTcEfsEX5Kk8DTsl0LJRChHAzJj3ooVzhA,4687
+toollib/__pycache__/py2pyder.cpython-38.pyc,sha256=Hp1OeV71Ehlt-dz4DmMxtvXbRCvs2j2FSS1xUbdyx_s,4687
 toollib/__pycache__/redis_cli.cpython-37.pyc,sha256=9KszF9Xt7X0x4BeMq_qzN31zfUU8eiGt-A5d9NDqxhE,2404
-toollib/__pycache__/redis_cli.cpython-38.pyc,sha256=UWPTljvB_yJE8MvZ60nS0AQE8QtAh1gMYuLJubs0s60,2433
+toollib/__pycache__/redis_cli.cpython-38.pyc,sha256=RJ1w0DEhtufC__NPPPC3vlIlKmerdn6FVaWJ9T0ywtw,2433
 toollib/__pycache__/regexp.cpython-37.pyc,sha256=jpncLe1n55Y0sG567ic0ZaNpFOw3-j3bRV_DMfqG_kw,1487
-toollib/__pycache__/regexp.cpython-38.pyc,sha256=408erEBawjfk5nHdFaw5Cg3EuXO6LEzBGbGJ0vK-nN8,1491
+toollib/__pycache__/regexp.cpython-38.pyc,sha256=1DwmxpiMmT6Q2MKfv1CIzGnS7vrhGgJKUl1z6QQUypM,1491
 toollib/__pycache__/useragent.cpython-37.pyc,sha256=YC8FPA91Cq6iEcurF55TASDv68WI_kwPM9pO9avNGCQ,126034
-toollib/__pycache__/useragent.cpython-38.pyc,sha256=flBFKIC2bLl7pohd2PIOCa-EPS5QfF8xWsb-4F83Rtw,125990
+toollib/__pycache__/useragent.cpython-38.pyc,sha256=1_aALIoXehTeQRLGrVD6P390NLW5B8X6hxrVZ2pC6BI,125990
 toollib/__pycache__/utils.cpython-37.pyc,sha256=Lhk0DpW0BkXIPE8xntSghfGmVX2KhFIQoxacbyd9EQ8,9234
-toollib/__pycache__/utils.cpython-38.pyc,sha256=GSfL3-JsZYXl_NcY_i_7wQNuO6QhBjG_wQtiXtSCgLQ,9986
+toollib/__pycache__/utils.cpython-38.pyc,sha256=_aw8E4rH1xP_KhjpACJkEMGaSH6CVRhywMI1I9Ezjhw,9986
 toollib/__pycache__/validator.cpython-37.pyc,sha256=AL2ln7oMVkMgwyKm8GyQ7vDX5I0D6Rh78J2pRFeV0JQ,3526
-toollib/__pycache__/validator.cpython-38.pyc,sha256=SwPdoCG6YQ7jRaAIA1-3JGEn24Dm7dpkPH-E3QU_ePI,3154
+toollib/__pycache__/validator.cpython-38.pyc,sha256=prMJbnBe_EgA2qVqcCc0rj7-w83mRhH1Y0HNoTefkQo,3154
 toollib/__pycache__/xlsx.cpython-37.pyc,sha256=_5lYw9NFWMxwK6gjv5xhsoqJxJqpQvj5GnN6a92r6NE,6010
-toollib/__pycache__/xlsx.cpython-38.pyc,sha256=pgF8r6fDJrGO8eln2ugll8wCDRJEOtgDAWupmsuw0Xg,6003
+toollib/__pycache__/xlsx.cpython-38.pyc,sha256=dCUK0qMMWp1B30YDGkC6Bb_nG5aeVJfkSNxptb0cP3c,6003
 toollib/common/UnRAR.exe,sha256=veSCqrCtSavPRssKPX_USi9ujmSaz1fmbFkIVCaoZQQ,369880
-toollib/common/__init__.py,sha256=LYMolB3pNN0ehe2Sq3UGc1LwO9AMkgkLH7pI3XbM0j8,104
-toollib/common/constor.py,sha256=GNVEz7a6k9pCOo2zP7BbD1hS8gE2zPIbEurgSfNb268,1217
-toollib/common/error.py,sha256=wAnZEeJX93bUjz2iVViUdpziDjcCGzwfdaN76BWAsdc,492
-toollib/common/rarfile.py,sha256=MHbGeCOaI5LphomIE8Pcfbhkw9hcFQGlJV_7_tFHfFI,103206
-toollib/common/zipfile.py,sha256=RbDl_6urII0B2hSv49Cdy0LOYZF8mwo6JpsXan2aLsg,83375
+toollib/common/__init__.py,sha256=pJQQDHQXkODKViConHezXdg1Y5S3fRVZUtO_Y6Akn64,96
+toollib/common/constor.py,sha256=nKfL-bwRXgvZDs7NiCZzOKLMLKLBva0OGmaJcaZe-o4,1198
+toollib/common/error.py,sha256=YwjXYo7H7WKodF5CEIldpR6mupSfdO_LAqe4I_5moy0,464
+toollib/common/rarfile.py,sha256=spq4xFwYKsuBc4nZsMAlD1wFE11sxbdS6ymxcXs5cPc,99841
+toollib/common/zipfile.py,sha256=ZBb2sqbFq6nI4AtO_sTK3psAkn9fVytrmIgEfz65e5U,81196
 toollib/common/__pycache__/__init__.cpython-37.pyc,sha256=EW7-FgFo2_9c-rezyYB0-vnEspug-kkTppLQukOB4iw,244
-toollib/common/__pycache__/__init__.cpython-38.pyc,sha256=6ZTk4lU_SLefFR9dOhaNIFVNpWKePkL_gizHZVIBSDA,248
+toollib/common/__pycache__/__init__.cpython-38.pyc,sha256=HM3P_wfl9qUkirQ3NW-h6p3uiLCas9xxqZf1OQtjQ0g,248
 toollib/common/__pycache__/constor.cpython-37.pyc,sha256=uzxbFxCz6Kyfuvflm8930rd82VhrWa4Vpo3g0Ht3YIw,1305
-toollib/common/__pycache__/constor.cpython-38.pyc,sha256=_6vdDP6NVCflU-5VIsoprom0g0uwdc-lPZ1a2uOBqmI,1313
+toollib/common/__pycache__/constor.cpython-38.pyc,sha256=QplmisfqGTZ21OZlZXiuYv01YdZeLLus0xfbBnFDm9Y,1313
 toollib/common/__pycache__/error.cpython-37.pyc,sha256=dGN8mo1_9ieYxfHImdL0f_zEgERCM_Jg4YEuHbskXqQ,1086
-toollib/common/__pycache__/error.cpython-38.pyc,sha256=H4DKYAjU0xKZx4SUzLL4MPaUi2PzNm0IsRFxs01pXI8,1093
+toollib/common/__pycache__/error.cpython-38.pyc,sha256=LAa7WzMXUnYO9RFLQkPKn5IGeZZA4ldQJodiuy-cNLQ,1093
 toollib/common/__pycache__/rarfile.cpython-37.pyc,sha256=-VGpbVRwV_kQp2how2ga3TGogpXrYQd-oizqyx72s5Y,84047
-toollib/common/__pycache__/rarfile.cpython-38.pyc,sha256=dMl9OMdfiZdBWq3ExTAWq3wcbFqV1-o8ObdW8HPg23o,84059
+toollib/common/__pycache__/rarfile.cpython-38.pyc,sha256=5z-O-NdrCR9JGCJ7k5ByrrJtZFi_fTH-Ff_5-D5ARCo,84059
 toollib/common/__pycache__/zipfile.cpython-37.pyc,sha256=NcLsqGEsYHU7FxbUsbIHLVOApTaVr-XOxwsAi21SgSY,50340
-toollib/common/__pycache__/zipfile.cpython-38.pyc,sha256=naqZQu7iIrFjzb8Ye2W9bRgFkjneLfcR8UznwX2tsJ4,50637
-toollib/tcli/__init__.py,sha256=yeNeV2TviDPBtnuwy_mcSkp1a5O644Ag7bwNunraMLE,173
-toollib/tcli/__main__.py,sha256=_ahGtZ41Qh-rxYzQKj3xkAg8PTV_4BP5SnhXQjwI2pQ,212
-toollib/tcli/base.py,sha256=oOODHLPndMJcvB80skfh1MEpbD56CTZ2EPogIacH1eA,2836
-toollib/tcli/cmder.py,sha256=kR5TDhcC90iFrbhyTIVL9IdNcThHVi7BFUJY_O79Cik,1543
-toollib/tcli/helper.py,sha256=KIggRC7gyqzHjg9ualKAl_qxJSXLzMbW5gIHqyrVWtY,1640
-toollib/tcli/option.py,sha256=6XSDZFVLxSO8pKRD5g5lkEc9AmBdO8UmJGdiwzk2EYA,2326
-toollib/tcli/commands/__init__.py,sha256=GqhXDCHXkWWP7jbakr3sn5kq6yYaBKZQsL5-LACTCDc,104
-toollib/tcli/commands/_docker.py,sha256=ZvkSR1TslujSNG_hJkrdz-ULI5hKdiC7YgZkAU9ckbg,4761
-toollib/tcli/commands/_py2pyd.py,sha256=8KjMIOi0QSCTjnhq38aVMUmZTQvIHPVdbNmFUK5TBUA,1483
-toollib/tcli/commands/_set_conda.py,sha256=vxcFqLMMQy3TaDgerWaLZsF5qD6VXDoEeFN13bX2SCs,867
-toollib/tcli/commands/_set_mirrors.py,sha256=Fyl-RZaf51dYKlf-IHVsySutTQeO-NzOPrcPVZjraP0,932
-toollib/tcli/commands/_set_pip.py,sha256=cMOg8SCMBkAWdN1zM33yzxc8Yhsa2CjalmPa84wsFaY,1095
-toollib/tcli/commands/_set_sshkey.py,sha256=pth3Ar3Ds0ARkTMy2L2Z2tkD3aPdotXWLH_HEbrg5tc,1313
-toollib/tcli/commands/plugins/__init__.py,sha256=O-y-Izo9lgukNf4tBAAN8OkjGmjoU-l6aDpH8-y1iz4,102
+toollib/common/__pycache__/zipfile.cpython-38.pyc,sha256=z0H6DIpnPWp_q9cbRie0Y4zzsVV8bff2d57hEaL-EVc,50637
+toollib/tcli/__init__.py,sha256=MIhU4Uunwkm57pP2g4h_l2cUIoQYToibByi58Zc3Ol0,162
+toollib/tcli/__main__.py,sha256=W-fMAXaSYErBxDp10d8Z5e0c1C2kuDlmqLpY7GnCQng,195
+toollib/tcli/base.py,sha256=CVfFOjg1BNXflx9bvEAaebovPSLr9kyUxwupNOBdWtg,2745
+toollib/tcli/cmder.py,sha256=nkqcCNT1vbgUWprTv9xkKyfw56o8cvkWU88-1_vtJrw,1487
+toollib/tcli/helper.py,sha256=D3VehVTI7pHSDYikl0et9LHeeTVCo0gAmb-67G61gG4,1570
+toollib/tcli/option.py,sha256=Y1xRBQ33fsyxSHa9KRUeffXstvRPbS0DgztE3kpncps,2249
+toollib/tcli/commands/__init__.py,sha256=zJNFoyIi13Y5Pb0hU5LnMd9KN1Ap47YhHQR-F2Psl3U,96
+toollib/tcli/commands/_docker.py,sha256=qsBapzwxrhU6Ea8TbHu_r8fi95GnqqWJykErrsYTLJM,4638
+toollib/tcli/commands/_py2pyd.py,sha256=tR6ZDwb3gqxX5ekduhui57h80EgyNopNJG2YSTk1Pe8,1438
+toollib/tcli/commands/_set_conda.py,sha256=i04ApLxoMPNUyiywR3EggqlxcgRw7N48VOiI8p-jVSI,830
+toollib/tcli/commands/_set_mirrors.py,sha256=plCG9QMcuCEFGIpN2xMJtD3m1Xu5AS-90Ul5Y7SLau0,894
+toollib/tcli/commands/_set_pip.py,sha256=diN6CmuRG8PP-cXtE_3heVk6K3fQSJuvfbctUcDrKtk,1053
+toollib/tcli/commands/_set_sshkey.py,sha256=CZtYDTS9IrncO2wGZJjgGUj7r6T8eUm5zE-mOOBHyCM,1267
+toollib/tcli/commands/plugins/__init__.py,sha256=paflNoZKFVYyIJX_YMUFcb3x__fQtUiDhlQGcMs5lVk,94
 toollib/tcli/commands/plugins/docker-compose.yml,sha256=T4MM1kntDQ-cfTxq1pIIkMnCiih2UxZtgu3KO_L48l4,2176
 toollib/tcli/commands/plugins/set_mirrors.sh,sha256=-gle6q9UwfYg-UqzJMlgJepcRBpoNMZ2tUikP_yj5hs,4802
-toollib/tcli/commands/plugins/set_sshkey.sh,sha256=fK2BBD6BDW-3ezNcG4CnA9JMgWTKKuJXpjgKyrAenlQ,2583
-toollib-1.3.5.dist-info/LICENSE,sha256=uu3UY_2aZxeVu7QE12nXJpIXQoWjFzO3BWzfdDjre_g,1074
-toollib-1.3.5.dist-info/METADATA,sha256=yP93uqwd98lbvG4SJ37eOOqiWayqUJ15ZOhuKx6_hRE,1996
-toollib-1.3.5.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-toollib-1.3.5.dist-info/entry_points.txt,sha256=7N2AT3Z2zyAJSpFsYs9cKMDU_O2NXU65UHvN1XFBHWc,54
-toollib-1.3.5.dist-info/top_level.txt,sha256=PxMR9mJbi7GwRfLOQjTsMqKIBQYbFQdFAteDlL1e7Y0,8
-toollib-1.3.5.dist-info/RECORD,,
+toollib/tcli/commands/plugins/set_sshkey.sh,sha256=kWscXG99gBfr3V28yar3wDEH0O1UghA9Imv6H-dfrzs,2481
+toollib-1.3.6.dist-info/LICENSE,sha256=-0kjMmKZn3rpnoeWxUwT4TWUOdisgw4UfEs1eYmFnaM,1055
+toollib-1.3.6.dist-info/METADATA,sha256=dOGA6EbG1YtncqdyBI0ACN16zf92jn8ua1c5gcPGeBU,1996
+toollib-1.3.6.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+toollib-1.3.6.dist-info/entry_points.txt,sha256=7N2AT3Z2zyAJSpFsYs9cKMDU_O2NXU65UHvN1XFBHWc,54
+toollib-1.3.6.dist-info/top_level.txt,sha256=PxMR9mJbi7GwRfLOQjTsMqKIBQYbFQdFAteDlL1e7Y0,8
+toollib-1.3.6.dist-info/RECORD,,
```

